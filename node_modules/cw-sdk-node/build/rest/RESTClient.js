"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RESTClient = void 0;
const tslib_1 = require("tslib");
const superagent_1 = tslib_1.__importDefault(require("superagent"));
const errors_1 = require("./errors");
const credentials_1 = require("../util/credentials");
const helpers_1 = require("../util/helpers");
const version_1 = tslib_1.__importDefault(require("../version"));
class RESTClient {
    constructor(options) {
        const restOpts = credentials_1.loadRESTCredentials(options);
        this.apiKey = restOpts.creds.apiKey;
        this.apiRoute = restOpts.creds.url;
    }
    getRestURL(relativeRoute) {
        return new URL(relativeRoute, this.apiRoute).href;
    }
    getRestData(relativeRoute, params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const request = superagent_1.default.get(this.getRestURL(relativeRoute));
                if (this.apiKey) {
                    request.set('X-CW-API-Key', this.apiKey);
                    request.set('User-Agent', `cw-sdk-node@${version_1.default}`);
                }
                if (params) {
                    request.query(params);
                }
                const response = yield request;
                this.lastAllowance = response.body.allowance;
                return response.body.result;
            }
            catch (e) {
                if (e.status !== undefined) {
                    throw new errors_1.RestError(e);
                }
                throw e;
            }
        });
    }
    /**
     * Returns the most recently retrieved REST allowance data.
     */
    getAllowance() {
        if (this.lastAllowance) {
            return this.lastAllowance;
        }
        else {
            throw new Error('You must make a request before getting your allowance data.');
        }
    }
    /**
     * Returns a list of all supported exchanges.
     * @see https://cryptowat.ch/docs/api#pairs-index
     */
    getExchanges() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.getRestData('/exchanges');
        });
    }
    /**
     * Returns a single exchange, with associated routes.
     * @param exchangeSymbol string (example: 'kraken')
     * @see https://cryptowat.ch/docs/api#exchange-details
     */
    getExchange(exchangeSymbol) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.getRestData(`/exchanges/${exchangeSymbol}`);
        });
    }
    /**
     * Returns all pairs (in no particular order).
     * @see https://cryptowat.ch/docs/api#pairs-index
     */
    getPairsIndex() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.getRestData('/pairs');
        });
    }
    /**
     * Returns a single pair. Lists all markets for this pair.
     * @param pairSymbol string (example: 'btcusd')
     * @see https://cryptowat.ch/docs/api#pair-details
     */
    getPair(pairSymbol) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.getRestData(`/pairs/${pairSymbol}`);
        });
    }
    /**
     * Returns a list of all supported markets.
     * @see https://cryptowat.ch/docs/api#market-index
     */
    getMarkets() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.getRestData('/markets');
        });
    }
    /**
     * Returns the market summary for all supported markets. Some values may be out of date by a few seconds.
     * @see https://cryptowat.ch/docs/api#summaries
     */
    getSummaries() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.getRestData('/markets/summaries');
        });
    }
    /**
     * Returns a single market summary.
     * @param exchangeSymbol string (Example: 'kraken')
     * @param pairSymbol string (Example: 'btcusd')
     * @see https://cryptowat.ch/docs/api#market-summary
     */
    getSummary(exchangeSymbol, pairSymbol) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.getRestData(`/markets/${exchangeSymbol}/${pairSymbol}/summary`);
        });
    }
    /**
     * Returns a list of supported markets for a specific exchange.
     * @param exchangeSymbol string (Example: 'kraken')
     * @see https://cryptowat.ch/docs/api#market-index
     */
    getExchangeMarkets(exchangeSymbol) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.getRestData(`/markets/${exchangeSymbol}`);
        });
    }
    /**
     * Returns a single market, with associated routes.
     * @param exchangeSymbol string (Example: 'kraken')
     * @param pairSymbol string (Example: 'btcusd')
     * @see https://cryptowat.ch/docs/api#market-details
     */
    getMarketDescription(exchangeSymbol, pairSymbol) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.getRestData(`/markets/${exchangeSymbol}/${pairSymbol}`);
        });
    }
    /**
     * Returns a single market.
     * @param marketSelector MarketSelector id of market (number) or MarketSymbol (Example: {exchange: 'kraken', base: 'btc', quote:'usd'})
     */
    getMarket(marketSelector) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (typeof marketSelector === 'number') {
                return yield this.getMarketByID(marketSelector);
            }
            else {
                return yield this.getMarketBySymbol(marketSelector);
            }
        });
    }
    /**
     * Returns a single market.
     * @param marketSymbol MarketSymbol (Example: {exchange: 'kraken', base: 'btc', quote:'usd'})
     */
    getMarketBySymbol(marketSymbol) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (yield this.getRestData(`/v2/markets`, marketSymbol))[0];
        });
    }
    /**
     * Returns a single market.
     * @param marketID number id of specific market.
     */
    getMarketByID(marketID) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.getRestData(`/v2/markets/${marketID}`);
        });
    }
    /**
     * Returns a single asset.
     * @param assetSelector number|string id of asset (number) or asset symbol (Example: 'btc')
     */
    getAsset(assetSelector) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (typeof assetSelector === 'number') {
                return yield this.getAssetByID(assetSelector);
            }
            else {
                return yield this.getAssetBySymbol(assetSelector);
            }
        });
    }
    /**
     * Returns a single asset, with associated routes.
     * @param assetSymbol string symbol for specific requested asset (Examples: 'btc', 'usd', 'eth', 'jpy', etc...)
     */
    getAssetBySymbol(assetSymbol) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.getRestData(`/v2/assets`, { symbol: assetSymbol });
        });
    }
    /**
     * Returns a single market, with associated routes.
     * @param assetId number id of specific asset
     */
    getAssetByID(assetId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.getRestData(`/v2/assets/${assetId}`);
        });
    }
    /**
     * Returns a market's OHLC candlestick data.
     * @param exchangeSymbol string (Example: 'kraken')
     * @param pairSymbol string (Example: 'btcusd')
     * @param {OHLCOptions} options Optional - see API documentation
     * @see https://cryptowat.ch/docs/api#market-ohlc
     */
    getOHLC(exchangeSymbol, pairSymbol, options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.getRestData(`/markets/${exchangeSymbol}/${pairSymbol}/ohlc`, options).then((marketOHLC) => {
                const result = {};
                for (const key in marketOHLC) {
                    result[key] = marketOHLC[key].map((value) => ({
                        closeTime: value[0],
                        openPrice: value[1].toString(),
                        highPrice: value[2].toString(),
                        lowPrice: value[3].toString(),
                        closePrice: value[4].toString(),
                        volume: value[5].toString(),
                        quoteVolume: value[6].toString()
                    }));
                }
                return result;
            });
        });
    }
    /**
     * Returns a market's order book.
     * @param exchangeSymbol string (Example: 'kraken')
     * @param pairSymbol string (Example: 'btcusd')
     * @see https://cryptowat.ch/docs/api#market-orderbook
     */
    getOrderBookSnapshot(exchangeSymbol, pairSymbol) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.getRestData(`/markets/${exchangeSymbol}/${pairSymbol}/orderbook`).then(helpers_1.transformSnapshot);
        });
    }
    /**
     * Returns a market's last price.
     * @param exchangeSymbol string (Example: 'kraken')
     * @param pairSymbol string (Example: 'btcusd')
     * @see https://cryptowat.ch/docs/api#market-price
     */
    getPrice(exchangeSymbol, pairSymbol) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.getRestData(`/markets/${exchangeSymbol}/${pairSymbol}/price`);
        });
    }
    /**
     * Returns a market's most recent trades, incrementing chronologically.
     * @param exchangeSymbol string (Example: 'kraken')
     * @param pairSymbol string (Example: 'btcusd')
     * @see https://cryptowat.ch/docs/api#market-trades
     */
    getTrades(exchangeSymbol, pairSymbol) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.getRestData(`/markets/${exchangeSymbol}/${pairSymbol}/trades`).then((tradeRaw) => tradeRaw.map((trade) => ({
                id: trade[0],
                timestamp: trade[1],
                price: trade[2].toString(),
                amount: trade[3].toString()
            })));
        });
    }
}
exports.RESTClient = RESTClient;
//# sourceMappingURL=RESTClient.js.map