"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrderBook = void 0;
const helpers_1 = require("../util/helpers");
/**
 * Internal class for handling OrderBook delta transforms
 */
class OrderBook {
    constructor(snapshot) {
        this.seqNum = 0;
        this.bids = [];
        this.asks = [];
        if (snapshot) {
            this.applySnapshot(snapshot);
        }
    }
    getSnapshot() {
        return {
            seqNum: this.seqNum,
            bids: this.bids,
            asks: this.asks
        };
    }
    applySnapshot(snapshot) {
        this.seqNum = snapshot.seqNum;
        this.bids = snapshot.bids;
        this.asks = snapshot.asks;
    }
    applyDelta(delta, ignoreSeqNum = false) {
        if (!ignoreSeqNum && delta.seqNum - 1 !== this.seqNum) {
            throw new Error("New delta sequence number must be equal to the previous snapshot's sequence number plus 1.\n" +
                `Previous Snapshot SeqNum: ${this.seqNum}\n` +
                `New Delta SeqNum: ${delta.seqNum}`);
        }
        this.bids = this.applyOrderDeltas(delta.bids, 'bids');
        this.asks = this.applyOrderDeltas(delta.asks, 'asks');
        this.seqNum = delta.seqNum;
        return this;
    }
    applyOrderDeltas(orderDeltas, deltaType) {
        const deltaItems = [];
        orderDeltas.set.forEach((order, index) => {
            deltaItems.push({
                action: 'set',
                order,
                index,
                overridden: false
            });
        });
        orderDeltas.remove.forEach((order, index) => {
            deltaItems.push({
                action: 'remove',
                order: {
                    amount: '0',
                    price: order
                },
                index,
                overridden: false
            });
        });
        deltaItems.sort((i, j) => helpers_1.sortDeltaItems(i, j, deltaType === 'bids'));
        let newOrders = [];
        let currentOrdersIndex = 0;
        for (const index in deltaItems) {
            if (deltaItems[index].overridden) {
                continue;
            }
            // eslint-disable-next-line prefer-const
            let { exists, index: insertionIndex } = helpers_1.binarySearchOrders(this[deltaType], deltaItems[index].order.price, currentOrdersIndex, deltaType === 'bids');
            newOrders = [...newOrders, ...this[deltaType].slice(currentOrdersIndex, insertionIndex)];
            switch (deltaItems[index].action) {
                case 'set': {
                    newOrders = [...newOrders, deltaItems[index].order];
                    if (exists) {
                        insertionIndex += 1;
                    }
                    break;
                }
                case 'remove': {
                    if (!exists) {
                        break;
                    }
                    insertionIndex += 1;
                }
            }
            currentOrdersIndex = insertionIndex;
        }
        newOrders = [
            ...newOrders,
            ...this[deltaType].slice(currentOrdersIndex, this[deltaType].length)
        ];
        return newOrders;
    }
}
exports.OrderBook = OrderBook;
//# sourceMappingURL=OrderBook.js.map