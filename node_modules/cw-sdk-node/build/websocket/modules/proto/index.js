/* Generated by Makefile */
/* tslint:disable */
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";
var $protobuf = require("protobufjs/minimal");
// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
$root.google = (function () {
    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};
    google.protobuf = (function () {
        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        var protobuf = {};
        protobuf.Any = (function () {
            /**
             * Properties of an Any.
             * @memberof google.protobuf
             * @interface IAny
             * @property {string|null} [type_url] Any type_url
             * @property {Uint8Array|null} [value] Any value
             */
            /**
             * Constructs a new Any.
             * @memberof google.protobuf
             * @classdesc Represents an Any.
             * @implements IAny
             * @constructor
             * @param {google.protobuf.IAny=} [properties] Properties to set
             */
            function Any(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Any type_url.
             * @member {string} type_url
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.type_url = "";
            /**
             * Any value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.value = $util.newBuffer([]);
            /**
             * Creates a new Any instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny=} [properties] Properties to set
             * @returns {google.protobuf.Any} Any instance
             */
            Any.create = function create(properties) {
                return new Any(properties);
            };
            /**
             * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type_url != null && Object.hasOwnProperty.call(message, "type_url"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.type_url);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.value);
                return writer;
            };
            /**
             * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an Any message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.type_url = reader.string();
                            break;
                        case 2:
                            message.value = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes an Any message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an Any message.
             * @function verify
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Any.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    if (!$util.isString(message.type_url))
                        return "type_url: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };
            /**
             * Creates an Any message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Any} Any
             */
            Any.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Any)
                    return object;
                var message = new $root.google.protobuf.Any();
                if (object.type_url != null)
                    message.type_url = String(object.type_url);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };
            /**
             * Creates a plain object from an Any message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.Any} message Any
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Any.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type_url = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    object.type_url = message.type_url;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };
            /**
             * Converts this Any to JSON.
             * @function toJSON
             * @memberof google.protobuf.Any
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Any.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Any;
        })();
        protobuf.Duration = (function () {
            /**
             * Properties of a Duration.
             * @memberof google.protobuf
             * @interface IDuration
             * @property {number|Long|null} [seconds] Duration seconds
             * @property {number|null} [nanos] Duration nanos
             */
            /**
             * Constructs a new Duration.
             * @memberof google.protobuf
             * @classdesc Represents a Duration.
             * @implements IDuration
             * @constructor
             * @param {google.protobuf.IDuration=} [properties] Properties to set
             */
            function Duration(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Duration seconds.
             * @member {number|Long} seconds
             * @memberof google.protobuf.Duration
             * @instance
             */
            Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Duration nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Duration
             * @instance
             */
            Duration.prototype.nanos = 0;
            /**
             * Creates a new Duration instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.IDuration=} [properties] Properties to set
             * @returns {google.protobuf.Duration} Duration instance
             */
            Duration.create = function create(properties) {
                return new Duration(properties);
            };
            /**
             * Encodes the specified Duration message. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.IDuration} message Duration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Duration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.seconds);
                if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.nanos);
                return writer;
            };
            /**
             * Encodes the specified Duration message, length delimited. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.IDuration} message Duration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Duration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Duration message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Duration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Duration} Duration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Duration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Duration();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.seconds = reader.int64();
                            break;
                        case 2:
                            message.nanos = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a Duration message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Duration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Duration} Duration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Duration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Duration message.
             * @function verify
             * @memberof google.protobuf.Duration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Duration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };
            /**
             * Creates a Duration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Duration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Duration} Duration
             */
            Duration.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Duration)
                    return object;
                var message = new $root.google.protobuf.Duration();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };
            /**
             * Creates a plain object from a Duration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.Duration} message Duration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Duration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };
            /**
             * Converts this Duration to JSON.
             * @function toJSON
             * @memberof google.protobuf.Duration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Duration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Duration;
        })();
        protobuf.Empty = (function () {
            /**
             * Properties of an Empty.
             * @memberof google.protobuf
             * @interface IEmpty
             */
            /**
             * Constructs a new Empty.
             * @memberof google.protobuf
             * @classdesc Represents an Empty.
             * @implements IEmpty
             * @constructor
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             */
            function Empty(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Creates a new Empty instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             * @returns {google.protobuf.Empty} Empty instance
             */
            Empty.create = function create(properties) {
                return new Empty(properties);
            };
            /**
             * Encodes the specified Empty message. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
            /**
             * Encodes the specified Empty message, length delimited. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an Empty message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Empty();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes an Empty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an Empty message.
             * @function verify
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Empty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
            /**
             * Creates an Empty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Empty} Empty
             */
            Empty.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Empty)
                    return object;
                return new $root.google.protobuf.Empty();
            };
            /**
             * Creates a plain object from an Empty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.Empty} message Empty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Empty.toObject = function toObject() {
                return {};
            };
            /**
             * Converts this Empty to JSON.
             * @function toJSON
             * @memberof google.protobuf.Empty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Empty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Empty;
        })();
        protobuf.Timestamp = (function () {
            /**
             * Properties of a Timestamp.
             * @memberof google.protobuf
             * @interface ITimestamp
             * @property {number|Long|null} [seconds] Timestamp seconds
             * @property {number|null} [nanos] Timestamp nanos
             */
            /**
             * Constructs a new Timestamp.
             * @memberof google.protobuf
             * @classdesc Represents a Timestamp.
             * @implements ITimestamp
             * @constructor
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             */
            function Timestamp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Timestamp seconds.
             * @member {number|Long} seconds
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Timestamp nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.nanos = 0;
            /**
             * Creates a new Timestamp instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             * @returns {google.protobuf.Timestamp} Timestamp instance
             */
            Timestamp.create = function create(properties) {
                return new Timestamp(properties);
            };
            /**
             * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.seconds);
                if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.nanos);
                return writer;
            };
            /**
             * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Timestamp message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.seconds = reader.int64();
                            break;
                        case 2:
                            message.nanos = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a Timestamp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Timestamp message.
             * @function verify
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Timestamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };
            /**
             * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Timestamp} Timestamp
             */
            Timestamp.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Timestamp)
                    return object;
                var message = new $root.google.protobuf.Timestamp();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };
            /**
             * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.Timestamp} message Timestamp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Timestamp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };
            /**
             * Converts this Timestamp to JSON.
             * @function toJSON
             * @memberof google.protobuf.Timestamp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Timestamp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Timestamp;
        })();
        return protobuf;
    })();
    return google;
})();
$root.ProtobufBroker = (function () {
    /**
     * Namespace ProtobufBroker.
     * @exports ProtobufBroker
     * @namespace
     */
    var ProtobufBroker = {};
    ProtobufBroker.BrokerSessionMessage = (function () {
        /**
         * Properties of a BrokerSessionMessage.
         * @memberof ProtobufBroker
         * @interface IBrokerSessionMessage
         * @property {ProtobufBroker.BrokerSessionMessage.ISession|null} [session] BrokerSessionMessage session
         * @property {ProtobufBroker.BrokerSessionMessage.IAnonymousTradingSession|null} [anonymousTradingSession] BrokerSessionMessage anonymousTradingSession
         * @property {number|Long|null} [marketId] BrokerSessionMessage marketId
         */
        /**
         * Constructs a new BrokerSessionMessage.
         * @memberof ProtobufBroker
         * @classdesc Represents a BrokerSessionMessage.
         * @implements IBrokerSessionMessage
         * @constructor
         * @param {ProtobufBroker.IBrokerSessionMessage=} [properties] Properties to set
         */
        function BrokerSessionMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * BrokerSessionMessage session.
         * @member {ProtobufBroker.BrokerSessionMessage.ISession|null|undefined} session
         * @memberof ProtobufBroker.BrokerSessionMessage
         * @instance
         */
        BrokerSessionMessage.prototype.session = null;
        /**
         * BrokerSessionMessage anonymousTradingSession.
         * @member {ProtobufBroker.BrokerSessionMessage.IAnonymousTradingSession|null|undefined} anonymousTradingSession
         * @memberof ProtobufBroker.BrokerSessionMessage
         * @instance
         */
        BrokerSessionMessage.prototype.anonymousTradingSession = null;
        /**
         * BrokerSessionMessage marketId.
         * @member {number|Long} marketId
         * @memberof ProtobufBroker.BrokerSessionMessage
         * @instance
         */
        BrokerSessionMessage.prototype.marketId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * BrokerSessionMessage SessionConfig.
         * @member {"session"|"anonymousTradingSession"|undefined} SessionConfig
         * @memberof ProtobufBroker.BrokerSessionMessage
         * @instance
         */
        Object.defineProperty(BrokerSessionMessage.prototype, "SessionConfig", {
            get: $util.oneOfGetter($oneOfFields = ["session", "anonymousTradingSession"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new BrokerSessionMessage instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.BrokerSessionMessage
         * @static
         * @param {ProtobufBroker.IBrokerSessionMessage=} [properties] Properties to set
         * @returns {ProtobufBroker.BrokerSessionMessage} BrokerSessionMessage instance
         */
        BrokerSessionMessage.create = function create(properties) {
            return new BrokerSessionMessage(properties);
        };
        /**
         * Encodes the specified BrokerSessionMessage message. Does not implicitly {@link ProtobufBroker.BrokerSessionMessage.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.BrokerSessionMessage
         * @static
         * @param {ProtobufBroker.IBrokerSessionMessage} message BrokerSessionMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BrokerSessionMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.session != null && Object.hasOwnProperty.call(message, "session"))
                $root.ProtobufBroker.BrokerSessionMessage.Session.encode(message.session, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.anonymousTradingSession != null && Object.hasOwnProperty.call(message, "anonymousTradingSession"))
                $root.ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession.encode(message.anonymousTradingSession, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.marketId != null && Object.hasOwnProperty.call(message, "marketId"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.marketId);
            return writer;
        };
        /**
         * Encodes the specified BrokerSessionMessage message, length delimited. Does not implicitly {@link ProtobufBroker.BrokerSessionMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.BrokerSessionMessage
         * @static
         * @param {ProtobufBroker.IBrokerSessionMessage} message BrokerSessionMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BrokerSessionMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a BrokerSessionMessage message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.BrokerSessionMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.BrokerSessionMessage} BrokerSessionMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BrokerSessionMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.BrokerSessionMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.session = $root.ProtobufBroker.BrokerSessionMessage.Session.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.anonymousTradingSession = $root.ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.marketId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a BrokerSessionMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.BrokerSessionMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.BrokerSessionMessage} BrokerSessionMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BrokerSessionMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a BrokerSessionMessage message.
         * @function verify
         * @memberof ProtobufBroker.BrokerSessionMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BrokerSessionMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.session != null && message.hasOwnProperty("session")) {
                properties.SessionConfig = 1;
                {
                    var error = $root.ProtobufBroker.BrokerSessionMessage.Session.verify(message.session);
                    if (error)
                        return "session." + error;
                }
            }
            if (message.anonymousTradingSession != null && message.hasOwnProperty("anonymousTradingSession")) {
                if (properties.SessionConfig === 1)
                    return "SessionConfig: multiple values";
                properties.SessionConfig = 1;
                {
                    var error = $root.ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession.verify(message.anonymousTradingSession);
                    if (error)
                        return "anonymousTradingSession." + error;
                }
            }
            if (message.marketId != null && message.hasOwnProperty("marketId"))
                if (!$util.isInteger(message.marketId) && !(message.marketId && $util.isInteger(message.marketId.low) && $util.isInteger(message.marketId.high)))
                    return "marketId: integer|Long expected";
            return null;
        };
        /**
         * Creates a BrokerSessionMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.BrokerSessionMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.BrokerSessionMessage} BrokerSessionMessage
         */
        BrokerSessionMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.BrokerSessionMessage)
                return object;
            var message = new $root.ProtobufBroker.BrokerSessionMessage();
            if (object.session != null) {
                if (typeof object.session !== "object")
                    throw TypeError(".ProtobufBroker.BrokerSessionMessage.session: object expected");
                message.session = $root.ProtobufBroker.BrokerSessionMessage.Session.fromObject(object.session);
            }
            if (object.anonymousTradingSession != null) {
                if (typeof object.anonymousTradingSession !== "object")
                    throw TypeError(".ProtobufBroker.BrokerSessionMessage.anonymousTradingSession: object expected");
                message.anonymousTradingSession = $root.ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession.fromObject(object.anonymousTradingSession);
            }
            if (object.marketId != null)
                if ($util.Long)
                    (message.marketId = $util.Long.fromValue(object.marketId)).unsigned = false;
                else if (typeof object.marketId === "string")
                    message.marketId = parseInt(object.marketId, 10);
                else if (typeof object.marketId === "number")
                    message.marketId = object.marketId;
                else if (typeof object.marketId === "object")
                    message.marketId = new $util.LongBits(object.marketId.low >>> 0, object.marketId.high >>> 0).toNumber();
            return message;
        };
        /**
         * Creates a plain object from a BrokerSessionMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.BrokerSessionMessage
         * @static
         * @param {ProtobufBroker.BrokerSessionMessage} message BrokerSessionMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BrokerSessionMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.marketId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.marketId = options.longs === String ? "0" : 0;
            if (message.session != null && message.hasOwnProperty("session")) {
                object.session = $root.ProtobufBroker.BrokerSessionMessage.Session.toObject(message.session, options);
                if (options.oneofs)
                    object.SessionConfig = "session";
            }
            if (message.anonymousTradingSession != null && message.hasOwnProperty("anonymousTradingSession")) {
                object.anonymousTradingSession = $root.ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession.toObject(message.anonymousTradingSession, options);
                if (options.oneofs)
                    object.SessionConfig = "anonymousTradingSession";
            }
            if (message.marketId != null && message.hasOwnProperty("marketId"))
                if (typeof message.marketId === "number")
                    object.marketId = options.longs === String ? String(message.marketId) : message.marketId;
                else
                    object.marketId = options.longs === String ? $util.Long.prototype.toString.call(message.marketId) : options.longs === Number ? new $util.LongBits(message.marketId.low >>> 0, message.marketId.high >>> 0).toNumber() : message.marketId;
            return object;
        };
        /**
         * Converts this BrokerSessionMessage to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.BrokerSessionMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BrokerSessionMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        BrokerSessionMessage.Session = (function () {
            /**
             * Properties of a Session.
             * @memberof ProtobufBroker.BrokerSessionMessage
             * @interface ISession
             * @property {string|null} [userId] Session userId
             * @property {number|Long|null} [expires] Session expires
             * @property {string|null} [token] Session token
             * @property {string|null} [mfaToken] Session mfaToken
             */
            /**
             * Constructs a new Session.
             * @memberof ProtobufBroker.BrokerSessionMessage
             * @classdesc Represents a Session.
             * @implements ISession
             * @constructor
             * @param {ProtobufBroker.BrokerSessionMessage.ISession=} [properties] Properties to set
             */
            function Session(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Session userId.
             * @member {string} userId
             * @memberof ProtobufBroker.BrokerSessionMessage.Session
             * @instance
             */
            Session.prototype.userId = "";
            /**
             * Session expires.
             * @member {number|Long} expires
             * @memberof ProtobufBroker.BrokerSessionMessage.Session
             * @instance
             */
            Session.prototype.expires = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Session token.
             * @member {string} token
             * @memberof ProtobufBroker.BrokerSessionMessage.Session
             * @instance
             */
            Session.prototype.token = "";
            /**
             * Session mfaToken.
             * @member {string} mfaToken
             * @memberof ProtobufBroker.BrokerSessionMessage.Session
             * @instance
             */
            Session.prototype.mfaToken = "";
            /**
             * Creates a new Session instance using the specified properties.
             * @function create
             * @memberof ProtobufBroker.BrokerSessionMessage.Session
             * @static
             * @param {ProtobufBroker.BrokerSessionMessage.ISession=} [properties] Properties to set
             * @returns {ProtobufBroker.BrokerSessionMessage.Session} Session instance
             */
            Session.create = function create(properties) {
                return new Session(properties);
            };
            /**
             * Encodes the specified Session message. Does not implicitly {@link ProtobufBroker.BrokerSessionMessage.Session.verify|verify} messages.
             * @function encode
             * @memberof ProtobufBroker.BrokerSessionMessage.Session
             * @static
             * @param {ProtobufBroker.BrokerSessionMessage.ISession} message Session message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Session.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.userId);
                if (message.expires != null && Object.hasOwnProperty.call(message, "expires"))
                    writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.expires);
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.token);
                if (message.mfaToken != null && Object.hasOwnProperty.call(message, "mfaToken"))
                    writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.mfaToken);
                return writer;
            };
            /**
             * Encodes the specified Session message, length delimited. Does not implicitly {@link ProtobufBroker.BrokerSessionMessage.Session.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ProtobufBroker.BrokerSessionMessage.Session
             * @static
             * @param {ProtobufBroker.BrokerSessionMessage.ISession} message Session message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Session.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Session message from the specified reader or buffer.
             * @function decode
             * @memberof ProtobufBroker.BrokerSessionMessage.Session
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ProtobufBroker.BrokerSessionMessage.Session} Session
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Session.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.BrokerSessionMessage.Session();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.userId = reader.string();
                            break;
                        case 2:
                            message.expires = reader.int64();
                            break;
                        case 3:
                            message.token = reader.string();
                            break;
                        case 4:
                            message.mfaToken = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a Session message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ProtobufBroker.BrokerSessionMessage.Session
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ProtobufBroker.BrokerSessionMessage.Session} Session
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Session.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Session message.
             * @function verify
             * @memberof ProtobufBroker.BrokerSessionMessage.Session
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Session.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userId != null && message.hasOwnProperty("userId"))
                    if (!$util.isString(message.userId))
                        return "userId: string expected";
                if (message.expires != null && message.hasOwnProperty("expires"))
                    if (!$util.isInteger(message.expires) && !(message.expires && $util.isInteger(message.expires.low) && $util.isInteger(message.expires.high)))
                        return "expires: integer|Long expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                if (message.mfaToken != null && message.hasOwnProperty("mfaToken"))
                    if (!$util.isString(message.mfaToken))
                        return "mfaToken: string expected";
                return null;
            };
            /**
             * Creates a Session message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ProtobufBroker.BrokerSessionMessage.Session
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ProtobufBroker.BrokerSessionMessage.Session} Session
             */
            Session.fromObject = function fromObject(object) {
                if (object instanceof $root.ProtobufBroker.BrokerSessionMessage.Session)
                    return object;
                var message = new $root.ProtobufBroker.BrokerSessionMessage.Session();
                if (object.userId != null)
                    message.userId = String(object.userId);
                if (object.expires != null)
                    if ($util.Long)
                        (message.expires = $util.Long.fromValue(object.expires)).unsigned = false;
                    else if (typeof object.expires === "string")
                        message.expires = parseInt(object.expires, 10);
                    else if (typeof object.expires === "number")
                        message.expires = object.expires;
                    else if (typeof object.expires === "object")
                        message.expires = new $util.LongBits(object.expires.low >>> 0, object.expires.high >>> 0).toNumber();
                if (object.token != null)
                    message.token = String(object.token);
                if (object.mfaToken != null)
                    message.mfaToken = String(object.mfaToken);
                return message;
            };
            /**
             * Creates a plain object from a Session message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ProtobufBroker.BrokerSessionMessage.Session
             * @static
             * @param {ProtobufBroker.BrokerSessionMessage.Session} message Session
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Session.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.userId = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.expires = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.expires = options.longs === String ? "0" : 0;
                    object.token = "";
                    object.mfaToken = "";
                }
                if (message.userId != null && message.hasOwnProperty("userId"))
                    object.userId = message.userId;
                if (message.expires != null && message.hasOwnProperty("expires"))
                    if (typeof message.expires === "number")
                        object.expires = options.longs === String ? String(message.expires) : message.expires;
                    else
                        object.expires = options.longs === String ? $util.Long.prototype.toString.call(message.expires) : options.longs === Number ? new $util.LongBits(message.expires.low >>> 0, message.expires.high >>> 0).toNumber() : message.expires;
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = message.token;
                if (message.mfaToken != null && message.hasOwnProperty("mfaToken"))
                    object.mfaToken = message.mfaToken;
                return object;
            };
            /**
             * Converts this Session to JSON.
             * @function toJSON
             * @memberof ProtobufBroker.BrokerSessionMessage.Session
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Session.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Session;
        })();
        BrokerSessionMessage.AnonymousTradingSession = (function () {
            /**
             * Properties of an AnonymousTradingSession.
             * @memberof ProtobufBroker.BrokerSessionMessage
             * @interface IAnonymousTradingSession
             * @property {string|null} [exchange] AnonymousTradingSession exchange
             * @property {string|null} [token] AnonymousTradingSession token
             * @property {number|Long|null} [expiration] AnonymousTradingSession expiration
             */
            /**
             * Constructs a new AnonymousTradingSession.
             * @memberof ProtobufBroker.BrokerSessionMessage
             * @classdesc Represents an AnonymousTradingSession.
             * @implements IAnonymousTradingSession
             * @constructor
             * @param {ProtobufBroker.BrokerSessionMessage.IAnonymousTradingSession=} [properties] Properties to set
             */
            function AnonymousTradingSession(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * AnonymousTradingSession exchange.
             * @member {string} exchange
             * @memberof ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession
             * @instance
             */
            AnonymousTradingSession.prototype.exchange = "";
            /**
             * AnonymousTradingSession token.
             * @member {string} token
             * @memberof ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession
             * @instance
             */
            AnonymousTradingSession.prototype.token = "";
            /**
             * AnonymousTradingSession expiration.
             * @member {number|Long} expiration
             * @memberof ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession
             * @instance
             */
            AnonymousTradingSession.prototype.expiration = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Creates a new AnonymousTradingSession instance using the specified properties.
             * @function create
             * @memberof ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession
             * @static
             * @param {ProtobufBroker.BrokerSessionMessage.IAnonymousTradingSession=} [properties] Properties to set
             * @returns {ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession} AnonymousTradingSession instance
             */
            AnonymousTradingSession.create = function create(properties) {
                return new AnonymousTradingSession(properties);
            };
            /**
             * Encodes the specified AnonymousTradingSession message. Does not implicitly {@link ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession.verify|verify} messages.
             * @function encode
             * @memberof ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession
             * @static
             * @param {ProtobufBroker.BrokerSessionMessage.IAnonymousTradingSession} message AnonymousTradingSession message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnonymousTradingSession.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.exchange != null && Object.hasOwnProperty.call(message, "exchange"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.exchange);
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.token);
                if (message.expiration != null && Object.hasOwnProperty.call(message, "expiration"))
                    writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.expiration);
                return writer;
            };
            /**
             * Encodes the specified AnonymousTradingSession message, length delimited. Does not implicitly {@link ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession
             * @static
             * @param {ProtobufBroker.BrokerSessionMessage.IAnonymousTradingSession} message AnonymousTradingSession message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnonymousTradingSession.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an AnonymousTradingSession message from the specified reader or buffer.
             * @function decode
             * @memberof ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession} AnonymousTradingSession
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnonymousTradingSession.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.exchange = reader.string();
                            break;
                        case 2:
                            message.token = reader.string();
                            break;
                        case 3:
                            message.expiration = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes an AnonymousTradingSession message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession} AnonymousTradingSession
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnonymousTradingSession.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an AnonymousTradingSession message.
             * @function verify
             * @memberof ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AnonymousTradingSession.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.exchange != null && message.hasOwnProperty("exchange"))
                    if (!$util.isString(message.exchange))
                        return "exchange: string expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                if (message.expiration != null && message.hasOwnProperty("expiration"))
                    if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                        return "expiration: integer|Long expected";
                return null;
            };
            /**
             * Creates an AnonymousTradingSession message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession} AnonymousTradingSession
             */
            AnonymousTradingSession.fromObject = function fromObject(object) {
                if (object instanceof $root.ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession)
                    return object;
                var message = new $root.ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession();
                if (object.exchange != null)
                    message.exchange = String(object.exchange);
                if (object.token != null)
                    message.token = String(object.token);
                if (object.expiration != null)
                    if ($util.Long)
                        (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                    else if (typeof object.expiration === "string")
                        message.expiration = parseInt(object.expiration, 10);
                    else if (typeof object.expiration === "number")
                        message.expiration = object.expiration;
                    else if (typeof object.expiration === "object")
                        message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
                return message;
            };
            /**
             * Creates a plain object from an AnonymousTradingSession message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession
             * @static
             * @param {ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession} message AnonymousTradingSession
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AnonymousTradingSession.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.exchange = "";
                    object.token = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.expiration = options.longs === String ? "0" : 0;
                }
                if (message.exchange != null && message.hasOwnProperty("exchange"))
                    object.exchange = message.exchange;
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = message.token;
                if (message.expiration != null && message.hasOwnProperty("expiration"))
                    if (typeof message.expiration === "number")
                        object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                    else
                        object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
                return object;
            };
            /**
             * Converts this AnonymousTradingSession to JSON.
             * @function toJSON
             * @memberof ProtobufBroker.BrokerSessionMessage.AnonymousTradingSession
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AnonymousTradingSession.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return AnonymousTradingSession;
        })();
        return BrokerSessionMessage;
    })();
    ProtobufBroker.PlaceOrderRequest = (function () {
        /**
         * Properties of a PlaceOrderRequest.
         * @memberof ProtobufBroker
         * @interface IPlaceOrderRequest
         * @property {ProtobufBroker.IPrivateOrder|null} [order] PlaceOrderRequest order
         * @property {ProtobufBroker.IPrivateOrder|null} [closingOrder] PlaceOrderRequest closingOrder
         */
        /**
         * Constructs a new PlaceOrderRequest.
         * @memberof ProtobufBroker
         * @classdesc Represents a PlaceOrderRequest.
         * @implements IPlaceOrderRequest
         * @constructor
         * @param {ProtobufBroker.IPlaceOrderRequest=} [properties] Properties to set
         */
        function PlaceOrderRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PlaceOrderRequest order.
         * @member {ProtobufBroker.IPrivateOrder|null|undefined} order
         * @memberof ProtobufBroker.PlaceOrderRequest
         * @instance
         */
        PlaceOrderRequest.prototype.order = null;
        /**
         * PlaceOrderRequest closingOrder.
         * @member {ProtobufBroker.IPrivateOrder|null|undefined} closingOrder
         * @memberof ProtobufBroker.PlaceOrderRequest
         * @instance
         */
        PlaceOrderRequest.prototype.closingOrder = null;
        /**
         * Creates a new PlaceOrderRequest instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.PlaceOrderRequest
         * @static
         * @param {ProtobufBroker.IPlaceOrderRequest=} [properties] Properties to set
         * @returns {ProtobufBroker.PlaceOrderRequest} PlaceOrderRequest instance
         */
        PlaceOrderRequest.create = function create(properties) {
            return new PlaceOrderRequest(properties);
        };
        /**
         * Encodes the specified PlaceOrderRequest message. Does not implicitly {@link ProtobufBroker.PlaceOrderRequest.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.PlaceOrderRequest
         * @static
         * @param {ProtobufBroker.IPlaceOrderRequest} message PlaceOrderRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlaceOrderRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.order != null && Object.hasOwnProperty.call(message, "order"))
                $root.ProtobufBroker.PrivateOrder.encode(message.order, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.closingOrder != null && Object.hasOwnProperty.call(message, "closingOrder"))
                $root.ProtobufBroker.PrivateOrder.encode(message.closingOrder, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified PlaceOrderRequest message, length delimited. Does not implicitly {@link ProtobufBroker.PlaceOrderRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.PlaceOrderRequest
         * @static
         * @param {ProtobufBroker.IPlaceOrderRequest} message PlaceOrderRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlaceOrderRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PlaceOrderRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.PlaceOrderRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.PlaceOrderRequest} PlaceOrderRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlaceOrderRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.PlaceOrderRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 2:
                        message.order = $root.ProtobufBroker.PrivateOrder.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.closingOrder = $root.ProtobufBroker.PrivateOrder.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PlaceOrderRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.PlaceOrderRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.PlaceOrderRequest} PlaceOrderRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlaceOrderRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PlaceOrderRequest message.
         * @function verify
         * @memberof ProtobufBroker.PlaceOrderRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlaceOrderRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.order != null && message.hasOwnProperty("order")) {
                var error = $root.ProtobufBroker.PrivateOrder.verify(message.order);
                if (error)
                    return "order." + error;
            }
            if (message.closingOrder != null && message.hasOwnProperty("closingOrder")) {
                var error = $root.ProtobufBroker.PrivateOrder.verify(message.closingOrder);
                if (error)
                    return "closingOrder." + error;
            }
            return null;
        };
        /**
         * Creates a PlaceOrderRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.PlaceOrderRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.PlaceOrderRequest} PlaceOrderRequest
         */
        PlaceOrderRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.PlaceOrderRequest)
                return object;
            var message = new $root.ProtobufBroker.PlaceOrderRequest();
            if (object.order != null) {
                if (typeof object.order !== "object")
                    throw TypeError(".ProtobufBroker.PlaceOrderRequest.order: object expected");
                message.order = $root.ProtobufBroker.PrivateOrder.fromObject(object.order);
            }
            if (object.closingOrder != null) {
                if (typeof object.closingOrder !== "object")
                    throw TypeError(".ProtobufBroker.PlaceOrderRequest.closingOrder: object expected");
                message.closingOrder = $root.ProtobufBroker.PrivateOrder.fromObject(object.closingOrder);
            }
            return message;
        };
        /**
         * Creates a plain object from a PlaceOrderRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.PlaceOrderRequest
         * @static
         * @param {ProtobufBroker.PlaceOrderRequest} message PlaceOrderRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlaceOrderRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.order = null;
                object.closingOrder = null;
            }
            if (message.order != null && message.hasOwnProperty("order"))
                object.order = $root.ProtobufBroker.PrivateOrder.toObject(message.order, options);
            if (message.closingOrder != null && message.hasOwnProperty("closingOrder"))
                object.closingOrder = $root.ProtobufBroker.PrivateOrder.toObject(message.closingOrder, options);
            return object;
        };
        /**
         * Converts this PlaceOrderRequest to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.PlaceOrderRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlaceOrderRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PlaceOrderRequest;
    })();
    ProtobufBroker.PlaceOrderResult = (function () {
        /**
         * Properties of a PlaceOrderResult.
         * @memberof ProtobufBroker
         * @interface IPlaceOrderResult
         * @property {ProtobufBroker.IPrivateOrder|null} [order] PlaceOrderResult order
         * @property {string|null} [orderId] PlaceOrderResult orderId
         */
        /**
         * Constructs a new PlaceOrderResult.
         * @memberof ProtobufBroker
         * @classdesc Represents a PlaceOrderResult.
         * @implements IPlaceOrderResult
         * @constructor
         * @param {ProtobufBroker.IPlaceOrderResult=} [properties] Properties to set
         */
        function PlaceOrderResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PlaceOrderResult order.
         * @member {ProtobufBroker.IPrivateOrder|null|undefined} order
         * @memberof ProtobufBroker.PlaceOrderResult
         * @instance
         */
        PlaceOrderResult.prototype.order = null;
        /**
         * PlaceOrderResult orderId.
         * @member {string} orderId
         * @memberof ProtobufBroker.PlaceOrderResult
         * @instance
         */
        PlaceOrderResult.prototype.orderId = "";
        /**
         * Creates a new PlaceOrderResult instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.PlaceOrderResult
         * @static
         * @param {ProtobufBroker.IPlaceOrderResult=} [properties] Properties to set
         * @returns {ProtobufBroker.PlaceOrderResult} PlaceOrderResult instance
         */
        PlaceOrderResult.create = function create(properties) {
            return new PlaceOrderResult(properties);
        };
        /**
         * Encodes the specified PlaceOrderResult message. Does not implicitly {@link ProtobufBroker.PlaceOrderResult.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.PlaceOrderResult
         * @static
         * @param {ProtobufBroker.IPlaceOrderResult} message PlaceOrderResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlaceOrderResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.orderId != null && Object.hasOwnProperty.call(message, "orderId"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.orderId);
            if (message.order != null && Object.hasOwnProperty.call(message, "order"))
                $root.ProtobufBroker.PrivateOrder.encode(message.order, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified PlaceOrderResult message, length delimited. Does not implicitly {@link ProtobufBroker.PlaceOrderResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.PlaceOrderResult
         * @static
         * @param {ProtobufBroker.IPlaceOrderResult} message PlaceOrderResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlaceOrderResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PlaceOrderResult message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.PlaceOrderResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.PlaceOrderResult} PlaceOrderResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlaceOrderResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.PlaceOrderResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 2:
                        message.order = $root.ProtobufBroker.PrivateOrder.decode(reader, reader.uint32());
                        break;
                    case 1:
                        message.orderId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PlaceOrderResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.PlaceOrderResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.PlaceOrderResult} PlaceOrderResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlaceOrderResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PlaceOrderResult message.
         * @function verify
         * @memberof ProtobufBroker.PlaceOrderResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlaceOrderResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.order != null && message.hasOwnProperty("order")) {
                var error = $root.ProtobufBroker.PrivateOrder.verify(message.order);
                if (error)
                    return "order." + error;
            }
            if (message.orderId != null && message.hasOwnProperty("orderId"))
                if (!$util.isString(message.orderId))
                    return "orderId: string expected";
            return null;
        };
        /**
         * Creates a PlaceOrderResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.PlaceOrderResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.PlaceOrderResult} PlaceOrderResult
         */
        PlaceOrderResult.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.PlaceOrderResult)
                return object;
            var message = new $root.ProtobufBroker.PlaceOrderResult();
            if (object.order != null) {
                if (typeof object.order !== "object")
                    throw TypeError(".ProtobufBroker.PlaceOrderResult.order: object expected");
                message.order = $root.ProtobufBroker.PrivateOrder.fromObject(object.order);
            }
            if (object.orderId != null)
                message.orderId = String(object.orderId);
            return message;
        };
        /**
         * Creates a plain object from a PlaceOrderResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.PlaceOrderResult
         * @static
         * @param {ProtobufBroker.PlaceOrderResult} message PlaceOrderResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlaceOrderResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.orderId = "";
                object.order = null;
            }
            if (message.orderId != null && message.hasOwnProperty("orderId"))
                object.orderId = message.orderId;
            if (message.order != null && message.hasOwnProperty("order"))
                object.order = $root.ProtobufBroker.PrivateOrder.toObject(message.order, options);
            return object;
        };
        /**
         * Converts this PlaceOrderResult to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.PlaceOrderResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlaceOrderResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PlaceOrderResult;
    })();
    ProtobufBroker.CancelOrderRequest = (function () {
        /**
         * Properties of a CancelOrderRequest.
         * @memberof ProtobufBroker
         * @interface ICancelOrderRequest
         * @property {string|null} [orderId] CancelOrderRequest orderId
         */
        /**
         * Constructs a new CancelOrderRequest.
         * @memberof ProtobufBroker
         * @classdesc Represents a CancelOrderRequest.
         * @implements ICancelOrderRequest
         * @constructor
         * @param {ProtobufBroker.ICancelOrderRequest=} [properties] Properties to set
         */
        function CancelOrderRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * CancelOrderRequest orderId.
         * @member {string} orderId
         * @memberof ProtobufBroker.CancelOrderRequest
         * @instance
         */
        CancelOrderRequest.prototype.orderId = "";
        /**
         * Creates a new CancelOrderRequest instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.CancelOrderRequest
         * @static
         * @param {ProtobufBroker.ICancelOrderRequest=} [properties] Properties to set
         * @returns {ProtobufBroker.CancelOrderRequest} CancelOrderRequest instance
         */
        CancelOrderRequest.create = function create(properties) {
            return new CancelOrderRequest(properties);
        };
        /**
         * Encodes the specified CancelOrderRequest message. Does not implicitly {@link ProtobufBroker.CancelOrderRequest.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.CancelOrderRequest
         * @static
         * @param {ProtobufBroker.ICancelOrderRequest} message CancelOrderRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelOrderRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.orderId != null && Object.hasOwnProperty.call(message, "orderId"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.orderId);
            return writer;
        };
        /**
         * Encodes the specified CancelOrderRequest message, length delimited. Does not implicitly {@link ProtobufBroker.CancelOrderRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.CancelOrderRequest
         * @static
         * @param {ProtobufBroker.ICancelOrderRequest} message CancelOrderRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelOrderRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a CancelOrderRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.CancelOrderRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.CancelOrderRequest} CancelOrderRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelOrderRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.CancelOrderRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 2:
                        message.orderId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a CancelOrderRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.CancelOrderRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.CancelOrderRequest} CancelOrderRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelOrderRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a CancelOrderRequest message.
         * @function verify
         * @memberof ProtobufBroker.CancelOrderRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CancelOrderRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.orderId != null && message.hasOwnProperty("orderId"))
                if (!$util.isString(message.orderId))
                    return "orderId: string expected";
            return null;
        };
        /**
         * Creates a CancelOrderRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.CancelOrderRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.CancelOrderRequest} CancelOrderRequest
         */
        CancelOrderRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.CancelOrderRequest)
                return object;
            var message = new $root.ProtobufBroker.CancelOrderRequest();
            if (object.orderId != null)
                message.orderId = String(object.orderId);
            return message;
        };
        /**
         * Creates a plain object from a CancelOrderRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.CancelOrderRequest
         * @static
         * @param {ProtobufBroker.CancelOrderRequest} message CancelOrderRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CancelOrderRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.orderId = "";
            if (message.orderId != null && message.hasOwnProperty("orderId"))
                object.orderId = message.orderId;
            return object;
        };
        /**
         * Converts this CancelOrderRequest to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.CancelOrderRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CancelOrderRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CancelOrderRequest;
    })();
    ProtobufBroker.CancelOrderResult = (function () {
        /**
         * Properties of a CancelOrderResult.
         * @memberof ProtobufBroker
         * @interface ICancelOrderResult
         * @property {string|null} [orderId] CancelOrderResult orderId
         */
        /**
         * Constructs a new CancelOrderResult.
         * @memberof ProtobufBroker
         * @classdesc Represents a CancelOrderResult.
         * @implements ICancelOrderResult
         * @constructor
         * @param {ProtobufBroker.ICancelOrderResult=} [properties] Properties to set
         */
        function CancelOrderResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * CancelOrderResult orderId.
         * @member {string} orderId
         * @memberof ProtobufBroker.CancelOrderResult
         * @instance
         */
        CancelOrderResult.prototype.orderId = "";
        /**
         * Creates a new CancelOrderResult instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.CancelOrderResult
         * @static
         * @param {ProtobufBroker.ICancelOrderResult=} [properties] Properties to set
         * @returns {ProtobufBroker.CancelOrderResult} CancelOrderResult instance
         */
        CancelOrderResult.create = function create(properties) {
            return new CancelOrderResult(properties);
        };
        /**
         * Encodes the specified CancelOrderResult message. Does not implicitly {@link ProtobufBroker.CancelOrderResult.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.CancelOrderResult
         * @static
         * @param {ProtobufBroker.ICancelOrderResult} message CancelOrderResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelOrderResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.orderId != null && Object.hasOwnProperty.call(message, "orderId"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.orderId);
            return writer;
        };
        /**
         * Encodes the specified CancelOrderResult message, length delimited. Does not implicitly {@link ProtobufBroker.CancelOrderResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.CancelOrderResult
         * @static
         * @param {ProtobufBroker.ICancelOrderResult} message CancelOrderResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelOrderResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a CancelOrderResult message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.CancelOrderResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.CancelOrderResult} CancelOrderResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelOrderResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.CancelOrderResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.orderId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a CancelOrderResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.CancelOrderResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.CancelOrderResult} CancelOrderResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelOrderResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a CancelOrderResult message.
         * @function verify
         * @memberof ProtobufBroker.CancelOrderResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CancelOrderResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.orderId != null && message.hasOwnProperty("orderId"))
                if (!$util.isString(message.orderId))
                    return "orderId: string expected";
            return null;
        };
        /**
         * Creates a CancelOrderResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.CancelOrderResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.CancelOrderResult} CancelOrderResult
         */
        CancelOrderResult.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.CancelOrderResult)
                return object;
            var message = new $root.ProtobufBroker.CancelOrderResult();
            if (object.orderId != null)
                message.orderId = String(object.orderId);
            return message;
        };
        /**
         * Creates a plain object from a CancelOrderResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.CancelOrderResult
         * @static
         * @param {ProtobufBroker.CancelOrderResult} message CancelOrderResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CancelOrderResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.orderId = "";
            if (message.orderId != null && message.hasOwnProperty("orderId"))
                object.orderId = message.orderId;
            return object;
        };
        /**
         * Converts this CancelOrderResult to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.CancelOrderResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CancelOrderResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CancelOrderResult;
    })();
    ProtobufBroker.ReplaceOrderRequest = (function () {
        /**
         * Properties of a ReplaceOrderRequest.
         * @memberof ProtobufBroker
         * @interface IReplaceOrderRequest
         * @property {string|null} [orderId] ReplaceOrderRequest orderId
         * @property {ProtobufBroker.IPrivateOrder|null} [replacement] ReplaceOrderRequest replacement
         * @property {ProtobufBroker.IPrivateOrder|null} [replacementClosingOrder] ReplaceOrderRequest replacementClosingOrder
         */
        /**
         * Constructs a new ReplaceOrderRequest.
         * @memberof ProtobufBroker
         * @classdesc Represents a ReplaceOrderRequest.
         * @implements IReplaceOrderRequest
         * @constructor
         * @param {ProtobufBroker.IReplaceOrderRequest=} [properties] Properties to set
         */
        function ReplaceOrderRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ReplaceOrderRequest orderId.
         * @member {string} orderId
         * @memberof ProtobufBroker.ReplaceOrderRequest
         * @instance
         */
        ReplaceOrderRequest.prototype.orderId = "";
        /**
         * ReplaceOrderRequest replacement.
         * @member {ProtobufBroker.IPrivateOrder|null|undefined} replacement
         * @memberof ProtobufBroker.ReplaceOrderRequest
         * @instance
         */
        ReplaceOrderRequest.prototype.replacement = null;
        /**
         * ReplaceOrderRequest replacementClosingOrder.
         * @member {ProtobufBroker.IPrivateOrder|null|undefined} replacementClosingOrder
         * @memberof ProtobufBroker.ReplaceOrderRequest
         * @instance
         */
        ReplaceOrderRequest.prototype.replacementClosingOrder = null;
        /**
         * Creates a new ReplaceOrderRequest instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.ReplaceOrderRequest
         * @static
         * @param {ProtobufBroker.IReplaceOrderRequest=} [properties] Properties to set
         * @returns {ProtobufBroker.ReplaceOrderRequest} ReplaceOrderRequest instance
         */
        ReplaceOrderRequest.create = function create(properties) {
            return new ReplaceOrderRequest(properties);
        };
        /**
         * Encodes the specified ReplaceOrderRequest message. Does not implicitly {@link ProtobufBroker.ReplaceOrderRequest.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.ReplaceOrderRequest
         * @static
         * @param {ProtobufBroker.IReplaceOrderRequest} message ReplaceOrderRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReplaceOrderRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.orderId != null && Object.hasOwnProperty.call(message, "orderId"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.orderId);
            if (message.replacement != null && Object.hasOwnProperty.call(message, "replacement"))
                $root.ProtobufBroker.PrivateOrder.encode(message.replacement, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.replacementClosingOrder != null && Object.hasOwnProperty.call(message, "replacementClosingOrder"))
                $root.ProtobufBroker.PrivateOrder.encode(message.replacementClosingOrder, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified ReplaceOrderRequest message, length delimited. Does not implicitly {@link ProtobufBroker.ReplaceOrderRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.ReplaceOrderRequest
         * @static
         * @param {ProtobufBroker.IReplaceOrderRequest} message ReplaceOrderRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReplaceOrderRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ReplaceOrderRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.ReplaceOrderRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.ReplaceOrderRequest} ReplaceOrderRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReplaceOrderRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.ReplaceOrderRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.orderId = reader.string();
                        break;
                    case 2:
                        message.replacement = $root.ProtobufBroker.PrivateOrder.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.replacementClosingOrder = $root.ProtobufBroker.PrivateOrder.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ReplaceOrderRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.ReplaceOrderRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.ReplaceOrderRequest} ReplaceOrderRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReplaceOrderRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ReplaceOrderRequest message.
         * @function verify
         * @memberof ProtobufBroker.ReplaceOrderRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReplaceOrderRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.orderId != null && message.hasOwnProperty("orderId"))
                if (!$util.isString(message.orderId))
                    return "orderId: string expected";
            if (message.replacement != null && message.hasOwnProperty("replacement")) {
                var error = $root.ProtobufBroker.PrivateOrder.verify(message.replacement);
                if (error)
                    return "replacement." + error;
            }
            if (message.replacementClosingOrder != null && message.hasOwnProperty("replacementClosingOrder")) {
                var error = $root.ProtobufBroker.PrivateOrder.verify(message.replacementClosingOrder);
                if (error)
                    return "replacementClosingOrder." + error;
            }
            return null;
        };
        /**
         * Creates a ReplaceOrderRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.ReplaceOrderRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.ReplaceOrderRequest} ReplaceOrderRequest
         */
        ReplaceOrderRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.ReplaceOrderRequest)
                return object;
            var message = new $root.ProtobufBroker.ReplaceOrderRequest();
            if (object.orderId != null)
                message.orderId = String(object.orderId);
            if (object.replacement != null) {
                if (typeof object.replacement !== "object")
                    throw TypeError(".ProtobufBroker.ReplaceOrderRequest.replacement: object expected");
                message.replacement = $root.ProtobufBroker.PrivateOrder.fromObject(object.replacement);
            }
            if (object.replacementClosingOrder != null) {
                if (typeof object.replacementClosingOrder !== "object")
                    throw TypeError(".ProtobufBroker.ReplaceOrderRequest.replacementClosingOrder: object expected");
                message.replacementClosingOrder = $root.ProtobufBroker.PrivateOrder.fromObject(object.replacementClosingOrder);
            }
            return message;
        };
        /**
         * Creates a plain object from a ReplaceOrderRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.ReplaceOrderRequest
         * @static
         * @param {ProtobufBroker.ReplaceOrderRequest} message ReplaceOrderRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReplaceOrderRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.orderId = "";
                object.replacement = null;
                object.replacementClosingOrder = null;
            }
            if (message.orderId != null && message.hasOwnProperty("orderId"))
                object.orderId = message.orderId;
            if (message.replacement != null && message.hasOwnProperty("replacement"))
                object.replacement = $root.ProtobufBroker.PrivateOrder.toObject(message.replacement, options);
            if (message.replacementClosingOrder != null && message.hasOwnProperty("replacementClosingOrder"))
                object.replacementClosingOrder = $root.ProtobufBroker.PrivateOrder.toObject(message.replacementClosingOrder, options);
            return object;
        };
        /**
         * Converts this ReplaceOrderRequest to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.ReplaceOrderRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReplaceOrderRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ReplaceOrderRequest;
    })();
    ProtobufBroker.ClosePositionRequest = (function () {
        /**
         * Properties of a ClosePositionRequest.
         * @memberof ProtobufBroker
         * @interface IClosePositionRequest
         * @property {string|null} [positionId] ClosePositionRequest positionId
         */
        /**
         * Constructs a new ClosePositionRequest.
         * @memberof ProtobufBroker
         * @classdesc Represents a ClosePositionRequest.
         * @implements IClosePositionRequest
         * @constructor
         * @param {ProtobufBroker.IClosePositionRequest=} [properties] Properties to set
         */
        function ClosePositionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ClosePositionRequest positionId.
         * @member {string} positionId
         * @memberof ProtobufBroker.ClosePositionRequest
         * @instance
         */
        ClosePositionRequest.prototype.positionId = "";
        /**
         * Creates a new ClosePositionRequest instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.ClosePositionRequest
         * @static
         * @param {ProtobufBroker.IClosePositionRequest=} [properties] Properties to set
         * @returns {ProtobufBroker.ClosePositionRequest} ClosePositionRequest instance
         */
        ClosePositionRequest.create = function create(properties) {
            return new ClosePositionRequest(properties);
        };
        /**
         * Encodes the specified ClosePositionRequest message. Does not implicitly {@link ProtobufBroker.ClosePositionRequest.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.ClosePositionRequest
         * @static
         * @param {ProtobufBroker.IClosePositionRequest} message ClosePositionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClosePositionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.positionId != null && Object.hasOwnProperty.call(message, "positionId"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.positionId);
            return writer;
        };
        /**
         * Encodes the specified ClosePositionRequest message, length delimited. Does not implicitly {@link ProtobufBroker.ClosePositionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.ClosePositionRequest
         * @static
         * @param {ProtobufBroker.IClosePositionRequest} message ClosePositionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClosePositionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ClosePositionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.ClosePositionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.ClosePositionRequest} ClosePositionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClosePositionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.ClosePositionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 2:
                        message.positionId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ClosePositionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.ClosePositionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.ClosePositionRequest} ClosePositionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClosePositionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ClosePositionRequest message.
         * @function verify
         * @memberof ProtobufBroker.ClosePositionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClosePositionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.positionId != null && message.hasOwnProperty("positionId"))
                if (!$util.isString(message.positionId))
                    return "positionId: string expected";
            return null;
        };
        /**
         * Creates a ClosePositionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.ClosePositionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.ClosePositionRequest} ClosePositionRequest
         */
        ClosePositionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.ClosePositionRequest)
                return object;
            var message = new $root.ProtobufBroker.ClosePositionRequest();
            if (object.positionId != null)
                message.positionId = String(object.positionId);
            return message;
        };
        /**
         * Creates a plain object from a ClosePositionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.ClosePositionRequest
         * @static
         * @param {ProtobufBroker.ClosePositionRequest} message ClosePositionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClosePositionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.positionId = "";
            if (message.positionId != null && message.hasOwnProperty("positionId"))
                object.positionId = message.positionId;
            return object;
        };
        /**
         * Converts this ClosePositionRequest to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.ClosePositionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClosePositionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ClosePositionRequest;
    })();
    ProtobufBroker.SettlePositionRequest = (function () {
        /**
         * Properties of a SettlePositionRequest.
         * @memberof ProtobufBroker
         * @interface ISettlePositionRequest
         * @property {string|null} [positionId] SettlePositionRequest positionId
         */
        /**
         * Constructs a new SettlePositionRequest.
         * @memberof ProtobufBroker
         * @classdesc Represents a SettlePositionRequest.
         * @implements ISettlePositionRequest
         * @constructor
         * @param {ProtobufBroker.ISettlePositionRequest=} [properties] Properties to set
         */
        function SettlePositionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * SettlePositionRequest positionId.
         * @member {string} positionId
         * @memberof ProtobufBroker.SettlePositionRequest
         * @instance
         */
        SettlePositionRequest.prototype.positionId = "";
        /**
         * Creates a new SettlePositionRequest instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.SettlePositionRequest
         * @static
         * @param {ProtobufBroker.ISettlePositionRequest=} [properties] Properties to set
         * @returns {ProtobufBroker.SettlePositionRequest} SettlePositionRequest instance
         */
        SettlePositionRequest.create = function create(properties) {
            return new SettlePositionRequest(properties);
        };
        /**
         * Encodes the specified SettlePositionRequest message. Does not implicitly {@link ProtobufBroker.SettlePositionRequest.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.SettlePositionRequest
         * @static
         * @param {ProtobufBroker.ISettlePositionRequest} message SettlePositionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SettlePositionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.positionId != null && Object.hasOwnProperty.call(message, "positionId"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.positionId);
            return writer;
        };
        /**
         * Encodes the specified SettlePositionRequest message, length delimited. Does not implicitly {@link ProtobufBroker.SettlePositionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.SettlePositionRequest
         * @static
         * @param {ProtobufBroker.ISettlePositionRequest} message SettlePositionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SettlePositionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a SettlePositionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.SettlePositionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.SettlePositionRequest} SettlePositionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SettlePositionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.SettlePositionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.positionId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a SettlePositionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.SettlePositionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.SettlePositionRequest} SettlePositionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SettlePositionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a SettlePositionRequest message.
         * @function verify
         * @memberof ProtobufBroker.SettlePositionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SettlePositionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.positionId != null && message.hasOwnProperty("positionId"))
                if (!$util.isString(message.positionId))
                    return "positionId: string expected";
            return null;
        };
        /**
         * Creates a SettlePositionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.SettlePositionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.SettlePositionRequest} SettlePositionRequest
         */
        SettlePositionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.SettlePositionRequest)
                return object;
            var message = new $root.ProtobufBroker.SettlePositionRequest();
            if (object.positionId != null)
                message.positionId = String(object.positionId);
            return message;
        };
        /**
         * Creates a plain object from a SettlePositionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.SettlePositionRequest
         * @static
         * @param {ProtobufBroker.SettlePositionRequest} message SettlePositionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SettlePositionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.positionId = "";
            if (message.positionId != null && message.hasOwnProperty("positionId"))
                object.positionId = message.positionId;
            return object;
        };
        /**
         * Converts this SettlePositionRequest to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.SettlePositionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SettlePositionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return SettlePositionRequest;
    })();
    ProtobufBroker.SyncRequest = (function () {
        /**
         * Properties of a SyncRequest.
         * @memberof ProtobufBroker
         * @interface ISyncRequest
         */
        /**
         * Constructs a new SyncRequest.
         * @memberof ProtobufBroker
         * @classdesc Represents a SyncRequest.
         * @implements ISyncRequest
         * @constructor
         * @param {ProtobufBroker.ISyncRequest=} [properties] Properties to set
         */
        function SyncRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Creates a new SyncRequest instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.SyncRequest
         * @static
         * @param {ProtobufBroker.ISyncRequest=} [properties] Properties to set
         * @returns {ProtobufBroker.SyncRequest} SyncRequest instance
         */
        SyncRequest.create = function create(properties) {
            return new SyncRequest(properties);
        };
        /**
         * Encodes the specified SyncRequest message. Does not implicitly {@link ProtobufBroker.SyncRequest.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.SyncRequest
         * @static
         * @param {ProtobufBroker.ISyncRequest} message SyncRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
        /**
         * Encodes the specified SyncRequest message, length delimited. Does not implicitly {@link ProtobufBroker.SyncRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.SyncRequest
         * @static
         * @param {ProtobufBroker.ISyncRequest} message SyncRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a SyncRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.SyncRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.SyncRequest} SyncRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.SyncRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a SyncRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.SyncRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.SyncRequest} SyncRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a SyncRequest message.
         * @function verify
         * @memberof ProtobufBroker.SyncRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
        /**
         * Creates a SyncRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.SyncRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.SyncRequest} SyncRequest
         */
        SyncRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.SyncRequest)
                return object;
            return new $root.ProtobufBroker.SyncRequest();
        };
        /**
         * Creates a plain object from a SyncRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.SyncRequest
         * @static
         * @param {ProtobufBroker.SyncRequest} message SyncRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncRequest.toObject = function toObject() {
            return {};
        };
        /**
         * Converts this SyncRequest to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.SyncRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return SyncRequest;
    })();
    ProtobufBroker.BrokerRequest = (function () {
        /**
         * Properties of a BrokerRequest.
         * @memberof ProtobufBroker
         * @interface IBrokerRequest
         * @property {string|null} [id] BrokerRequest id
         * @property {number|Long|null} [marketId] BrokerRequest marketId
         * @property {ProtobufBroker.IPlaceOrderRequest|null} [placeOrderRequest] BrokerRequest placeOrderRequest
         * @property {ProtobufBroker.ICancelOrderRequest|null} [cancelOrderRequest] BrokerRequest cancelOrderRequest
         * @property {ProtobufBroker.IReplaceOrderRequest|null} [replaceOrderRequest] BrokerRequest replaceOrderRequest
         * @property {ProtobufBroker.ISyncRequest|null} [syncRequest] BrokerRequest syncRequest
         * @property {ProtobufBroker.IClosePositionRequest|null} [closePositionRequest] BrokerRequest closePositionRequest
         * @property {ProtobufBroker.ISettlePositionRequest|null} [settlePositionRequest] BrokerRequest settlePositionRequest
         */
        /**
         * Constructs a new BrokerRequest.
         * @memberof ProtobufBroker
         * @classdesc Represents a BrokerRequest.
         * @implements IBrokerRequest
         * @constructor
         * @param {ProtobufBroker.IBrokerRequest=} [properties] Properties to set
         */
        function BrokerRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * BrokerRequest id.
         * @member {string} id
         * @memberof ProtobufBroker.BrokerRequest
         * @instance
         */
        BrokerRequest.prototype.id = "";
        /**
         * BrokerRequest marketId.
         * @member {number|Long} marketId
         * @memberof ProtobufBroker.BrokerRequest
         * @instance
         */
        BrokerRequest.prototype.marketId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * BrokerRequest placeOrderRequest.
         * @member {ProtobufBroker.IPlaceOrderRequest|null|undefined} placeOrderRequest
         * @memberof ProtobufBroker.BrokerRequest
         * @instance
         */
        BrokerRequest.prototype.placeOrderRequest = null;
        /**
         * BrokerRequest cancelOrderRequest.
         * @member {ProtobufBroker.ICancelOrderRequest|null|undefined} cancelOrderRequest
         * @memberof ProtobufBroker.BrokerRequest
         * @instance
         */
        BrokerRequest.prototype.cancelOrderRequest = null;
        /**
         * BrokerRequest replaceOrderRequest.
         * @member {ProtobufBroker.IReplaceOrderRequest|null|undefined} replaceOrderRequest
         * @memberof ProtobufBroker.BrokerRequest
         * @instance
         */
        BrokerRequest.prototype.replaceOrderRequest = null;
        /**
         * BrokerRequest syncRequest.
         * @member {ProtobufBroker.ISyncRequest|null|undefined} syncRequest
         * @memberof ProtobufBroker.BrokerRequest
         * @instance
         */
        BrokerRequest.prototype.syncRequest = null;
        /**
         * BrokerRequest closePositionRequest.
         * @member {ProtobufBroker.IClosePositionRequest|null|undefined} closePositionRequest
         * @memberof ProtobufBroker.BrokerRequest
         * @instance
         */
        BrokerRequest.prototype.closePositionRequest = null;
        /**
         * BrokerRequest settlePositionRequest.
         * @member {ProtobufBroker.ISettlePositionRequest|null|undefined} settlePositionRequest
         * @memberof ProtobufBroker.BrokerRequest
         * @instance
         */
        BrokerRequest.prototype.settlePositionRequest = null;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * BrokerRequest Request.
         * @member {"placeOrderRequest"|"cancelOrderRequest"|"replaceOrderRequest"|"syncRequest"|"closePositionRequest"|"settlePositionRequest"|undefined} Request
         * @memberof ProtobufBroker.BrokerRequest
         * @instance
         */
        Object.defineProperty(BrokerRequest.prototype, "Request", {
            get: $util.oneOfGetter($oneOfFields = ["placeOrderRequest", "cancelOrderRequest", "replaceOrderRequest", "syncRequest", "closePositionRequest", "settlePositionRequest"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new BrokerRequest instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.BrokerRequest
         * @static
         * @param {ProtobufBroker.IBrokerRequest=} [properties] Properties to set
         * @returns {ProtobufBroker.BrokerRequest} BrokerRequest instance
         */
        BrokerRequest.create = function create(properties) {
            return new BrokerRequest(properties);
        };
        /**
         * Encodes the specified BrokerRequest message. Does not implicitly {@link ProtobufBroker.BrokerRequest.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.BrokerRequest
         * @static
         * @param {ProtobufBroker.IBrokerRequest} message BrokerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BrokerRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
            if (message.placeOrderRequest != null && Object.hasOwnProperty.call(message, "placeOrderRequest"))
                $root.ProtobufBroker.PlaceOrderRequest.encode(message.placeOrderRequest, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.cancelOrderRequest != null && Object.hasOwnProperty.call(message, "cancelOrderRequest"))
                $root.ProtobufBroker.CancelOrderRequest.encode(message.cancelOrderRequest, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.syncRequest != null && Object.hasOwnProperty.call(message, "syncRequest"))
                $root.ProtobufBroker.SyncRequest.encode(message.syncRequest, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            if (message.closePositionRequest != null && Object.hasOwnProperty.call(message, "closePositionRequest"))
                $root.ProtobufBroker.ClosePositionRequest.encode(message.closePositionRequest, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
            if (message.replaceOrderRequest != null && Object.hasOwnProperty.call(message, "replaceOrderRequest"))
                $root.ProtobufBroker.ReplaceOrderRequest.encode(message.replaceOrderRequest, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
            if (message.marketId != null && Object.hasOwnProperty.call(message, "marketId"))
                writer.uint32(/* id 7, wireType 0 =*/ 56).int64(message.marketId);
            if (message.settlePositionRequest != null && Object.hasOwnProperty.call(message, "settlePositionRequest"))
                $root.ProtobufBroker.SettlePositionRequest.encode(message.settlePositionRequest, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified BrokerRequest message, length delimited. Does not implicitly {@link ProtobufBroker.BrokerRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.BrokerRequest
         * @static
         * @param {ProtobufBroker.IBrokerRequest} message BrokerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BrokerRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a BrokerRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.BrokerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.BrokerRequest} BrokerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BrokerRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.BrokerRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 7:
                        message.marketId = reader.int64();
                        break;
                    case 2:
                        message.placeOrderRequest = $root.ProtobufBroker.PlaceOrderRequest.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.cancelOrderRequest = $root.ProtobufBroker.CancelOrderRequest.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.replaceOrderRequest = $root.ProtobufBroker.ReplaceOrderRequest.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.syncRequest = $root.ProtobufBroker.SyncRequest.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.closePositionRequest = $root.ProtobufBroker.ClosePositionRequest.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.settlePositionRequest = $root.ProtobufBroker.SettlePositionRequest.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a BrokerRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.BrokerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.BrokerRequest} BrokerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BrokerRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a BrokerRequest message.
         * @function verify
         * @memberof ProtobufBroker.BrokerRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BrokerRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.marketId != null && message.hasOwnProperty("marketId"))
                if (!$util.isInteger(message.marketId) && !(message.marketId && $util.isInteger(message.marketId.low) && $util.isInteger(message.marketId.high)))
                    return "marketId: integer|Long expected";
            if (message.placeOrderRequest != null && message.hasOwnProperty("placeOrderRequest")) {
                properties.Request = 1;
                {
                    var error = $root.ProtobufBroker.PlaceOrderRequest.verify(message.placeOrderRequest);
                    if (error)
                        return "placeOrderRequest." + error;
                }
            }
            if (message.cancelOrderRequest != null && message.hasOwnProperty("cancelOrderRequest")) {
                if (properties.Request === 1)
                    return "Request: multiple values";
                properties.Request = 1;
                {
                    var error = $root.ProtobufBroker.CancelOrderRequest.verify(message.cancelOrderRequest);
                    if (error)
                        return "cancelOrderRequest." + error;
                }
            }
            if (message.replaceOrderRequest != null && message.hasOwnProperty("replaceOrderRequest")) {
                if (properties.Request === 1)
                    return "Request: multiple values";
                properties.Request = 1;
                {
                    var error = $root.ProtobufBroker.ReplaceOrderRequest.verify(message.replaceOrderRequest);
                    if (error)
                        return "replaceOrderRequest." + error;
                }
            }
            if (message.syncRequest != null && message.hasOwnProperty("syncRequest")) {
                if (properties.Request === 1)
                    return "Request: multiple values";
                properties.Request = 1;
                {
                    var error = $root.ProtobufBroker.SyncRequest.verify(message.syncRequest);
                    if (error)
                        return "syncRequest." + error;
                }
            }
            if (message.closePositionRequest != null && message.hasOwnProperty("closePositionRequest")) {
                if (properties.Request === 1)
                    return "Request: multiple values";
                properties.Request = 1;
                {
                    var error = $root.ProtobufBroker.ClosePositionRequest.verify(message.closePositionRequest);
                    if (error)
                        return "closePositionRequest." + error;
                }
            }
            if (message.settlePositionRequest != null && message.hasOwnProperty("settlePositionRequest")) {
                if (properties.Request === 1)
                    return "Request: multiple values";
                properties.Request = 1;
                {
                    var error = $root.ProtobufBroker.SettlePositionRequest.verify(message.settlePositionRequest);
                    if (error)
                        return "settlePositionRequest." + error;
                }
            }
            return null;
        };
        /**
         * Creates a BrokerRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.BrokerRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.BrokerRequest} BrokerRequest
         */
        BrokerRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.BrokerRequest)
                return object;
            var message = new $root.ProtobufBroker.BrokerRequest();
            if (object.id != null)
                message.id = String(object.id);
            if (object.marketId != null)
                if ($util.Long)
                    (message.marketId = $util.Long.fromValue(object.marketId)).unsigned = false;
                else if (typeof object.marketId === "string")
                    message.marketId = parseInt(object.marketId, 10);
                else if (typeof object.marketId === "number")
                    message.marketId = object.marketId;
                else if (typeof object.marketId === "object")
                    message.marketId = new $util.LongBits(object.marketId.low >>> 0, object.marketId.high >>> 0).toNumber();
            if (object.placeOrderRequest != null) {
                if (typeof object.placeOrderRequest !== "object")
                    throw TypeError(".ProtobufBroker.BrokerRequest.placeOrderRequest: object expected");
                message.placeOrderRequest = $root.ProtobufBroker.PlaceOrderRequest.fromObject(object.placeOrderRequest);
            }
            if (object.cancelOrderRequest != null) {
                if (typeof object.cancelOrderRequest !== "object")
                    throw TypeError(".ProtobufBroker.BrokerRequest.cancelOrderRequest: object expected");
                message.cancelOrderRequest = $root.ProtobufBroker.CancelOrderRequest.fromObject(object.cancelOrderRequest);
            }
            if (object.replaceOrderRequest != null) {
                if (typeof object.replaceOrderRequest !== "object")
                    throw TypeError(".ProtobufBroker.BrokerRequest.replaceOrderRequest: object expected");
                message.replaceOrderRequest = $root.ProtobufBroker.ReplaceOrderRequest.fromObject(object.replaceOrderRequest);
            }
            if (object.syncRequest != null) {
                if (typeof object.syncRequest !== "object")
                    throw TypeError(".ProtobufBroker.BrokerRequest.syncRequest: object expected");
                message.syncRequest = $root.ProtobufBroker.SyncRequest.fromObject(object.syncRequest);
            }
            if (object.closePositionRequest != null) {
                if (typeof object.closePositionRequest !== "object")
                    throw TypeError(".ProtobufBroker.BrokerRequest.closePositionRequest: object expected");
                message.closePositionRequest = $root.ProtobufBroker.ClosePositionRequest.fromObject(object.closePositionRequest);
            }
            if (object.settlePositionRequest != null) {
                if (typeof object.settlePositionRequest !== "object")
                    throw TypeError(".ProtobufBroker.BrokerRequest.settlePositionRequest: object expected");
                message.settlePositionRequest = $root.ProtobufBroker.SettlePositionRequest.fromObject(object.settlePositionRequest);
            }
            return message;
        };
        /**
         * Creates a plain object from a BrokerRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.BrokerRequest
         * @static
         * @param {ProtobufBroker.BrokerRequest} message BrokerRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BrokerRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.marketId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.marketId = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.placeOrderRequest != null && message.hasOwnProperty("placeOrderRequest")) {
                object.placeOrderRequest = $root.ProtobufBroker.PlaceOrderRequest.toObject(message.placeOrderRequest, options);
                if (options.oneofs)
                    object.Request = "placeOrderRequest";
            }
            if (message.cancelOrderRequest != null && message.hasOwnProperty("cancelOrderRequest")) {
                object.cancelOrderRequest = $root.ProtobufBroker.CancelOrderRequest.toObject(message.cancelOrderRequest, options);
                if (options.oneofs)
                    object.Request = "cancelOrderRequest";
            }
            if (message.syncRequest != null && message.hasOwnProperty("syncRequest")) {
                object.syncRequest = $root.ProtobufBroker.SyncRequest.toObject(message.syncRequest, options);
                if (options.oneofs)
                    object.Request = "syncRequest";
            }
            if (message.closePositionRequest != null && message.hasOwnProperty("closePositionRequest")) {
                object.closePositionRequest = $root.ProtobufBroker.ClosePositionRequest.toObject(message.closePositionRequest, options);
                if (options.oneofs)
                    object.Request = "closePositionRequest";
            }
            if (message.replaceOrderRequest != null && message.hasOwnProperty("replaceOrderRequest")) {
                object.replaceOrderRequest = $root.ProtobufBroker.ReplaceOrderRequest.toObject(message.replaceOrderRequest, options);
                if (options.oneofs)
                    object.Request = "replaceOrderRequest";
            }
            if (message.marketId != null && message.hasOwnProperty("marketId"))
                if (typeof message.marketId === "number")
                    object.marketId = options.longs === String ? String(message.marketId) : message.marketId;
                else
                    object.marketId = options.longs === String ? $util.Long.prototype.toString.call(message.marketId) : options.longs === Number ? new $util.LongBits(message.marketId.low >>> 0, message.marketId.high >>> 0).toNumber() : message.marketId;
            if (message.settlePositionRequest != null && message.hasOwnProperty("settlePositionRequest")) {
                object.settlePositionRequest = $root.ProtobufBroker.SettlePositionRequest.toObject(message.settlePositionRequest, options);
                if (options.oneofs)
                    object.Request = "settlePositionRequest";
            }
            return object;
        };
        /**
         * Converts this BrokerRequest to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.BrokerRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BrokerRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return BrokerRequest;
    })();
    ProtobufBroker.OrdersUpdate = (function () {
        /**
         * Properties of an OrdersUpdate.
         * @memberof ProtobufBroker
         * @interface IOrdersUpdate
         * @property {Array.<ProtobufBroker.IPrivateOrder>|null} [orders] OrdersUpdate orders
         */
        /**
         * Constructs a new OrdersUpdate.
         * @memberof ProtobufBroker
         * @classdesc Represents an OrdersUpdate.
         * @implements IOrdersUpdate
         * @constructor
         * @param {ProtobufBroker.IOrdersUpdate=} [properties] Properties to set
         */
        function OrdersUpdate(properties) {
            this.orders = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * OrdersUpdate orders.
         * @member {Array.<ProtobufBroker.IPrivateOrder>} orders
         * @memberof ProtobufBroker.OrdersUpdate
         * @instance
         */
        OrdersUpdate.prototype.orders = $util.emptyArray;
        /**
         * Creates a new OrdersUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.OrdersUpdate
         * @static
         * @param {ProtobufBroker.IOrdersUpdate=} [properties] Properties to set
         * @returns {ProtobufBroker.OrdersUpdate} OrdersUpdate instance
         */
        OrdersUpdate.create = function create(properties) {
            return new OrdersUpdate(properties);
        };
        /**
         * Encodes the specified OrdersUpdate message. Does not implicitly {@link ProtobufBroker.OrdersUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.OrdersUpdate
         * @static
         * @param {ProtobufBroker.IOrdersUpdate} message OrdersUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrdersUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.orders != null && message.orders.length)
                for (var i = 0; i < message.orders.length; ++i)
                    $root.ProtobufBroker.PrivateOrder.encode(message.orders[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified OrdersUpdate message, length delimited. Does not implicitly {@link ProtobufBroker.OrdersUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.OrdersUpdate
         * @static
         * @param {ProtobufBroker.IOrdersUpdate} message OrdersUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrdersUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an OrdersUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.OrdersUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.OrdersUpdate} OrdersUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrdersUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.OrdersUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.orders && message.orders.length))
                            message.orders = [];
                        message.orders.push($root.ProtobufBroker.PrivateOrder.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an OrdersUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.OrdersUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.OrdersUpdate} OrdersUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrdersUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an OrdersUpdate message.
         * @function verify
         * @memberof ProtobufBroker.OrdersUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OrdersUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.orders != null && message.hasOwnProperty("orders")) {
                if (!Array.isArray(message.orders))
                    return "orders: array expected";
                for (var i = 0; i < message.orders.length; ++i) {
                    var error = $root.ProtobufBroker.PrivateOrder.verify(message.orders[i]);
                    if (error)
                        return "orders." + error;
                }
            }
            return null;
        };
        /**
         * Creates an OrdersUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.OrdersUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.OrdersUpdate} OrdersUpdate
         */
        OrdersUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.OrdersUpdate)
                return object;
            var message = new $root.ProtobufBroker.OrdersUpdate();
            if (object.orders) {
                if (!Array.isArray(object.orders))
                    throw TypeError(".ProtobufBroker.OrdersUpdate.orders: array expected");
                message.orders = [];
                for (var i = 0; i < object.orders.length; ++i) {
                    if (typeof object.orders[i] !== "object")
                        throw TypeError(".ProtobufBroker.OrdersUpdate.orders: object expected");
                    message.orders[i] = $root.ProtobufBroker.PrivateOrder.fromObject(object.orders[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from an OrdersUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.OrdersUpdate
         * @static
         * @param {ProtobufBroker.OrdersUpdate} message OrdersUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OrdersUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.orders = [];
            if (message.orders && message.orders.length) {
                object.orders = [];
                for (var j = 0; j < message.orders.length; ++j)
                    object.orders[j] = $root.ProtobufBroker.PrivateOrder.toObject(message.orders[j], options);
            }
            return object;
        };
        /**
         * Converts this OrdersUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.OrdersUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OrdersUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return OrdersUpdate;
    })();
    ProtobufBroker.TradesUpdate = (function () {
        /**
         * Properties of a TradesUpdate.
         * @memberof ProtobufBroker
         * @interface ITradesUpdate
         * @property {Array.<ProtobufBroker.IPrivateTrade>|null} [trades] TradesUpdate trades
         */
        /**
         * Constructs a new TradesUpdate.
         * @memberof ProtobufBroker
         * @classdesc Represents a TradesUpdate.
         * @implements ITradesUpdate
         * @constructor
         * @param {ProtobufBroker.ITradesUpdate=} [properties] Properties to set
         */
        function TradesUpdate(properties) {
            this.trades = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * TradesUpdate trades.
         * @member {Array.<ProtobufBroker.IPrivateTrade>} trades
         * @memberof ProtobufBroker.TradesUpdate
         * @instance
         */
        TradesUpdate.prototype.trades = $util.emptyArray;
        /**
         * Creates a new TradesUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.TradesUpdate
         * @static
         * @param {ProtobufBroker.ITradesUpdate=} [properties] Properties to set
         * @returns {ProtobufBroker.TradesUpdate} TradesUpdate instance
         */
        TradesUpdate.create = function create(properties) {
            return new TradesUpdate(properties);
        };
        /**
         * Encodes the specified TradesUpdate message. Does not implicitly {@link ProtobufBroker.TradesUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.TradesUpdate
         * @static
         * @param {ProtobufBroker.ITradesUpdate} message TradesUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradesUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trades != null && message.trades.length)
                for (var i = 0; i < message.trades.length; ++i)
                    $root.ProtobufBroker.PrivateTrade.encode(message.trades[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified TradesUpdate message, length delimited. Does not implicitly {@link ProtobufBroker.TradesUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.TradesUpdate
         * @static
         * @param {ProtobufBroker.ITradesUpdate} message TradesUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradesUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a TradesUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.TradesUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.TradesUpdate} TradesUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradesUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.TradesUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.trades && message.trades.length))
                            message.trades = [];
                        message.trades.push($root.ProtobufBroker.PrivateTrade.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a TradesUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.TradesUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.TradesUpdate} TradesUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradesUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a TradesUpdate message.
         * @function verify
         * @memberof ProtobufBroker.TradesUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TradesUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trades != null && message.hasOwnProperty("trades")) {
                if (!Array.isArray(message.trades))
                    return "trades: array expected";
                for (var i = 0; i < message.trades.length; ++i) {
                    var error = $root.ProtobufBroker.PrivateTrade.verify(message.trades[i]);
                    if (error)
                        return "trades." + error;
                }
            }
            return null;
        };
        /**
         * Creates a TradesUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.TradesUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.TradesUpdate} TradesUpdate
         */
        TradesUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.TradesUpdate)
                return object;
            var message = new $root.ProtobufBroker.TradesUpdate();
            if (object.trades) {
                if (!Array.isArray(object.trades))
                    throw TypeError(".ProtobufBroker.TradesUpdate.trades: array expected");
                message.trades = [];
                for (var i = 0; i < object.trades.length; ++i) {
                    if (typeof object.trades[i] !== "object")
                        throw TypeError(".ProtobufBroker.TradesUpdate.trades: object expected");
                    message.trades[i] = $root.ProtobufBroker.PrivateTrade.fromObject(object.trades[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a TradesUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.TradesUpdate
         * @static
         * @param {ProtobufBroker.TradesUpdate} message TradesUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TradesUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.trades = [];
            if (message.trades && message.trades.length) {
                object.trades = [];
                for (var j = 0; j < message.trades.length; ++j)
                    object.trades[j] = $root.ProtobufBroker.PrivateTrade.toObject(message.trades[j], options);
            }
            return object;
        };
        /**
         * Converts this TradesUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.TradesUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TradesUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return TradesUpdate;
    })();
    ProtobufBroker.PositionsUpdate = (function () {
        /**
         * Properties of a PositionsUpdate.
         * @memberof ProtobufBroker
         * @interface IPositionsUpdate
         * @property {Array.<ProtobufBroker.IPrivatePosition>|null} [positions] PositionsUpdate positions
         */
        /**
         * Constructs a new PositionsUpdate.
         * @memberof ProtobufBroker
         * @classdesc Represents a PositionsUpdate.
         * @implements IPositionsUpdate
         * @constructor
         * @param {ProtobufBroker.IPositionsUpdate=} [properties] Properties to set
         */
        function PositionsUpdate(properties) {
            this.positions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PositionsUpdate positions.
         * @member {Array.<ProtobufBroker.IPrivatePosition>} positions
         * @memberof ProtobufBroker.PositionsUpdate
         * @instance
         */
        PositionsUpdate.prototype.positions = $util.emptyArray;
        /**
         * Creates a new PositionsUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.PositionsUpdate
         * @static
         * @param {ProtobufBroker.IPositionsUpdate=} [properties] Properties to set
         * @returns {ProtobufBroker.PositionsUpdate} PositionsUpdate instance
         */
        PositionsUpdate.create = function create(properties) {
            return new PositionsUpdate(properties);
        };
        /**
         * Encodes the specified PositionsUpdate message. Does not implicitly {@link ProtobufBroker.PositionsUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.PositionsUpdate
         * @static
         * @param {ProtobufBroker.IPositionsUpdate} message PositionsUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PositionsUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.positions != null && message.positions.length)
                for (var i = 0; i < message.positions.length; ++i)
                    $root.ProtobufBroker.PrivatePosition.encode(message.positions[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified PositionsUpdate message, length delimited. Does not implicitly {@link ProtobufBroker.PositionsUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.PositionsUpdate
         * @static
         * @param {ProtobufBroker.IPositionsUpdate} message PositionsUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PositionsUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PositionsUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.PositionsUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.PositionsUpdate} PositionsUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PositionsUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.PositionsUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.positions && message.positions.length))
                            message.positions = [];
                        message.positions.push($root.ProtobufBroker.PrivatePosition.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PositionsUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.PositionsUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.PositionsUpdate} PositionsUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PositionsUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PositionsUpdate message.
         * @function verify
         * @memberof ProtobufBroker.PositionsUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PositionsUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.positions != null && message.hasOwnProperty("positions")) {
                if (!Array.isArray(message.positions))
                    return "positions: array expected";
                for (var i = 0; i < message.positions.length; ++i) {
                    var error = $root.ProtobufBroker.PrivatePosition.verify(message.positions[i]);
                    if (error)
                        return "positions." + error;
                }
            }
            return null;
        };
        /**
         * Creates a PositionsUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.PositionsUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.PositionsUpdate} PositionsUpdate
         */
        PositionsUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.PositionsUpdate)
                return object;
            var message = new $root.ProtobufBroker.PositionsUpdate();
            if (object.positions) {
                if (!Array.isArray(object.positions))
                    throw TypeError(".ProtobufBroker.PositionsUpdate.positions: array expected");
                message.positions = [];
                for (var i = 0; i < object.positions.length; ++i) {
                    if (typeof object.positions[i] !== "object")
                        throw TypeError(".ProtobufBroker.PositionsUpdate.positions: object expected");
                    message.positions[i] = $root.ProtobufBroker.PrivatePosition.fromObject(object.positions[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a PositionsUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.PositionsUpdate
         * @static
         * @param {ProtobufBroker.PositionsUpdate} message PositionsUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PositionsUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.positions = [];
            if (message.positions && message.positions.length) {
                object.positions = [];
                for (var j = 0; j < message.positions.length; ++j)
                    object.positions[j] = $root.ProtobufBroker.PrivatePosition.toObject(message.positions[j], options);
            }
            return object;
        };
        /**
         * Converts this PositionsUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.PositionsUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PositionsUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PositionsUpdate;
    })();
    ProtobufBroker.BalancesUpdate = (function () {
        /**
         * Properties of a BalancesUpdate.
         * @memberof ProtobufBroker
         * @interface IBalancesUpdate
         * @property {Array.<ProtobufBroker.IBalances>|null} [balances] BalancesUpdate balances
         * @property {Array.<ProtobufBroker.IBalances>|null} [total] BalancesUpdate total
         */
        /**
         * Constructs a new BalancesUpdate.
         * @memberof ProtobufBroker
         * @classdesc Represents a BalancesUpdate.
         * @implements IBalancesUpdate
         * @constructor
         * @param {ProtobufBroker.IBalancesUpdate=} [properties] Properties to set
         */
        function BalancesUpdate(properties) {
            this.balances = [];
            this.total = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * BalancesUpdate balances.
         * @member {Array.<ProtobufBroker.IBalances>} balances
         * @memberof ProtobufBroker.BalancesUpdate
         * @instance
         */
        BalancesUpdate.prototype.balances = $util.emptyArray;
        /**
         * BalancesUpdate total.
         * @member {Array.<ProtobufBroker.IBalances>} total
         * @memberof ProtobufBroker.BalancesUpdate
         * @instance
         */
        BalancesUpdate.prototype.total = $util.emptyArray;
        /**
         * Creates a new BalancesUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.BalancesUpdate
         * @static
         * @param {ProtobufBroker.IBalancesUpdate=} [properties] Properties to set
         * @returns {ProtobufBroker.BalancesUpdate} BalancesUpdate instance
         */
        BalancesUpdate.create = function create(properties) {
            return new BalancesUpdate(properties);
        };
        /**
         * Encodes the specified BalancesUpdate message. Does not implicitly {@link ProtobufBroker.BalancesUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.BalancesUpdate
         * @static
         * @param {ProtobufBroker.IBalancesUpdate} message BalancesUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BalancesUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.balances != null && message.balances.length)
                for (var i = 0; i < message.balances.length; ++i)
                    $root.ProtobufBroker.Balances.encode(message.balances[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.total != null && message.total.length)
                for (var i = 0; i < message.total.length; ++i)
                    $root.ProtobufBroker.Balances.encode(message.total[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified BalancesUpdate message, length delimited. Does not implicitly {@link ProtobufBroker.BalancesUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.BalancesUpdate
         * @static
         * @param {ProtobufBroker.IBalancesUpdate} message BalancesUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BalancesUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a BalancesUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.BalancesUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.BalancesUpdate} BalancesUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BalancesUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.BalancesUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.balances && message.balances.length))
                            message.balances = [];
                        message.balances.push($root.ProtobufBroker.Balances.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.total && message.total.length))
                            message.total = [];
                        message.total.push($root.ProtobufBroker.Balances.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a BalancesUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.BalancesUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.BalancesUpdate} BalancesUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BalancesUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a BalancesUpdate message.
         * @function verify
         * @memberof ProtobufBroker.BalancesUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BalancesUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.balances != null && message.hasOwnProperty("balances")) {
                if (!Array.isArray(message.balances))
                    return "balances: array expected";
                for (var i = 0; i < message.balances.length; ++i) {
                    var error = $root.ProtobufBroker.Balances.verify(message.balances[i]);
                    if (error)
                        return "balances." + error;
                }
            }
            if (message.total != null && message.hasOwnProperty("total")) {
                if (!Array.isArray(message.total))
                    return "total: array expected";
                for (var i = 0; i < message.total.length; ++i) {
                    var error = $root.ProtobufBroker.Balances.verify(message.total[i]);
                    if (error)
                        return "total." + error;
                }
            }
            return null;
        };
        /**
         * Creates a BalancesUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.BalancesUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.BalancesUpdate} BalancesUpdate
         */
        BalancesUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.BalancesUpdate)
                return object;
            var message = new $root.ProtobufBroker.BalancesUpdate();
            if (object.balances) {
                if (!Array.isArray(object.balances))
                    throw TypeError(".ProtobufBroker.BalancesUpdate.balances: array expected");
                message.balances = [];
                for (var i = 0; i < object.balances.length; ++i) {
                    if (typeof object.balances[i] !== "object")
                        throw TypeError(".ProtobufBroker.BalancesUpdate.balances: object expected");
                    message.balances[i] = $root.ProtobufBroker.Balances.fromObject(object.balances[i]);
                }
            }
            if (object.total) {
                if (!Array.isArray(object.total))
                    throw TypeError(".ProtobufBroker.BalancesUpdate.total: array expected");
                message.total = [];
                for (var i = 0; i < object.total.length; ++i) {
                    if (typeof object.total[i] !== "object")
                        throw TypeError(".ProtobufBroker.BalancesUpdate.total: object expected");
                    message.total[i] = $root.ProtobufBroker.Balances.fromObject(object.total[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a BalancesUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.BalancesUpdate
         * @static
         * @param {ProtobufBroker.BalancesUpdate} message BalancesUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BalancesUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.balances = [];
                object.total = [];
            }
            if (message.balances && message.balances.length) {
                object.balances = [];
                for (var j = 0; j < message.balances.length; ++j)
                    object.balances[j] = $root.ProtobufBroker.Balances.toObject(message.balances[j], options);
            }
            if (message.total && message.total.length) {
                object.total = [];
                for (var j = 0; j < message.total.length; ++j)
                    object.total[j] = $root.ProtobufBroker.Balances.toObject(message.total[j], options);
            }
            return object;
        };
        /**
         * Converts this BalancesUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.BalancesUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BalancesUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return BalancesUpdate;
    })();
    ProtobufBroker.LedgersUpdate = (function () {
        /**
         * Properties of a LedgersUpdate.
         * @memberof ProtobufBroker
         * @interface ILedgersUpdate
         * @property {Array.<ProtobufBroker.IPrivateLedger>|null} [ledgers] LedgersUpdate ledgers
         */
        /**
         * Constructs a new LedgersUpdate.
         * @memberof ProtobufBroker
         * @classdesc Represents a LedgersUpdate.
         * @implements ILedgersUpdate
         * @constructor
         * @param {ProtobufBroker.ILedgersUpdate=} [properties] Properties to set
         */
        function LedgersUpdate(properties) {
            this.ledgers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * LedgersUpdate ledgers.
         * @member {Array.<ProtobufBroker.IPrivateLedger>} ledgers
         * @memberof ProtobufBroker.LedgersUpdate
         * @instance
         */
        LedgersUpdate.prototype.ledgers = $util.emptyArray;
        /**
         * Creates a new LedgersUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.LedgersUpdate
         * @static
         * @param {ProtobufBroker.ILedgersUpdate=} [properties] Properties to set
         * @returns {ProtobufBroker.LedgersUpdate} LedgersUpdate instance
         */
        LedgersUpdate.create = function create(properties) {
            return new LedgersUpdate(properties);
        };
        /**
         * Encodes the specified LedgersUpdate message. Does not implicitly {@link ProtobufBroker.LedgersUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.LedgersUpdate
         * @static
         * @param {ProtobufBroker.ILedgersUpdate} message LedgersUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LedgersUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ledgers != null && message.ledgers.length)
                for (var i = 0; i < message.ledgers.length; ++i)
                    $root.ProtobufBroker.PrivateLedger.encode(message.ledgers[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified LedgersUpdate message, length delimited. Does not implicitly {@link ProtobufBroker.LedgersUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.LedgersUpdate
         * @static
         * @param {ProtobufBroker.ILedgersUpdate} message LedgersUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LedgersUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a LedgersUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.LedgersUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.LedgersUpdate} LedgersUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LedgersUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.LedgersUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.ledgers && message.ledgers.length))
                            message.ledgers = [];
                        message.ledgers.push($root.ProtobufBroker.PrivateLedger.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a LedgersUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.LedgersUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.LedgersUpdate} LedgersUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LedgersUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a LedgersUpdate message.
         * @function verify
         * @memberof ProtobufBroker.LedgersUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LedgersUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ledgers != null && message.hasOwnProperty("ledgers")) {
                if (!Array.isArray(message.ledgers))
                    return "ledgers: array expected";
                for (var i = 0; i < message.ledgers.length; ++i) {
                    var error = $root.ProtobufBroker.PrivateLedger.verify(message.ledgers[i]);
                    if (error)
                        return "ledgers." + error;
                }
            }
            return null;
        };
        /**
         * Creates a LedgersUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.LedgersUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.LedgersUpdate} LedgersUpdate
         */
        LedgersUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.LedgersUpdate)
                return object;
            var message = new $root.ProtobufBroker.LedgersUpdate();
            if (object.ledgers) {
                if (!Array.isArray(object.ledgers))
                    throw TypeError(".ProtobufBroker.LedgersUpdate.ledgers: array expected");
                message.ledgers = [];
                for (var i = 0; i < object.ledgers.length; ++i) {
                    if (typeof object.ledgers[i] !== "object")
                        throw TypeError(".ProtobufBroker.LedgersUpdate.ledgers: object expected");
                    message.ledgers[i] = $root.ProtobufBroker.PrivateLedger.fromObject(object.ledgers[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a LedgersUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.LedgersUpdate
         * @static
         * @param {ProtobufBroker.LedgersUpdate} message LedgersUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LedgersUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ledgers = [];
            if (message.ledgers && message.ledgers.length) {
                object.ledgers = [];
                for (var j = 0; j < message.ledgers.length; ++j)
                    object.ledgers[j] = $root.ProtobufBroker.PrivateLedger.toObject(message.ledgers[j], options);
            }
            return object;
        };
        /**
         * Converts this LedgersUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.LedgersUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LedgersUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return LedgersUpdate;
    })();
    ProtobufBroker.RequestResolutionUpdate = (function () {
        /**
         * Properties of a RequestResolutionUpdate.
         * @memberof ProtobufBroker
         * @interface IRequestResolutionUpdate
         * @property {string|null} [id] RequestResolutionUpdate id
         * @property {number|null} [error] RequestResolutionUpdate error
         * @property {string|null} [message] RequestResolutionUpdate message
         * @property {ProtobufBroker.IError|null} [errorV2] RequestResolutionUpdate errorV2
         * @property {ProtobufBroker.IPlaceOrderResult|null} [placeOrderResult] RequestResolutionUpdate placeOrderResult
         * @property {ProtobufBroker.ICancelOrderResult|null} [cancelOrderResult] RequestResolutionUpdate cancelOrderResult
         */
        /**
         * Constructs a new RequestResolutionUpdate.
         * @memberof ProtobufBroker
         * @classdesc Represents a RequestResolutionUpdate.
         * @implements IRequestResolutionUpdate
         * @constructor
         * @param {ProtobufBroker.IRequestResolutionUpdate=} [properties] Properties to set
         */
        function RequestResolutionUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * RequestResolutionUpdate id.
         * @member {string} id
         * @memberof ProtobufBroker.RequestResolutionUpdate
         * @instance
         */
        RequestResolutionUpdate.prototype.id = "";
        /**
         * RequestResolutionUpdate error.
         * @member {number} error
         * @memberof ProtobufBroker.RequestResolutionUpdate
         * @instance
         */
        RequestResolutionUpdate.prototype.error = 0;
        /**
         * RequestResolutionUpdate message.
         * @member {string} message
         * @memberof ProtobufBroker.RequestResolutionUpdate
         * @instance
         */
        RequestResolutionUpdate.prototype.message = "";
        /**
         * RequestResolutionUpdate errorV2.
         * @member {ProtobufBroker.IError|null|undefined} errorV2
         * @memberof ProtobufBroker.RequestResolutionUpdate
         * @instance
         */
        RequestResolutionUpdate.prototype.errorV2 = null;
        /**
         * RequestResolutionUpdate placeOrderResult.
         * @member {ProtobufBroker.IPlaceOrderResult|null|undefined} placeOrderResult
         * @memberof ProtobufBroker.RequestResolutionUpdate
         * @instance
         */
        RequestResolutionUpdate.prototype.placeOrderResult = null;
        /**
         * RequestResolutionUpdate cancelOrderResult.
         * @member {ProtobufBroker.ICancelOrderResult|null|undefined} cancelOrderResult
         * @memberof ProtobufBroker.RequestResolutionUpdate
         * @instance
         */
        RequestResolutionUpdate.prototype.cancelOrderResult = null;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * RequestResolutionUpdate Result.
         * @member {"placeOrderResult"|"cancelOrderResult"|undefined} Result
         * @memberof ProtobufBroker.RequestResolutionUpdate
         * @instance
         */
        Object.defineProperty(RequestResolutionUpdate.prototype, "Result", {
            get: $util.oneOfGetter($oneOfFields = ["placeOrderResult", "cancelOrderResult"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new RequestResolutionUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.RequestResolutionUpdate
         * @static
         * @param {ProtobufBroker.IRequestResolutionUpdate=} [properties] Properties to set
         * @returns {ProtobufBroker.RequestResolutionUpdate} RequestResolutionUpdate instance
         */
        RequestResolutionUpdate.create = function create(properties) {
            return new RequestResolutionUpdate(properties);
        };
        /**
         * Encodes the specified RequestResolutionUpdate message. Does not implicitly {@link ProtobufBroker.RequestResolutionUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.RequestResolutionUpdate
         * @static
         * @param {ProtobufBroker.IRequestResolutionUpdate} message RequestResolutionUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestResolutionUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
            if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.error);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.message);
            if (message.placeOrderResult != null && Object.hasOwnProperty.call(message, "placeOrderResult"))
                $root.ProtobufBroker.PlaceOrderResult.encode(message.placeOrderResult, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            if (message.cancelOrderResult != null && Object.hasOwnProperty.call(message, "cancelOrderResult"))
                $root.ProtobufBroker.CancelOrderResult.encode(message.cancelOrderResult, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
            if (message.errorV2 != null && Object.hasOwnProperty.call(message, "errorV2"))
                $root.ProtobufBroker.Error.encode(message.errorV2, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified RequestResolutionUpdate message, length delimited. Does not implicitly {@link ProtobufBroker.RequestResolutionUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.RequestResolutionUpdate
         * @static
         * @param {ProtobufBroker.IRequestResolutionUpdate} message RequestResolutionUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestResolutionUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestResolutionUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.RequestResolutionUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.RequestResolutionUpdate} RequestResolutionUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestResolutionUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.RequestResolutionUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.error = reader.int32();
                        break;
                    case 3:
                        message.message = reader.string();
                        break;
                    case 6:
                        message.errorV2 = $root.ProtobufBroker.Error.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.placeOrderResult = $root.ProtobufBroker.PlaceOrderResult.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.cancelOrderResult = $root.ProtobufBroker.CancelOrderResult.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestResolutionUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.RequestResolutionUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.RequestResolutionUpdate} RequestResolutionUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestResolutionUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestResolutionUpdate message.
         * @function verify
         * @memberof ProtobufBroker.RequestResolutionUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestResolutionUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.error != null && message.hasOwnProperty("error"))
                if (!$util.isInteger(message.error))
                    return "error: integer expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.errorV2 != null && message.hasOwnProperty("errorV2")) {
                var error = $root.ProtobufBroker.Error.verify(message.errorV2);
                if (error)
                    return "errorV2." + error;
            }
            if (message.placeOrderResult != null && message.hasOwnProperty("placeOrderResult")) {
                properties.Result = 1;
                {
                    var error = $root.ProtobufBroker.PlaceOrderResult.verify(message.placeOrderResult);
                    if (error)
                        return "placeOrderResult." + error;
                }
            }
            if (message.cancelOrderResult != null && message.hasOwnProperty("cancelOrderResult")) {
                if (properties.Result === 1)
                    return "Result: multiple values";
                properties.Result = 1;
                {
                    var error = $root.ProtobufBroker.CancelOrderResult.verify(message.cancelOrderResult);
                    if (error)
                        return "cancelOrderResult." + error;
                }
            }
            return null;
        };
        /**
         * Creates a RequestResolutionUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.RequestResolutionUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.RequestResolutionUpdate} RequestResolutionUpdate
         */
        RequestResolutionUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.RequestResolutionUpdate)
                return object;
            var message = new $root.ProtobufBroker.RequestResolutionUpdate();
            if (object.id != null)
                message.id = String(object.id);
            if (object.error != null)
                message.error = object.error | 0;
            if (object.message != null)
                message.message = String(object.message);
            if (object.errorV2 != null) {
                if (typeof object.errorV2 !== "object")
                    throw TypeError(".ProtobufBroker.RequestResolutionUpdate.errorV2: object expected");
                message.errorV2 = $root.ProtobufBroker.Error.fromObject(object.errorV2);
            }
            if (object.placeOrderResult != null) {
                if (typeof object.placeOrderResult !== "object")
                    throw TypeError(".ProtobufBroker.RequestResolutionUpdate.placeOrderResult: object expected");
                message.placeOrderResult = $root.ProtobufBroker.PlaceOrderResult.fromObject(object.placeOrderResult);
            }
            if (object.cancelOrderResult != null) {
                if (typeof object.cancelOrderResult !== "object")
                    throw TypeError(".ProtobufBroker.RequestResolutionUpdate.cancelOrderResult: object expected");
                message.cancelOrderResult = $root.ProtobufBroker.CancelOrderResult.fromObject(object.cancelOrderResult);
            }
            return message;
        };
        /**
         * Creates a plain object from a RequestResolutionUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.RequestResolutionUpdate
         * @static
         * @param {ProtobufBroker.RequestResolutionUpdate} message RequestResolutionUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestResolutionUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.error = 0;
                object.message = "";
                object.errorV2 = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = message.error;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.placeOrderResult != null && message.hasOwnProperty("placeOrderResult")) {
                object.placeOrderResult = $root.ProtobufBroker.PlaceOrderResult.toObject(message.placeOrderResult, options);
                if (options.oneofs)
                    object.Result = "placeOrderResult";
            }
            if (message.cancelOrderResult != null && message.hasOwnProperty("cancelOrderResult")) {
                object.cancelOrderResult = $root.ProtobufBroker.CancelOrderResult.toObject(message.cancelOrderResult, options);
                if (options.oneofs)
                    object.Result = "cancelOrderResult";
            }
            if (message.errorV2 != null && message.hasOwnProperty("errorV2"))
                object.errorV2 = $root.ProtobufBroker.Error.toObject(message.errorV2, options);
            return object;
        };
        /**
         * Converts this RequestResolutionUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.RequestResolutionUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestResolutionUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestResolutionUpdate;
    })();
    ProtobufBroker.AnonymousSessionStatusUpdate = (function () {
        /**
         * Properties of an AnonymousSessionStatusUpdate.
         * @memberof ProtobufBroker
         * @interface IAnonymousSessionStatusUpdate
         * @property {number|Long|null} [expiration] AnonymousSessionStatusUpdate expiration
         * @property {string|null} [token] AnonymousSessionStatusUpdate token
         */
        /**
         * Constructs a new AnonymousSessionStatusUpdate.
         * @memberof ProtobufBroker
         * @classdesc Represents an AnonymousSessionStatusUpdate.
         * @implements IAnonymousSessionStatusUpdate
         * @constructor
         * @param {ProtobufBroker.IAnonymousSessionStatusUpdate=} [properties] Properties to set
         */
        function AnonymousSessionStatusUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * AnonymousSessionStatusUpdate expiration.
         * @member {number|Long} expiration
         * @memberof ProtobufBroker.AnonymousSessionStatusUpdate
         * @instance
         */
        AnonymousSessionStatusUpdate.prototype.expiration = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * AnonymousSessionStatusUpdate token.
         * @member {string} token
         * @memberof ProtobufBroker.AnonymousSessionStatusUpdate
         * @instance
         */
        AnonymousSessionStatusUpdate.prototype.token = "";
        /**
         * Creates a new AnonymousSessionStatusUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.AnonymousSessionStatusUpdate
         * @static
         * @param {ProtobufBroker.IAnonymousSessionStatusUpdate=} [properties] Properties to set
         * @returns {ProtobufBroker.AnonymousSessionStatusUpdate} AnonymousSessionStatusUpdate instance
         */
        AnonymousSessionStatusUpdate.create = function create(properties) {
            return new AnonymousSessionStatusUpdate(properties);
        };
        /**
         * Encodes the specified AnonymousSessionStatusUpdate message. Does not implicitly {@link ProtobufBroker.AnonymousSessionStatusUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.AnonymousSessionStatusUpdate
         * @static
         * @param {ProtobufBroker.IAnonymousSessionStatusUpdate} message AnonymousSessionStatusUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AnonymousSessionStatusUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.expiration != null && Object.hasOwnProperty.call(message, "expiration"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.expiration);
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.token);
            return writer;
        };
        /**
         * Encodes the specified AnonymousSessionStatusUpdate message, length delimited. Does not implicitly {@link ProtobufBroker.AnonymousSessionStatusUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.AnonymousSessionStatusUpdate
         * @static
         * @param {ProtobufBroker.IAnonymousSessionStatusUpdate} message AnonymousSessionStatusUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AnonymousSessionStatusUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an AnonymousSessionStatusUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.AnonymousSessionStatusUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.AnonymousSessionStatusUpdate} AnonymousSessionStatusUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AnonymousSessionStatusUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.AnonymousSessionStatusUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.expiration = reader.int64();
                        break;
                    case 2:
                        message.token = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an AnonymousSessionStatusUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.AnonymousSessionStatusUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.AnonymousSessionStatusUpdate} AnonymousSessionStatusUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AnonymousSessionStatusUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an AnonymousSessionStatusUpdate message.
         * @function verify
         * @memberof ProtobufBroker.AnonymousSessionStatusUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AnonymousSessionStatusUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                    return "expiration: integer|Long expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!$util.isString(message.token))
                    return "token: string expected";
            return null;
        };
        /**
         * Creates an AnonymousSessionStatusUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.AnonymousSessionStatusUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.AnonymousSessionStatusUpdate} AnonymousSessionStatusUpdate
         */
        AnonymousSessionStatusUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.AnonymousSessionStatusUpdate)
                return object;
            var message = new $root.ProtobufBroker.AnonymousSessionStatusUpdate();
            if (object.expiration != null)
                if ($util.Long)
                    (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                else if (typeof object.expiration === "string")
                    message.expiration = parseInt(object.expiration, 10);
                else if (typeof object.expiration === "number")
                    message.expiration = object.expiration;
                else if (typeof object.expiration === "object")
                    message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
            if (object.token != null)
                message.token = String(object.token);
            return message;
        };
        /**
         * Creates a plain object from an AnonymousSessionStatusUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.AnonymousSessionStatusUpdate
         * @static
         * @param {ProtobufBroker.AnonymousSessionStatusUpdate} message AnonymousSessionStatusUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AnonymousSessionStatusUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.expiration = options.longs === String ? "0" : 0;
                object.token = "";
            }
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (typeof message.expiration === "number")
                    object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                else
                    object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = message.token;
            return object;
        };
        /**
         * Converts this AnonymousSessionStatusUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.AnonymousSessionStatusUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AnonymousSessionStatusUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return AnonymousSessionStatusUpdate;
    })();
    ProtobufBroker.SessionStatusUpdate = (function () {
        /**
         * Properties of a SessionStatusUpdate.
         * @memberof ProtobufBroker
         * @interface ISessionStatusUpdate
         * @property {boolean|null} [initialized] SessionStatusUpdate initialized
         * @property {boolean|null} [syncing] SessionStatusUpdate syncing
         * @property {number|Long|null} [lastSyncTime] SessionStatusUpdate lastSyncTime
         * @property {number|null} [syncError] SessionStatusUpdate syncError
         */
        /**
         * Constructs a new SessionStatusUpdate.
         * @memberof ProtobufBroker
         * @classdesc Represents a SessionStatusUpdate.
         * @implements ISessionStatusUpdate
         * @constructor
         * @param {ProtobufBroker.ISessionStatusUpdate=} [properties] Properties to set
         */
        function SessionStatusUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * SessionStatusUpdate initialized.
         * @member {boolean} initialized
         * @memberof ProtobufBroker.SessionStatusUpdate
         * @instance
         */
        SessionStatusUpdate.prototype.initialized = false;
        /**
         * SessionStatusUpdate syncing.
         * @member {boolean} syncing
         * @memberof ProtobufBroker.SessionStatusUpdate
         * @instance
         */
        SessionStatusUpdate.prototype.syncing = false;
        /**
         * SessionStatusUpdate lastSyncTime.
         * @member {number|Long} lastSyncTime
         * @memberof ProtobufBroker.SessionStatusUpdate
         * @instance
         */
        SessionStatusUpdate.prototype.lastSyncTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * SessionStatusUpdate syncError.
         * @member {number} syncError
         * @memberof ProtobufBroker.SessionStatusUpdate
         * @instance
         */
        SessionStatusUpdate.prototype.syncError = 0;
        /**
         * Creates a new SessionStatusUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.SessionStatusUpdate
         * @static
         * @param {ProtobufBroker.ISessionStatusUpdate=} [properties] Properties to set
         * @returns {ProtobufBroker.SessionStatusUpdate} SessionStatusUpdate instance
         */
        SessionStatusUpdate.create = function create(properties) {
            return new SessionStatusUpdate(properties);
        };
        /**
         * Encodes the specified SessionStatusUpdate message. Does not implicitly {@link ProtobufBroker.SessionStatusUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.SessionStatusUpdate
         * @static
         * @param {ProtobufBroker.ISessionStatusUpdate} message SessionStatusUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionStatusUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.initialized != null && Object.hasOwnProperty.call(message, "initialized"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.initialized);
            if (message.syncing != null && Object.hasOwnProperty.call(message, "syncing"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.syncing);
            if (message.lastSyncTime != null && Object.hasOwnProperty.call(message, "lastSyncTime"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.lastSyncTime);
            if (message.syncError != null && Object.hasOwnProperty.call(message, "syncError"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.syncError);
            return writer;
        };
        /**
         * Encodes the specified SessionStatusUpdate message, length delimited. Does not implicitly {@link ProtobufBroker.SessionStatusUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.SessionStatusUpdate
         * @static
         * @param {ProtobufBroker.ISessionStatusUpdate} message SessionStatusUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionStatusUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a SessionStatusUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.SessionStatusUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.SessionStatusUpdate} SessionStatusUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionStatusUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.SessionStatusUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.initialized = reader.bool();
                        break;
                    case 2:
                        message.syncing = reader.bool();
                        break;
                    case 3:
                        message.lastSyncTime = reader.int64();
                        break;
                    case 4:
                        message.syncError = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a SessionStatusUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.SessionStatusUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.SessionStatusUpdate} SessionStatusUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionStatusUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a SessionStatusUpdate message.
         * @function verify
         * @memberof ProtobufBroker.SessionStatusUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionStatusUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.initialized != null && message.hasOwnProperty("initialized"))
                if (typeof message.initialized !== "boolean")
                    return "initialized: boolean expected";
            if (message.syncing != null && message.hasOwnProperty("syncing"))
                if (typeof message.syncing !== "boolean")
                    return "syncing: boolean expected";
            if (message.lastSyncTime != null && message.hasOwnProperty("lastSyncTime"))
                if (!$util.isInteger(message.lastSyncTime) && !(message.lastSyncTime && $util.isInteger(message.lastSyncTime.low) && $util.isInteger(message.lastSyncTime.high)))
                    return "lastSyncTime: integer|Long expected";
            if (message.syncError != null && message.hasOwnProperty("syncError"))
                if (!$util.isInteger(message.syncError))
                    return "syncError: integer expected";
            return null;
        };
        /**
         * Creates a SessionStatusUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.SessionStatusUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.SessionStatusUpdate} SessionStatusUpdate
         */
        SessionStatusUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.SessionStatusUpdate)
                return object;
            var message = new $root.ProtobufBroker.SessionStatusUpdate();
            if (object.initialized != null)
                message.initialized = Boolean(object.initialized);
            if (object.syncing != null)
                message.syncing = Boolean(object.syncing);
            if (object.lastSyncTime != null)
                if ($util.Long)
                    (message.lastSyncTime = $util.Long.fromValue(object.lastSyncTime)).unsigned = false;
                else if (typeof object.lastSyncTime === "string")
                    message.lastSyncTime = parseInt(object.lastSyncTime, 10);
                else if (typeof object.lastSyncTime === "number")
                    message.lastSyncTime = object.lastSyncTime;
                else if (typeof object.lastSyncTime === "object")
                    message.lastSyncTime = new $util.LongBits(object.lastSyncTime.low >>> 0, object.lastSyncTime.high >>> 0).toNumber();
            if (object.syncError != null)
                message.syncError = object.syncError | 0;
            return message;
        };
        /**
         * Creates a plain object from a SessionStatusUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.SessionStatusUpdate
         * @static
         * @param {ProtobufBroker.SessionStatusUpdate} message SessionStatusUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionStatusUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.initialized = false;
                object.syncing = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.lastSyncTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.lastSyncTime = options.longs === String ? "0" : 0;
                object.syncError = 0;
            }
            if (message.initialized != null && message.hasOwnProperty("initialized"))
                object.initialized = message.initialized;
            if (message.syncing != null && message.hasOwnProperty("syncing"))
                object.syncing = message.syncing;
            if (message.lastSyncTime != null && message.hasOwnProperty("lastSyncTime"))
                if (typeof message.lastSyncTime === "number")
                    object.lastSyncTime = options.longs === String ? String(message.lastSyncTime) : message.lastSyncTime;
                else
                    object.lastSyncTime = options.longs === String ? $util.Long.prototype.toString.call(message.lastSyncTime) : options.longs === Number ? new $util.LongBits(message.lastSyncTime.low >>> 0, message.lastSyncTime.high >>> 0).toNumber() : message.lastSyncTime;
            if (message.syncError != null && message.hasOwnProperty("syncError"))
                object.syncError = message.syncError;
            return object;
        };
        /**
         * Converts this SessionStatusUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.SessionStatusUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionStatusUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return SessionStatusUpdate;
    })();
    ProtobufBroker.PermissionsUpdate = (function () {
        /**
         * Properties of a PermissionsUpdate.
         * @memberof ProtobufBroker
         * @interface IPermissionsUpdate
         * @property {Array.<ProtobufBroker.PrivateOrder.Type>|null} [orderTypes] PermissionsUpdate orderTypes
         * @property {Array.<ProtobufBroker.FundingType>|null} [fundingTypes] PermissionsUpdate fundingTypes
         * @property {Array.<ProtobufBroker.PermissionsUpdate.IAgreement>|null} [agreements] PermissionsUpdate agreements
         * @property {ProtobufBroker.PermissionsUpdate.ILeverageLevels|null} [leverageLevels] PermissionsUpdate leverageLevels
         * @property {boolean|null} [supportsOrderExpiry] PermissionsUpdate supportsOrderExpiry
         */
        /**
         * Constructs a new PermissionsUpdate.
         * @memberof ProtobufBroker
         * @classdesc Represents a PermissionsUpdate.
         * @implements IPermissionsUpdate
         * @constructor
         * @param {ProtobufBroker.IPermissionsUpdate=} [properties] Properties to set
         */
        function PermissionsUpdate(properties) {
            this.orderTypes = [];
            this.fundingTypes = [];
            this.agreements = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PermissionsUpdate orderTypes.
         * @member {Array.<ProtobufBroker.PrivateOrder.Type>} orderTypes
         * @memberof ProtobufBroker.PermissionsUpdate
         * @instance
         */
        PermissionsUpdate.prototype.orderTypes = $util.emptyArray;
        /**
         * PermissionsUpdate fundingTypes.
         * @member {Array.<ProtobufBroker.FundingType>} fundingTypes
         * @memberof ProtobufBroker.PermissionsUpdate
         * @instance
         */
        PermissionsUpdate.prototype.fundingTypes = $util.emptyArray;
        /**
         * PermissionsUpdate agreements.
         * @member {Array.<ProtobufBroker.PermissionsUpdate.IAgreement>} agreements
         * @memberof ProtobufBroker.PermissionsUpdate
         * @instance
         */
        PermissionsUpdate.prototype.agreements = $util.emptyArray;
        /**
         * PermissionsUpdate leverageLevels.
         * @member {ProtobufBroker.PermissionsUpdate.ILeverageLevels|null|undefined} leverageLevels
         * @memberof ProtobufBroker.PermissionsUpdate
         * @instance
         */
        PermissionsUpdate.prototype.leverageLevels = null;
        /**
         * PermissionsUpdate supportsOrderExpiry.
         * @member {boolean} supportsOrderExpiry
         * @memberof ProtobufBroker.PermissionsUpdate
         * @instance
         */
        PermissionsUpdate.prototype.supportsOrderExpiry = false;
        /**
         * Creates a new PermissionsUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.PermissionsUpdate
         * @static
         * @param {ProtobufBroker.IPermissionsUpdate=} [properties] Properties to set
         * @returns {ProtobufBroker.PermissionsUpdate} PermissionsUpdate instance
         */
        PermissionsUpdate.create = function create(properties) {
            return new PermissionsUpdate(properties);
        };
        /**
         * Encodes the specified PermissionsUpdate message. Does not implicitly {@link ProtobufBroker.PermissionsUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.PermissionsUpdate
         * @static
         * @param {ProtobufBroker.IPermissionsUpdate} message PermissionsUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PermissionsUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.orderTypes != null && message.orderTypes.length)
                for (var i = 0; i < message.orderTypes.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.orderTypes[i]);
            if (message.fundingTypes != null && message.fundingTypes.length)
                for (var i = 0; i < message.fundingTypes.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.fundingTypes[i]);
            if (message.agreements != null && message.agreements.length)
                for (var i = 0; i < message.agreements.length; ++i)
                    $root.ProtobufBroker.PermissionsUpdate.Agreement.encode(message.agreements[i], writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            if (message.leverageLevels != null && Object.hasOwnProperty.call(message, "leverageLevels"))
                $root.ProtobufBroker.PermissionsUpdate.LeverageLevels.encode(message.leverageLevels, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
            if (message.supportsOrderExpiry != null && Object.hasOwnProperty.call(message, "supportsOrderExpiry"))
                writer.uint32(/* id 7, wireType 0 =*/ 56).bool(message.supportsOrderExpiry);
            return writer;
        };
        /**
         * Encodes the specified PermissionsUpdate message, length delimited. Does not implicitly {@link ProtobufBroker.PermissionsUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.PermissionsUpdate
         * @static
         * @param {ProtobufBroker.IPermissionsUpdate} message PermissionsUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PermissionsUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PermissionsUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.PermissionsUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.PermissionsUpdate} PermissionsUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PermissionsUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.PermissionsUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.orderTypes && message.orderTypes.length))
                            message.orderTypes = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.orderTypes.push(reader.int32());
                        }
                        else
                            message.orderTypes.push(reader.int32());
                        break;
                    case 2:
                        if (!(message.fundingTypes && message.fundingTypes.length))
                            message.fundingTypes = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.fundingTypes.push(reader.int32());
                        }
                        else
                            message.fundingTypes.push(reader.int32());
                        break;
                    case 4:
                        if (!(message.agreements && message.agreements.length))
                            message.agreements = [];
                        message.agreements.push($root.ProtobufBroker.PermissionsUpdate.Agreement.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.leverageLevels = $root.ProtobufBroker.PermissionsUpdate.LeverageLevels.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.supportsOrderExpiry = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PermissionsUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.PermissionsUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.PermissionsUpdate} PermissionsUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PermissionsUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PermissionsUpdate message.
         * @function verify
         * @memberof ProtobufBroker.PermissionsUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PermissionsUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.orderTypes != null && message.hasOwnProperty("orderTypes")) {
                if (!Array.isArray(message.orderTypes))
                    return "orderTypes: array expected";
                for (var i = 0; i < message.orderTypes.length; ++i)
                    switch (message.orderTypes[i]) {
                        default:
                            return "orderTypes: enum value[] expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                            break;
                    }
            }
            if (message.fundingTypes != null && message.hasOwnProperty("fundingTypes")) {
                if (!Array.isArray(message.fundingTypes))
                    return "fundingTypes: array expected";
                for (var i = 0; i < message.fundingTypes.length; ++i)
                    switch (message.fundingTypes[i]) {
                        default:
                            return "fundingTypes: enum value[] expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                    }
            }
            if (message.agreements != null && message.hasOwnProperty("agreements")) {
                if (!Array.isArray(message.agreements))
                    return "agreements: array expected";
                for (var i = 0; i < message.agreements.length; ++i) {
                    var error = $root.ProtobufBroker.PermissionsUpdate.Agreement.verify(message.agreements[i]);
                    if (error)
                        return "agreements." + error;
                }
            }
            if (message.leverageLevels != null && message.hasOwnProperty("leverageLevels")) {
                var error = $root.ProtobufBroker.PermissionsUpdate.LeverageLevels.verify(message.leverageLevels);
                if (error)
                    return "leverageLevels." + error;
            }
            if (message.supportsOrderExpiry != null && message.hasOwnProperty("supportsOrderExpiry"))
                if (typeof message.supportsOrderExpiry !== "boolean")
                    return "supportsOrderExpiry: boolean expected";
            return null;
        };
        /**
         * Creates a PermissionsUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.PermissionsUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.PermissionsUpdate} PermissionsUpdate
         */
        PermissionsUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.PermissionsUpdate)
                return object;
            var message = new $root.ProtobufBroker.PermissionsUpdate();
            if (object.orderTypes) {
                if (!Array.isArray(object.orderTypes))
                    throw TypeError(".ProtobufBroker.PermissionsUpdate.orderTypes: array expected");
                message.orderTypes = [];
                for (var i = 0; i < object.orderTypes.length; ++i)
                    switch (object.orderTypes[i]) {
                        default:
                        case "Market":
                        case 0:
                            message.orderTypes[i] = 0;
                            break;
                        case "Limit":
                        case 1:
                            message.orderTypes[i] = 1;
                            break;
                        case "StopLoss":
                        case 2:
                            message.orderTypes[i] = 2;
                            break;
                        case "StopLossLimit":
                        case 3:
                            message.orderTypes[i] = 3;
                            break;
                        case "TakeProfit":
                        case 4:
                            message.orderTypes[i] = 4;
                            break;
                        case "TakeProfitLimit":
                        case 5:
                            message.orderTypes[i] = 5;
                            break;
                        case "StopLossTakeProfit":
                        case 6:
                            message.orderTypes[i] = 6;
                            break;
                        case "StopLossTakeProfitLimit":
                        case 7:
                            message.orderTypes[i] = 7;
                            break;
                        case "TrailingStopLoss":
                        case 8:
                            message.orderTypes[i] = 8;
                            break;
                        case "TrailingStopLossLimit":
                        case 9:
                            message.orderTypes[i] = 9;
                            break;
                        case "StopLossAndLimit":
                        case 10:
                            message.orderTypes[i] = 10;
                            break;
                        case "FillOrKill":
                        case 11:
                            message.orderTypes[i] = 11;
                            break;
                        case "SettlePosition":
                        case 12:
                            message.orderTypes[i] = 12;
                            break;
                    }
            }
            if (object.fundingTypes) {
                if (!Array.isArray(object.fundingTypes))
                    throw TypeError(".ProtobufBroker.PermissionsUpdate.fundingTypes: array expected");
                message.fundingTypes = [];
                for (var i = 0; i < object.fundingTypes.length; ++i)
                    switch (object.fundingTypes[i]) {
                        default:
                        case "Spot":
                        case 0:
                            message.fundingTypes[i] = 0;
                            break;
                        case "Margin":
                        case 1:
                            message.fundingTypes[i] = 1;
                            break;
                        case "Staking":
                        case 2:
                            message.fundingTypes[i] = 2;
                            break;
                    }
            }
            if (object.agreements) {
                if (!Array.isArray(object.agreements))
                    throw TypeError(".ProtobufBroker.PermissionsUpdate.agreements: array expected");
                message.agreements = [];
                for (var i = 0; i < object.agreements.length; ++i) {
                    if (typeof object.agreements[i] !== "object")
                        throw TypeError(".ProtobufBroker.PermissionsUpdate.agreements: object expected");
                    message.agreements[i] = $root.ProtobufBroker.PermissionsUpdate.Agreement.fromObject(object.agreements[i]);
                }
            }
            if (object.leverageLevels != null) {
                if (typeof object.leverageLevels !== "object")
                    throw TypeError(".ProtobufBroker.PermissionsUpdate.leverageLevels: object expected");
                message.leverageLevels = $root.ProtobufBroker.PermissionsUpdate.LeverageLevels.fromObject(object.leverageLevels);
            }
            if (object.supportsOrderExpiry != null)
                message.supportsOrderExpiry = Boolean(object.supportsOrderExpiry);
            return message;
        };
        /**
         * Creates a plain object from a PermissionsUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.PermissionsUpdate
         * @static
         * @param {ProtobufBroker.PermissionsUpdate} message PermissionsUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PermissionsUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.orderTypes = [];
                object.fundingTypes = [];
                object.agreements = [];
            }
            if (options.defaults) {
                object.leverageLevels = null;
                object.supportsOrderExpiry = false;
            }
            if (message.orderTypes && message.orderTypes.length) {
                object.orderTypes = [];
                for (var j = 0; j < message.orderTypes.length; ++j)
                    object.orderTypes[j] = options.enums === String ? $root.ProtobufBroker.PrivateOrder.Type[message.orderTypes[j]] : message.orderTypes[j];
            }
            if (message.fundingTypes && message.fundingTypes.length) {
                object.fundingTypes = [];
                for (var j = 0; j < message.fundingTypes.length; ++j)
                    object.fundingTypes[j] = options.enums === String ? $root.ProtobufBroker.FundingType[message.fundingTypes[j]] : message.fundingTypes[j];
            }
            if (message.agreements && message.agreements.length) {
                object.agreements = [];
                for (var j = 0; j < message.agreements.length; ++j)
                    object.agreements[j] = $root.ProtobufBroker.PermissionsUpdate.Agreement.toObject(message.agreements[j], options);
            }
            if (message.leverageLevels != null && message.hasOwnProperty("leverageLevels"))
                object.leverageLevels = $root.ProtobufBroker.PermissionsUpdate.LeverageLevels.toObject(message.leverageLevels, options);
            if (message.supportsOrderExpiry != null && message.hasOwnProperty("supportsOrderExpiry"))
                object.supportsOrderExpiry = message.supportsOrderExpiry;
            return object;
        };
        /**
         * Converts this PermissionsUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.PermissionsUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PermissionsUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        PermissionsUpdate.Agreement = (function () {
            /**
             * Properties of an Agreement.
             * @memberof ProtobufBroker.PermissionsUpdate
             * @interface IAgreement
             * @property {string|null} [key] Agreement key
             * @property {string|null} [body] Agreement body
             */
            /**
             * Constructs a new Agreement.
             * @memberof ProtobufBroker.PermissionsUpdate
             * @classdesc Represents an Agreement.
             * @implements IAgreement
             * @constructor
             * @param {ProtobufBroker.PermissionsUpdate.IAgreement=} [properties] Properties to set
             */
            function Agreement(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Agreement key.
             * @member {string} key
             * @memberof ProtobufBroker.PermissionsUpdate.Agreement
             * @instance
             */
            Agreement.prototype.key = "";
            /**
             * Agreement body.
             * @member {string} body
             * @memberof ProtobufBroker.PermissionsUpdate.Agreement
             * @instance
             */
            Agreement.prototype.body = "";
            /**
             * Creates a new Agreement instance using the specified properties.
             * @function create
             * @memberof ProtobufBroker.PermissionsUpdate.Agreement
             * @static
             * @param {ProtobufBroker.PermissionsUpdate.IAgreement=} [properties] Properties to set
             * @returns {ProtobufBroker.PermissionsUpdate.Agreement} Agreement instance
             */
            Agreement.create = function create(properties) {
                return new Agreement(properties);
            };
            /**
             * Encodes the specified Agreement message. Does not implicitly {@link ProtobufBroker.PermissionsUpdate.Agreement.verify|verify} messages.
             * @function encode
             * @memberof ProtobufBroker.PermissionsUpdate.Agreement
             * @static
             * @param {ProtobufBroker.PermissionsUpdate.IAgreement} message Agreement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Agreement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.key);
                if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                    writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.body);
                return writer;
            };
            /**
             * Encodes the specified Agreement message, length delimited. Does not implicitly {@link ProtobufBroker.PermissionsUpdate.Agreement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ProtobufBroker.PermissionsUpdate.Agreement
             * @static
             * @param {ProtobufBroker.PermissionsUpdate.IAgreement} message Agreement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Agreement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an Agreement message from the specified reader or buffer.
             * @function decode
             * @memberof ProtobufBroker.PermissionsUpdate.Agreement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ProtobufBroker.PermissionsUpdate.Agreement} Agreement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Agreement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.PermissionsUpdate.Agreement();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.key = reader.string();
                            break;
                        case 2:
                            message.body = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes an Agreement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ProtobufBroker.PermissionsUpdate.Agreement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ProtobufBroker.PermissionsUpdate.Agreement} Agreement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Agreement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an Agreement message.
             * @function verify
             * @memberof ProtobufBroker.PermissionsUpdate.Agreement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Agreement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.body != null && message.hasOwnProperty("body"))
                    if (!$util.isString(message.body))
                        return "body: string expected";
                return null;
            };
            /**
             * Creates an Agreement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ProtobufBroker.PermissionsUpdate.Agreement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ProtobufBroker.PermissionsUpdate.Agreement} Agreement
             */
            Agreement.fromObject = function fromObject(object) {
                if (object instanceof $root.ProtobufBroker.PermissionsUpdate.Agreement)
                    return object;
                var message = new $root.ProtobufBroker.PermissionsUpdate.Agreement();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.body != null)
                    message.body = String(object.body);
                return message;
            };
            /**
             * Creates a plain object from an Agreement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ProtobufBroker.PermissionsUpdate.Agreement
             * @static
             * @param {ProtobufBroker.PermissionsUpdate.Agreement} message Agreement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Agreement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.body = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.body != null && message.hasOwnProperty("body"))
                    object.body = message.body;
                return object;
            };
            /**
             * Converts this Agreement to JSON.
             * @function toJSON
             * @memberof ProtobufBroker.PermissionsUpdate.Agreement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Agreement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Agreement;
        })();
        PermissionsUpdate.LeverageLevels = (function () {
            /**
             * Properties of a LeverageLevels.
             * @memberof ProtobufBroker.PermissionsUpdate
             * @interface ILeverageLevels
             * @property {Array.<string>|null} [buy] LeverageLevels buy
             * @property {Array.<string>|null} [sell] LeverageLevels sell
             */
            /**
             * Constructs a new LeverageLevels.
             * @memberof ProtobufBroker.PermissionsUpdate
             * @classdesc Represents a LeverageLevels.
             * @implements ILeverageLevels
             * @constructor
             * @param {ProtobufBroker.PermissionsUpdate.ILeverageLevels=} [properties] Properties to set
             */
            function LeverageLevels(properties) {
                this.buy = [];
                this.sell = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * LeverageLevels buy.
             * @member {Array.<string>} buy
             * @memberof ProtobufBroker.PermissionsUpdate.LeverageLevels
             * @instance
             */
            LeverageLevels.prototype.buy = $util.emptyArray;
            /**
             * LeverageLevels sell.
             * @member {Array.<string>} sell
             * @memberof ProtobufBroker.PermissionsUpdate.LeverageLevels
             * @instance
             */
            LeverageLevels.prototype.sell = $util.emptyArray;
            /**
             * Creates a new LeverageLevels instance using the specified properties.
             * @function create
             * @memberof ProtobufBroker.PermissionsUpdate.LeverageLevels
             * @static
             * @param {ProtobufBroker.PermissionsUpdate.ILeverageLevels=} [properties] Properties to set
             * @returns {ProtobufBroker.PermissionsUpdate.LeverageLevels} LeverageLevels instance
             */
            LeverageLevels.create = function create(properties) {
                return new LeverageLevels(properties);
            };
            /**
             * Encodes the specified LeverageLevels message. Does not implicitly {@link ProtobufBroker.PermissionsUpdate.LeverageLevels.verify|verify} messages.
             * @function encode
             * @memberof ProtobufBroker.PermissionsUpdate.LeverageLevels
             * @static
             * @param {ProtobufBroker.PermissionsUpdate.ILeverageLevels} message LeverageLevels message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeverageLevels.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.buy != null && message.buy.length)
                    for (var i = 0; i < message.buy.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.buy[i]);
                if (message.sell != null && message.sell.length)
                    for (var i = 0; i < message.sell.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.sell[i]);
                return writer;
            };
            /**
             * Encodes the specified LeverageLevels message, length delimited. Does not implicitly {@link ProtobufBroker.PermissionsUpdate.LeverageLevels.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ProtobufBroker.PermissionsUpdate.LeverageLevels
             * @static
             * @param {ProtobufBroker.PermissionsUpdate.ILeverageLevels} message LeverageLevels message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeverageLevels.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a LeverageLevels message from the specified reader or buffer.
             * @function decode
             * @memberof ProtobufBroker.PermissionsUpdate.LeverageLevels
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ProtobufBroker.PermissionsUpdate.LeverageLevels} LeverageLevels
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeverageLevels.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.PermissionsUpdate.LeverageLevels();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.buy && message.buy.length))
                                message.buy = [];
                            message.buy.push(reader.string());
                            break;
                        case 2:
                            if (!(message.sell && message.sell.length))
                                message.sell = [];
                            message.sell.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a LeverageLevels message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ProtobufBroker.PermissionsUpdate.LeverageLevels
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ProtobufBroker.PermissionsUpdate.LeverageLevels} LeverageLevels
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeverageLevels.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a LeverageLevels message.
             * @function verify
             * @memberof ProtobufBroker.PermissionsUpdate.LeverageLevels
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LeverageLevels.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.buy != null && message.hasOwnProperty("buy")) {
                    if (!Array.isArray(message.buy))
                        return "buy: array expected";
                    for (var i = 0; i < message.buy.length; ++i)
                        if (!$util.isString(message.buy[i]))
                            return "buy: string[] expected";
                }
                if (message.sell != null && message.hasOwnProperty("sell")) {
                    if (!Array.isArray(message.sell))
                        return "sell: array expected";
                    for (var i = 0; i < message.sell.length; ++i)
                        if (!$util.isString(message.sell[i]))
                            return "sell: string[] expected";
                }
                return null;
            };
            /**
             * Creates a LeverageLevels message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ProtobufBroker.PermissionsUpdate.LeverageLevels
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ProtobufBroker.PermissionsUpdate.LeverageLevels} LeverageLevels
             */
            LeverageLevels.fromObject = function fromObject(object) {
                if (object instanceof $root.ProtobufBroker.PermissionsUpdate.LeverageLevels)
                    return object;
                var message = new $root.ProtobufBroker.PermissionsUpdate.LeverageLevels();
                if (object.buy) {
                    if (!Array.isArray(object.buy))
                        throw TypeError(".ProtobufBroker.PermissionsUpdate.LeverageLevels.buy: array expected");
                    message.buy = [];
                    for (var i = 0; i < object.buy.length; ++i)
                        message.buy[i] = String(object.buy[i]);
                }
                if (object.sell) {
                    if (!Array.isArray(object.sell))
                        throw TypeError(".ProtobufBroker.PermissionsUpdate.LeverageLevels.sell: array expected");
                    message.sell = [];
                    for (var i = 0; i < object.sell.length; ++i)
                        message.sell[i] = String(object.sell[i]);
                }
                return message;
            };
            /**
             * Creates a plain object from a LeverageLevels message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ProtobufBroker.PermissionsUpdate.LeverageLevels
             * @static
             * @param {ProtobufBroker.PermissionsUpdate.LeverageLevels} message LeverageLevels
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LeverageLevels.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.buy = [];
                    object.sell = [];
                }
                if (message.buy && message.buy.length) {
                    object.buy = [];
                    for (var j = 0; j < message.buy.length; ++j)
                        object.buy[j] = message.buy[j];
                }
                if (message.sell && message.sell.length) {
                    object.sell = [];
                    for (var j = 0; j < message.sell.length; ++j)
                        object.sell[j] = message.sell[j];
                }
                return object;
            };
            /**
             * Converts this LeverageLevels to JSON.
             * @function toJSON
             * @memberof ProtobufBroker.PermissionsUpdate.LeverageLevels
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LeverageLevels.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return LeverageLevels;
        })();
        return PermissionsUpdate;
    })();
    ProtobufBroker.APIAccessorStatusUpdate = (function () {
        /**
         * Properties of a APIAccessorStatusUpdate.
         * @memberof ProtobufBroker
         * @interface IAPIAccessorStatusUpdate
         * @property {boolean|null} [hasAccess] APIAccessorStatusUpdate hasAccess
         * @property {number|null} [status] APIAccessorStatusUpdate status
         * @property {string|null} [statusString] APIAccessorStatusUpdate statusString
         */
        /**
         * Constructs a new APIAccessorStatusUpdate.
         * @memberof ProtobufBroker
         * @classdesc Represents a APIAccessorStatusUpdate.
         * @implements IAPIAccessorStatusUpdate
         * @constructor
         * @param {ProtobufBroker.IAPIAccessorStatusUpdate=} [properties] Properties to set
         */
        function APIAccessorStatusUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * APIAccessorStatusUpdate hasAccess.
         * @member {boolean} hasAccess
         * @memberof ProtobufBroker.APIAccessorStatusUpdate
         * @instance
         */
        APIAccessorStatusUpdate.prototype.hasAccess = false;
        /**
         * APIAccessorStatusUpdate status.
         * @member {number} status
         * @memberof ProtobufBroker.APIAccessorStatusUpdate
         * @instance
         */
        APIAccessorStatusUpdate.prototype.status = 0;
        /**
         * APIAccessorStatusUpdate statusString.
         * @member {string} statusString
         * @memberof ProtobufBroker.APIAccessorStatusUpdate
         * @instance
         */
        APIAccessorStatusUpdate.prototype.statusString = "";
        /**
         * Creates a new APIAccessorStatusUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.APIAccessorStatusUpdate
         * @static
         * @param {ProtobufBroker.IAPIAccessorStatusUpdate=} [properties] Properties to set
         * @returns {ProtobufBroker.APIAccessorStatusUpdate} APIAccessorStatusUpdate instance
         */
        APIAccessorStatusUpdate.create = function create(properties) {
            return new APIAccessorStatusUpdate(properties);
        };
        /**
         * Encodes the specified APIAccessorStatusUpdate message. Does not implicitly {@link ProtobufBroker.APIAccessorStatusUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.APIAccessorStatusUpdate
         * @static
         * @param {ProtobufBroker.IAPIAccessorStatusUpdate} message APIAccessorStatusUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        APIAccessorStatusUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hasAccess != null && Object.hasOwnProperty.call(message, "hasAccess"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.hasAccess);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.status);
            if (message.statusString != null && Object.hasOwnProperty.call(message, "statusString"))
                writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.statusString);
            return writer;
        };
        /**
         * Encodes the specified APIAccessorStatusUpdate message, length delimited. Does not implicitly {@link ProtobufBroker.APIAccessorStatusUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.APIAccessorStatusUpdate
         * @static
         * @param {ProtobufBroker.IAPIAccessorStatusUpdate} message APIAccessorStatusUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        APIAccessorStatusUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a APIAccessorStatusUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.APIAccessorStatusUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.APIAccessorStatusUpdate} APIAccessorStatusUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        APIAccessorStatusUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.APIAccessorStatusUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.hasAccess = reader.bool();
                        break;
                    case 2:
                        message.status = reader.int32();
                        break;
                    case 3:
                        message.statusString = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a APIAccessorStatusUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.APIAccessorStatusUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.APIAccessorStatusUpdate} APIAccessorStatusUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        APIAccessorStatusUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a APIAccessorStatusUpdate message.
         * @function verify
         * @memberof ProtobufBroker.APIAccessorStatusUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        APIAccessorStatusUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hasAccess != null && message.hasOwnProperty("hasAccess"))
                if (typeof message.hasAccess !== "boolean")
                    return "hasAccess: boolean expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
            if (message.statusString != null && message.hasOwnProperty("statusString"))
                if (!$util.isString(message.statusString))
                    return "statusString: string expected";
            return null;
        };
        /**
         * Creates a APIAccessorStatusUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.APIAccessorStatusUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.APIAccessorStatusUpdate} APIAccessorStatusUpdate
         */
        APIAccessorStatusUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.APIAccessorStatusUpdate)
                return object;
            var message = new $root.ProtobufBroker.APIAccessorStatusUpdate();
            if (object.hasAccess != null)
                message.hasAccess = Boolean(object.hasAccess);
            if (object.status != null)
                message.status = object.status | 0;
            if (object.statusString != null)
                message.statusString = String(object.statusString);
            return message;
        };
        /**
         * Creates a plain object from a APIAccessorStatusUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.APIAccessorStatusUpdate
         * @static
         * @param {ProtobufBroker.APIAccessorStatusUpdate} message APIAccessorStatusUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        APIAccessorStatusUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.hasAccess = false;
                object.status = 0;
                object.statusString = "";
            }
            if (message.hasAccess != null && message.hasOwnProperty("hasAccess"))
                object.hasAccess = message.hasAccess;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.statusString != null && message.hasOwnProperty("statusString"))
                object.statusString = message.statusString;
            return object;
        };
        /**
         * Converts this APIAccessorStatusUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.APIAccessorStatusUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        APIAccessorStatusUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return APIAccessorStatusUpdate;
    })();
    ProtobufBroker.BrokerUpdateMessage = (function () {
        /**
         * Properties of a BrokerUpdateMessage.
         * @memberof ProtobufBroker
         * @interface IBrokerUpdateMessage
         * @property {number|Long|null} [marketId] BrokerUpdateMessage marketId
         * @property {ProtobufBroker.IOrdersUpdate|null} [ordersUpdate] BrokerUpdateMessage ordersUpdate
         * @property {ProtobufBroker.ITradesUpdate|null} [tradesUpdate] BrokerUpdateMessage tradesUpdate
         * @property {ProtobufBroker.IBalancesUpdate|null} [balancesUpdate] BrokerUpdateMessage balancesUpdate
         * @property {ProtobufBroker.IPositionsUpdate|null} [positionsUpdate] BrokerUpdateMessage positionsUpdate
         * @property {ProtobufBroker.ILedgersUpdate|null} [ledgersUpdate] BrokerUpdateMessage ledgersUpdate
         * @property {ProtobufBroker.IRequestResolutionUpdate|null} [requestResolutionUpdate] BrokerUpdateMessage requestResolutionUpdate
         * @property {ProtobufBroker.IAnonymousSessionStatusUpdate|null} [anonymousSessionStatusUpdate] BrokerUpdateMessage anonymousSessionStatusUpdate
         * @property {ProtobufBroker.IPermissionsUpdate|null} [permissionsUpdate] BrokerUpdateMessage permissionsUpdate
         * @property {ProtobufBroker.ISessionStatusUpdate|null} [sessionStatusUpdate] BrokerUpdateMessage sessionStatusUpdate
         * @property {ProtobufBroker.IAPIAccessorStatusUpdate|null} [apiAccessorStatusUpdate] BrokerUpdateMessage apiAccessorStatusUpdate
         * @property {ProtobufStream.IAuthenticationResult|null} [authenticationResult] BrokerUpdateMessage authenticationResult
         * @property {ProtobufStream.ISubscriptionResult|null} [subscriptionResult] BrokerUpdateMessage subscriptionResult
         * @property {ProtobufClient.IWebAuthenticationResult|null} [webAuthenticationResult] BrokerUpdateMessage webAuthenticationResult
         */
        /**
         * Constructs a new BrokerUpdateMessage.
         * @memberof ProtobufBroker
         * @classdesc Represents a BrokerUpdateMessage.
         * @implements IBrokerUpdateMessage
         * @constructor
         * @param {ProtobufBroker.IBrokerUpdateMessage=} [properties] Properties to set
         */
        function BrokerUpdateMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * BrokerUpdateMessage marketId.
         * @member {number|Long} marketId
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @instance
         */
        BrokerUpdateMessage.prototype.marketId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * BrokerUpdateMessage ordersUpdate.
         * @member {ProtobufBroker.IOrdersUpdate|null|undefined} ordersUpdate
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @instance
         */
        BrokerUpdateMessage.prototype.ordersUpdate = null;
        /**
         * BrokerUpdateMessage tradesUpdate.
         * @member {ProtobufBroker.ITradesUpdate|null|undefined} tradesUpdate
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @instance
         */
        BrokerUpdateMessage.prototype.tradesUpdate = null;
        /**
         * BrokerUpdateMessage balancesUpdate.
         * @member {ProtobufBroker.IBalancesUpdate|null|undefined} balancesUpdate
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @instance
         */
        BrokerUpdateMessage.prototype.balancesUpdate = null;
        /**
         * BrokerUpdateMessage positionsUpdate.
         * @member {ProtobufBroker.IPositionsUpdate|null|undefined} positionsUpdate
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @instance
         */
        BrokerUpdateMessage.prototype.positionsUpdate = null;
        /**
         * BrokerUpdateMessage ledgersUpdate.
         * @member {ProtobufBroker.ILedgersUpdate|null|undefined} ledgersUpdate
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @instance
         */
        BrokerUpdateMessage.prototype.ledgersUpdate = null;
        /**
         * BrokerUpdateMessage requestResolutionUpdate.
         * @member {ProtobufBroker.IRequestResolutionUpdate|null|undefined} requestResolutionUpdate
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @instance
         */
        BrokerUpdateMessage.prototype.requestResolutionUpdate = null;
        /**
         * BrokerUpdateMessage anonymousSessionStatusUpdate.
         * @member {ProtobufBroker.IAnonymousSessionStatusUpdate|null|undefined} anonymousSessionStatusUpdate
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @instance
         */
        BrokerUpdateMessage.prototype.anonymousSessionStatusUpdate = null;
        /**
         * BrokerUpdateMessage permissionsUpdate.
         * @member {ProtobufBroker.IPermissionsUpdate|null|undefined} permissionsUpdate
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @instance
         */
        BrokerUpdateMessage.prototype.permissionsUpdate = null;
        /**
         * BrokerUpdateMessage sessionStatusUpdate.
         * @member {ProtobufBroker.ISessionStatusUpdate|null|undefined} sessionStatusUpdate
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @instance
         */
        BrokerUpdateMessage.prototype.sessionStatusUpdate = null;
        /**
         * BrokerUpdateMessage apiAccessorStatusUpdate.
         * @member {ProtobufBroker.IAPIAccessorStatusUpdate|null|undefined} apiAccessorStatusUpdate
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @instance
         */
        BrokerUpdateMessage.prototype.apiAccessorStatusUpdate = null;
        /**
         * BrokerUpdateMessage authenticationResult.
         * @member {ProtobufStream.IAuthenticationResult|null|undefined} authenticationResult
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @instance
         */
        BrokerUpdateMessage.prototype.authenticationResult = null;
        /**
         * BrokerUpdateMessage subscriptionResult.
         * @member {ProtobufStream.ISubscriptionResult|null|undefined} subscriptionResult
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @instance
         */
        BrokerUpdateMessage.prototype.subscriptionResult = null;
        /**
         * BrokerUpdateMessage webAuthenticationResult.
         * @member {ProtobufClient.IWebAuthenticationResult|null|undefined} webAuthenticationResult
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @instance
         */
        BrokerUpdateMessage.prototype.webAuthenticationResult = null;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * BrokerUpdateMessage Update.
         * @member {"ordersUpdate"|"tradesUpdate"|"balancesUpdate"|"positionsUpdate"|"ledgersUpdate"|"requestResolutionUpdate"|"anonymousSessionStatusUpdate"|"permissionsUpdate"|"sessionStatusUpdate"|"apiAccessorStatusUpdate"|"authenticationResult"|"subscriptionResult"|"webAuthenticationResult"|undefined} Update
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @instance
         */
        Object.defineProperty(BrokerUpdateMessage.prototype, "Update", {
            get: $util.oneOfGetter($oneOfFields = ["ordersUpdate", "tradesUpdate", "balancesUpdate", "positionsUpdate", "ledgersUpdate", "requestResolutionUpdate", "anonymousSessionStatusUpdate", "permissionsUpdate", "sessionStatusUpdate", "apiAccessorStatusUpdate", "authenticationResult", "subscriptionResult", "webAuthenticationResult"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new BrokerUpdateMessage instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @static
         * @param {ProtobufBroker.IBrokerUpdateMessage=} [properties] Properties to set
         * @returns {ProtobufBroker.BrokerUpdateMessage} BrokerUpdateMessage instance
         */
        BrokerUpdateMessage.create = function create(properties) {
            return new BrokerUpdateMessage(properties);
        };
        /**
         * Encodes the specified BrokerUpdateMessage message. Does not implicitly {@link ProtobufBroker.BrokerUpdateMessage.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @static
         * @param {ProtobufBroker.IBrokerUpdateMessage} message BrokerUpdateMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BrokerUpdateMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ordersUpdate != null && Object.hasOwnProperty.call(message, "ordersUpdate"))
                $root.ProtobufBroker.OrdersUpdate.encode(message.ordersUpdate, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.tradesUpdate != null && Object.hasOwnProperty.call(message, "tradesUpdate"))
                $root.ProtobufBroker.TradesUpdate.encode(message.tradesUpdate, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.balancesUpdate != null && Object.hasOwnProperty.call(message, "balancesUpdate"))
                $root.ProtobufBroker.BalancesUpdate.encode(message.balancesUpdate, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.requestResolutionUpdate != null && Object.hasOwnProperty.call(message, "requestResolutionUpdate"))
                $root.ProtobufBroker.RequestResolutionUpdate.encode(message.requestResolutionUpdate, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            if (message.anonymousSessionStatusUpdate != null && Object.hasOwnProperty.call(message, "anonymousSessionStatusUpdate"))
                $root.ProtobufBroker.AnonymousSessionStatusUpdate.encode(message.anonymousSessionStatusUpdate, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
            if (message.permissionsUpdate != null && Object.hasOwnProperty.call(message, "permissionsUpdate"))
                $root.ProtobufBroker.PermissionsUpdate.encode(message.permissionsUpdate, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
            if (message.sessionStatusUpdate != null && Object.hasOwnProperty.call(message, "sessionStatusUpdate"))
                $root.ProtobufBroker.SessionStatusUpdate.encode(message.sessionStatusUpdate, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
            if (message.positionsUpdate != null && Object.hasOwnProperty.call(message, "positionsUpdate"))
                $root.ProtobufBroker.PositionsUpdate.encode(message.positionsUpdate, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
            if (message.apiAccessorStatusUpdate != null && Object.hasOwnProperty.call(message, "apiAccessorStatusUpdate"))
                $root.ProtobufBroker.APIAccessorStatusUpdate.encode(message.apiAccessorStatusUpdate, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
            if (message.authenticationResult != null && Object.hasOwnProperty.call(message, "authenticationResult"))
                $root.ProtobufStream.AuthenticationResult.encode(message.authenticationResult, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
            if (message.marketId != null && Object.hasOwnProperty.call(message, "marketId"))
                writer.uint32(/* id 11, wireType 0 =*/ 88).int64(message.marketId);
            if (message.subscriptionResult != null && Object.hasOwnProperty.call(message, "subscriptionResult"))
                $root.ProtobufStream.SubscriptionResult.encode(message.subscriptionResult, writer.uint32(/* id 12, wireType 2 =*/ 98).fork()).ldelim();
            if (message.webAuthenticationResult != null && Object.hasOwnProperty.call(message, "webAuthenticationResult"))
                $root.ProtobufClient.WebAuthenticationResult.encode(message.webAuthenticationResult, writer.uint32(/* id 14, wireType 2 =*/ 114).fork()).ldelim();
            if (message.ledgersUpdate != null && Object.hasOwnProperty.call(message, "ledgersUpdate"))
                $root.ProtobufBroker.LedgersUpdate.encode(message.ledgersUpdate, writer.uint32(/* id 15, wireType 2 =*/ 122).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified BrokerUpdateMessage message, length delimited. Does not implicitly {@link ProtobufBroker.BrokerUpdateMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @static
         * @param {ProtobufBroker.IBrokerUpdateMessage} message BrokerUpdateMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BrokerUpdateMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a BrokerUpdateMessage message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.BrokerUpdateMessage} BrokerUpdateMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BrokerUpdateMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.BrokerUpdateMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 11:
                        message.marketId = reader.int64();
                        break;
                    case 1:
                        message.ordersUpdate = $root.ProtobufBroker.OrdersUpdate.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.tradesUpdate = $root.ProtobufBroker.TradesUpdate.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.balancesUpdate = $root.ProtobufBroker.BalancesUpdate.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.positionsUpdate = $root.ProtobufBroker.PositionsUpdate.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.ledgersUpdate = $root.ProtobufBroker.LedgersUpdate.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.requestResolutionUpdate = $root.ProtobufBroker.RequestResolutionUpdate.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.anonymousSessionStatusUpdate = $root.ProtobufBroker.AnonymousSessionStatusUpdate.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.permissionsUpdate = $root.ProtobufBroker.PermissionsUpdate.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.sessionStatusUpdate = $root.ProtobufBroker.SessionStatusUpdate.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.apiAccessorStatusUpdate = $root.ProtobufBroker.APIAccessorStatusUpdate.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.authenticationResult = $root.ProtobufStream.AuthenticationResult.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.subscriptionResult = $root.ProtobufStream.SubscriptionResult.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.webAuthenticationResult = $root.ProtobufClient.WebAuthenticationResult.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a BrokerUpdateMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.BrokerUpdateMessage} BrokerUpdateMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BrokerUpdateMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a BrokerUpdateMessage message.
         * @function verify
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BrokerUpdateMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.marketId != null && message.hasOwnProperty("marketId"))
                if (!$util.isInteger(message.marketId) && !(message.marketId && $util.isInteger(message.marketId.low) && $util.isInteger(message.marketId.high)))
                    return "marketId: integer|Long expected";
            if (message.ordersUpdate != null && message.hasOwnProperty("ordersUpdate")) {
                properties.Update = 1;
                {
                    var error = $root.ProtobufBroker.OrdersUpdate.verify(message.ordersUpdate);
                    if (error)
                        return "ordersUpdate." + error;
                }
            }
            if (message.tradesUpdate != null && message.hasOwnProperty("tradesUpdate")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufBroker.TradesUpdate.verify(message.tradesUpdate);
                    if (error)
                        return "tradesUpdate." + error;
                }
            }
            if (message.balancesUpdate != null && message.hasOwnProperty("balancesUpdate")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufBroker.BalancesUpdate.verify(message.balancesUpdate);
                    if (error)
                        return "balancesUpdate." + error;
                }
            }
            if (message.positionsUpdate != null && message.hasOwnProperty("positionsUpdate")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufBroker.PositionsUpdate.verify(message.positionsUpdate);
                    if (error)
                        return "positionsUpdate." + error;
                }
            }
            if (message.ledgersUpdate != null && message.hasOwnProperty("ledgersUpdate")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufBroker.LedgersUpdate.verify(message.ledgersUpdate);
                    if (error)
                        return "ledgersUpdate." + error;
                }
            }
            if (message.requestResolutionUpdate != null && message.hasOwnProperty("requestResolutionUpdate")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufBroker.RequestResolutionUpdate.verify(message.requestResolutionUpdate);
                    if (error)
                        return "requestResolutionUpdate." + error;
                }
            }
            if (message.anonymousSessionStatusUpdate != null && message.hasOwnProperty("anonymousSessionStatusUpdate")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufBroker.AnonymousSessionStatusUpdate.verify(message.anonymousSessionStatusUpdate);
                    if (error)
                        return "anonymousSessionStatusUpdate." + error;
                }
            }
            if (message.permissionsUpdate != null && message.hasOwnProperty("permissionsUpdate")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufBroker.PermissionsUpdate.verify(message.permissionsUpdate);
                    if (error)
                        return "permissionsUpdate." + error;
                }
            }
            if (message.sessionStatusUpdate != null && message.hasOwnProperty("sessionStatusUpdate")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufBroker.SessionStatusUpdate.verify(message.sessionStatusUpdate);
                    if (error)
                        return "sessionStatusUpdate." + error;
                }
            }
            if (message.apiAccessorStatusUpdate != null && message.hasOwnProperty("apiAccessorStatusUpdate")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufBroker.APIAccessorStatusUpdate.verify(message.apiAccessorStatusUpdate);
                    if (error)
                        return "apiAccessorStatusUpdate." + error;
                }
            }
            if (message.authenticationResult != null && message.hasOwnProperty("authenticationResult")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufStream.AuthenticationResult.verify(message.authenticationResult);
                    if (error)
                        return "authenticationResult." + error;
                }
            }
            if (message.subscriptionResult != null && message.hasOwnProperty("subscriptionResult")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufStream.SubscriptionResult.verify(message.subscriptionResult);
                    if (error)
                        return "subscriptionResult." + error;
                }
            }
            if (message.webAuthenticationResult != null && message.hasOwnProperty("webAuthenticationResult")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufClient.WebAuthenticationResult.verify(message.webAuthenticationResult);
                    if (error)
                        return "webAuthenticationResult." + error;
                }
            }
            return null;
        };
        /**
         * Creates a BrokerUpdateMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.BrokerUpdateMessage} BrokerUpdateMessage
         */
        BrokerUpdateMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.BrokerUpdateMessage)
                return object;
            var message = new $root.ProtobufBroker.BrokerUpdateMessage();
            if (object.marketId != null)
                if ($util.Long)
                    (message.marketId = $util.Long.fromValue(object.marketId)).unsigned = false;
                else if (typeof object.marketId === "string")
                    message.marketId = parseInt(object.marketId, 10);
                else if (typeof object.marketId === "number")
                    message.marketId = object.marketId;
                else if (typeof object.marketId === "object")
                    message.marketId = new $util.LongBits(object.marketId.low >>> 0, object.marketId.high >>> 0).toNumber();
            if (object.ordersUpdate != null) {
                if (typeof object.ordersUpdate !== "object")
                    throw TypeError(".ProtobufBroker.BrokerUpdateMessage.ordersUpdate: object expected");
                message.ordersUpdate = $root.ProtobufBroker.OrdersUpdate.fromObject(object.ordersUpdate);
            }
            if (object.tradesUpdate != null) {
                if (typeof object.tradesUpdate !== "object")
                    throw TypeError(".ProtobufBroker.BrokerUpdateMessage.tradesUpdate: object expected");
                message.tradesUpdate = $root.ProtobufBroker.TradesUpdate.fromObject(object.tradesUpdate);
            }
            if (object.balancesUpdate != null) {
                if (typeof object.balancesUpdate !== "object")
                    throw TypeError(".ProtobufBroker.BrokerUpdateMessage.balancesUpdate: object expected");
                message.balancesUpdate = $root.ProtobufBroker.BalancesUpdate.fromObject(object.balancesUpdate);
            }
            if (object.positionsUpdate != null) {
                if (typeof object.positionsUpdate !== "object")
                    throw TypeError(".ProtobufBroker.BrokerUpdateMessage.positionsUpdate: object expected");
                message.positionsUpdate = $root.ProtobufBroker.PositionsUpdate.fromObject(object.positionsUpdate);
            }
            if (object.ledgersUpdate != null) {
                if (typeof object.ledgersUpdate !== "object")
                    throw TypeError(".ProtobufBroker.BrokerUpdateMessage.ledgersUpdate: object expected");
                message.ledgersUpdate = $root.ProtobufBroker.LedgersUpdate.fromObject(object.ledgersUpdate);
            }
            if (object.requestResolutionUpdate != null) {
                if (typeof object.requestResolutionUpdate !== "object")
                    throw TypeError(".ProtobufBroker.BrokerUpdateMessage.requestResolutionUpdate: object expected");
                message.requestResolutionUpdate = $root.ProtobufBroker.RequestResolutionUpdate.fromObject(object.requestResolutionUpdate);
            }
            if (object.anonymousSessionStatusUpdate != null) {
                if (typeof object.anonymousSessionStatusUpdate !== "object")
                    throw TypeError(".ProtobufBroker.BrokerUpdateMessage.anonymousSessionStatusUpdate: object expected");
                message.anonymousSessionStatusUpdate = $root.ProtobufBroker.AnonymousSessionStatusUpdate.fromObject(object.anonymousSessionStatusUpdate);
            }
            if (object.permissionsUpdate != null) {
                if (typeof object.permissionsUpdate !== "object")
                    throw TypeError(".ProtobufBroker.BrokerUpdateMessage.permissionsUpdate: object expected");
                message.permissionsUpdate = $root.ProtobufBroker.PermissionsUpdate.fromObject(object.permissionsUpdate);
            }
            if (object.sessionStatusUpdate != null) {
                if (typeof object.sessionStatusUpdate !== "object")
                    throw TypeError(".ProtobufBroker.BrokerUpdateMessage.sessionStatusUpdate: object expected");
                message.sessionStatusUpdate = $root.ProtobufBroker.SessionStatusUpdate.fromObject(object.sessionStatusUpdate);
            }
            if (object.apiAccessorStatusUpdate != null) {
                if (typeof object.apiAccessorStatusUpdate !== "object")
                    throw TypeError(".ProtobufBroker.BrokerUpdateMessage.apiAccessorStatusUpdate: object expected");
                message.apiAccessorStatusUpdate = $root.ProtobufBroker.APIAccessorStatusUpdate.fromObject(object.apiAccessorStatusUpdate);
            }
            if (object.authenticationResult != null) {
                if (typeof object.authenticationResult !== "object")
                    throw TypeError(".ProtobufBroker.BrokerUpdateMessage.authenticationResult: object expected");
                message.authenticationResult = $root.ProtobufStream.AuthenticationResult.fromObject(object.authenticationResult);
            }
            if (object.subscriptionResult != null) {
                if (typeof object.subscriptionResult !== "object")
                    throw TypeError(".ProtobufBroker.BrokerUpdateMessage.subscriptionResult: object expected");
                message.subscriptionResult = $root.ProtobufStream.SubscriptionResult.fromObject(object.subscriptionResult);
            }
            if (object.webAuthenticationResult != null) {
                if (typeof object.webAuthenticationResult !== "object")
                    throw TypeError(".ProtobufBroker.BrokerUpdateMessage.webAuthenticationResult: object expected");
                message.webAuthenticationResult = $root.ProtobufClient.WebAuthenticationResult.fromObject(object.webAuthenticationResult);
            }
            return message;
        };
        /**
         * Creates a plain object from a BrokerUpdateMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @static
         * @param {ProtobufBroker.BrokerUpdateMessage} message BrokerUpdateMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BrokerUpdateMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.marketId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.marketId = options.longs === String ? "0" : 0;
            if (message.ordersUpdate != null && message.hasOwnProperty("ordersUpdate")) {
                object.ordersUpdate = $root.ProtobufBroker.OrdersUpdate.toObject(message.ordersUpdate, options);
                if (options.oneofs)
                    object.Update = "ordersUpdate";
            }
            if (message.tradesUpdate != null && message.hasOwnProperty("tradesUpdate")) {
                object.tradesUpdate = $root.ProtobufBroker.TradesUpdate.toObject(message.tradesUpdate, options);
                if (options.oneofs)
                    object.Update = "tradesUpdate";
            }
            if (message.balancesUpdate != null && message.hasOwnProperty("balancesUpdate")) {
                object.balancesUpdate = $root.ProtobufBroker.BalancesUpdate.toObject(message.balancesUpdate, options);
                if (options.oneofs)
                    object.Update = "balancesUpdate";
            }
            if (message.requestResolutionUpdate != null && message.hasOwnProperty("requestResolutionUpdate")) {
                object.requestResolutionUpdate = $root.ProtobufBroker.RequestResolutionUpdate.toObject(message.requestResolutionUpdate, options);
                if (options.oneofs)
                    object.Update = "requestResolutionUpdate";
            }
            if (message.anonymousSessionStatusUpdate != null && message.hasOwnProperty("anonymousSessionStatusUpdate")) {
                object.anonymousSessionStatusUpdate = $root.ProtobufBroker.AnonymousSessionStatusUpdate.toObject(message.anonymousSessionStatusUpdate, options);
                if (options.oneofs)
                    object.Update = "anonymousSessionStatusUpdate";
            }
            if (message.permissionsUpdate != null && message.hasOwnProperty("permissionsUpdate")) {
                object.permissionsUpdate = $root.ProtobufBroker.PermissionsUpdate.toObject(message.permissionsUpdate, options);
                if (options.oneofs)
                    object.Update = "permissionsUpdate";
            }
            if (message.sessionStatusUpdate != null && message.hasOwnProperty("sessionStatusUpdate")) {
                object.sessionStatusUpdate = $root.ProtobufBroker.SessionStatusUpdate.toObject(message.sessionStatusUpdate, options);
                if (options.oneofs)
                    object.Update = "sessionStatusUpdate";
            }
            if (message.positionsUpdate != null && message.hasOwnProperty("positionsUpdate")) {
                object.positionsUpdate = $root.ProtobufBroker.PositionsUpdate.toObject(message.positionsUpdate, options);
                if (options.oneofs)
                    object.Update = "positionsUpdate";
            }
            if (message.apiAccessorStatusUpdate != null && message.hasOwnProperty("apiAccessorStatusUpdate")) {
                object.apiAccessorStatusUpdate = $root.ProtobufBroker.APIAccessorStatusUpdate.toObject(message.apiAccessorStatusUpdate, options);
                if (options.oneofs)
                    object.Update = "apiAccessorStatusUpdate";
            }
            if (message.authenticationResult != null && message.hasOwnProperty("authenticationResult")) {
                object.authenticationResult = $root.ProtobufStream.AuthenticationResult.toObject(message.authenticationResult, options);
                if (options.oneofs)
                    object.Update = "authenticationResult";
            }
            if (message.marketId != null && message.hasOwnProperty("marketId"))
                if (typeof message.marketId === "number")
                    object.marketId = options.longs === String ? String(message.marketId) : message.marketId;
                else
                    object.marketId = options.longs === String ? $util.Long.prototype.toString.call(message.marketId) : options.longs === Number ? new $util.LongBits(message.marketId.low >>> 0, message.marketId.high >>> 0).toNumber() : message.marketId;
            if (message.subscriptionResult != null && message.hasOwnProperty("subscriptionResult")) {
                object.subscriptionResult = $root.ProtobufStream.SubscriptionResult.toObject(message.subscriptionResult, options);
                if (options.oneofs)
                    object.Update = "subscriptionResult";
            }
            if (message.webAuthenticationResult != null && message.hasOwnProperty("webAuthenticationResult")) {
                object.webAuthenticationResult = $root.ProtobufClient.WebAuthenticationResult.toObject(message.webAuthenticationResult, options);
                if (options.oneofs)
                    object.Update = "webAuthenticationResult";
            }
            if (message.ledgersUpdate != null && message.hasOwnProperty("ledgersUpdate")) {
                object.ledgersUpdate = $root.ProtobufBroker.LedgersUpdate.toObject(message.ledgersUpdate, options);
                if (options.oneofs)
                    object.Update = "ledgersUpdate";
            }
            return object;
        };
        /**
         * Converts this BrokerUpdateMessage to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.BrokerUpdateMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BrokerUpdateMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return BrokerUpdateMessage;
    })();
    ProtobufBroker.Error = (function () {
        /**
         * Properties of an Error.
         * @memberof ProtobufBroker
         * @interface IError
         * @property {ProtobufBroker.Error.Kind|null} [kind] Error kind
         * @property {number|Long|null} [code] Error code
         * @property {string|null} [message] Error message
         * @property {Array.<google.protobuf.IAny>|null} [details] Error details
         */
        /**
         * Constructs a new Error.
         * @memberof ProtobufBroker
         * @classdesc Represents an Error.
         * @implements IError
         * @constructor
         * @param {ProtobufBroker.IError=} [properties] Properties to set
         */
        function Error(properties) {
            this.details = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Error kind.
         * @member {ProtobufBroker.Error.Kind} kind
         * @memberof ProtobufBroker.Error
         * @instance
         */
        Error.prototype.kind = 0;
        /**
         * Error code.
         * @member {number|Long} code
         * @memberof ProtobufBroker.Error
         * @instance
         */
        Error.prototype.code = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * Error message.
         * @member {string} message
         * @memberof ProtobufBroker.Error
         * @instance
         */
        Error.prototype.message = "";
        /**
         * Error details.
         * @member {Array.<google.protobuf.IAny>} details
         * @memberof ProtobufBroker.Error
         * @instance
         */
        Error.prototype.details = $util.emptyArray;
        /**
         * Creates a new Error instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.Error
         * @static
         * @param {ProtobufBroker.IError=} [properties] Properties to set
         * @returns {ProtobufBroker.Error} Error instance
         */
        Error.create = function create(properties) {
            return new Error(properties);
        };
        /**
         * Encodes the specified Error message. Does not implicitly {@link ProtobufBroker.Error.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.Error
         * @static
         * @param {ProtobufBroker.IError} message Error message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Error.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.kind);
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.code);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.message);
            if (message.details != null && message.details.length)
                for (var i = 0; i < message.details.length; ++i)
                    $root.google.protobuf.Any.encode(message.details[i], writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified Error message, length delimited. Does not implicitly {@link ProtobufBroker.Error.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.Error
         * @static
         * @param {ProtobufBroker.IError} message Error message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Error.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an Error message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.Error
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.Error} Error
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Error.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.Error();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.kind = reader.int32();
                        break;
                    case 2:
                        message.code = reader.uint64();
                        break;
                    case 4:
                        message.message = reader.string();
                        break;
                    case 5:
                        if (!(message.details && message.details.length))
                            message.details = [];
                        message.details.push($root.google.protobuf.Any.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an Error message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.Error
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.Error} Error
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Error.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an Error message.
         * @function verify
         * @memberof ProtobufBroker.Error
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Error.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                switch (message.kind) {
                    default:
                        return "kind: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                }
            if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isInteger(message.code) && !(message.code && $util.isInteger(message.code.low) && $util.isInteger(message.code.high)))
                    return "code: integer|Long expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.details != null && message.hasOwnProperty("details")) {
                if (!Array.isArray(message.details))
                    return "details: array expected";
                for (var i = 0; i < message.details.length; ++i) {
                    var error = $root.google.protobuf.Any.verify(message.details[i]);
                    if (error)
                        return "details." + error;
                }
            }
            return null;
        };
        /**
         * Creates an Error message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.Error
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.Error} Error
         */
        Error.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.Error)
                return object;
            var message = new $root.ProtobufBroker.Error();
            switch (object.kind) {
                case "KIND_UNKNOWN":
                case 0:
                    message.kind = 0;
                    break;
                case "KIND_INTERNAL":
                case 1:
                    message.kind = 1;
                    break;
                case "KIND_TRANSIENT":
                case 2:
                    message.kind = 2;
                    break;
                case "KIND_ABORTED":
                case 3:
                    message.kind = 3;
                    break;
                case "KIND_IO":
                case 4:
                    message.kind = 4;
                    break;
                case "KIND_PERMISSION_DENIED":
                case 5:
                    message.kind = 5;
                    break;
                case "KIND_INVALID_OPERATION":
                case 6:
                    message.kind = 6;
                    break;
                case "KIND_INVALID_ARGUMENT":
                case 7:
                    message.kind = 7;
                    break;
                case "KIND_INVALID_REQUEST":
                case 8:
                    message.kind = 8;
                    break;
            }
            if (object.code != null)
                if ($util.Long)
                    (message.code = $util.Long.fromValue(object.code)).unsigned = true;
                else if (typeof object.code === "string")
                    message.code = parseInt(object.code, 10);
                else if (typeof object.code === "number")
                    message.code = object.code;
                else if (typeof object.code === "object")
                    message.code = new $util.LongBits(object.code.low >>> 0, object.code.high >>> 0).toNumber(true);
            if (object.message != null)
                message.message = String(object.message);
            if (object.details) {
                if (!Array.isArray(object.details))
                    throw TypeError(".ProtobufBroker.Error.details: array expected");
                message.details = [];
                for (var i = 0; i < object.details.length; ++i) {
                    if (typeof object.details[i] !== "object")
                        throw TypeError(".ProtobufBroker.Error.details: object expected");
                    message.details[i] = $root.google.protobuf.Any.fromObject(object.details[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from an Error message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.Error
         * @static
         * @param {ProtobufBroker.Error} message Error
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Error.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.details = [];
            if (options.defaults) {
                object.kind = options.enums === String ? "KIND_UNKNOWN" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.code = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.code = options.longs === String ? "0" : 0;
                object.message = "";
            }
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = options.enums === String ? $root.ProtobufBroker.Error.Kind[message.kind] : message.kind;
            if (message.code != null && message.hasOwnProperty("code"))
                if (typeof message.code === "number")
                    object.code = options.longs === String ? String(message.code) : message.code;
                else
                    object.code = options.longs === String ? $util.Long.prototype.toString.call(message.code) : options.longs === Number ? new $util.LongBits(message.code.low >>> 0, message.code.high >>> 0).toNumber(true) : message.code;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.details && message.details.length) {
                object.details = [];
                for (var j = 0; j < message.details.length; ++j)
                    object.details[j] = $root.google.protobuf.Any.toObject(message.details[j], options);
            }
            return object;
        };
        /**
         * Converts this Error to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.Error
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Error.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Kind enum.
         * @name ProtobufBroker.Error.Kind
         * @enum {number}
         * @property {number} KIND_UNKNOWN=0 KIND_UNKNOWN value
         * @property {number} KIND_INTERNAL=1 KIND_INTERNAL value
         * @property {number} KIND_TRANSIENT=2 KIND_TRANSIENT value
         * @property {number} KIND_ABORTED=3 KIND_ABORTED value
         * @property {number} KIND_IO=4 KIND_IO value
         * @property {number} KIND_PERMISSION_DENIED=5 KIND_PERMISSION_DENIED value
         * @property {number} KIND_INVALID_OPERATION=6 KIND_INVALID_OPERATION value
         * @property {number} KIND_INVALID_ARGUMENT=7 KIND_INVALID_ARGUMENT value
         * @property {number} KIND_INVALID_REQUEST=8 KIND_INVALID_REQUEST value
         */
        Error.Kind = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "KIND_UNKNOWN"] = 0;
            values[valuesById[1] = "KIND_INTERNAL"] = 1;
            values[valuesById[2] = "KIND_TRANSIENT"] = 2;
            values[valuesById[3] = "KIND_ABORTED"] = 3;
            values[valuesById[4] = "KIND_IO"] = 4;
            values[valuesById[5] = "KIND_PERMISSION_DENIED"] = 5;
            values[valuesById[6] = "KIND_INVALID_OPERATION"] = 6;
            values[valuesById[7] = "KIND_INVALID_ARGUMENT"] = 7;
            values[valuesById[8] = "KIND_INVALID_REQUEST"] = 8;
            return values;
        })();
        return Error;
    })();
    /**
     * FundingType enum.
     * @name ProtobufBroker.FundingType
     * @enum {number}
     * @property {number} Spot=0 Spot value
     * @property {number} Margin=1 Margin value
     * @property {number} Staking=2 Staking value
     */
    ProtobufBroker.FundingType = (function () {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Spot"] = 0;
        values[valuesById[1] = "Margin"] = 1;
        values[valuesById[2] = "Staking"] = 2;
        return values;
    })();
    ProtobufBroker.PrivateOrder = (function () {
        /**
         * Properties of a PrivateOrder.
         * @memberof ProtobufBroker
         * @interface IPrivateOrder
         * @property {string|null} [id] PrivateOrder id
         * @property {number|Long|null} [time] PrivateOrder time
         * @property {number|null} [side] PrivateOrder side
         * @property {ProtobufBroker.PrivateOrder.Type|null} [type] PrivateOrder type
         * @property {ProtobufBroker.FundingType|null} [fundingType] PrivateOrder fundingType
         * @property {Array.<ProtobufBroker.PrivateOrder.IPriceParam>|null} [priceParams] PrivateOrder priceParams
         * @property {string|null} [amountParamString] PrivateOrder amountParamString
         * @property {string|null} [amountFilledString] PrivateOrder amountFilledString
         * @property {string|null} [leverage] PrivateOrder leverage
         * @property {string|null} [currentStopString] PrivateOrder currentStopString
         * @property {string|null} [initialStopString] PrivateOrder initialStopString
         * @property {number|Long|null} [startTime] PrivateOrder startTime
         * @property {number|Long|null} [expireTime] PrivateOrder expireTime
         * @property {number|null} [rate] PrivateOrder rate
         * @property {boolean|null} [hasClosingOrder] PrivateOrder hasClosingOrder
         * @property {ProtobufBroker.PrivateOrder.Type|null} [closingOrderType] PrivateOrder closingOrderType
         * @property {Array.<ProtobufBroker.PrivateOrder.IPriceParam>|null} [closingOrderPriceParams] PrivateOrder closingOrderPriceParams
         * @property {ProtobufBroker.PrivateOrder.CurrencyPairSide|null} [feeCurrency] PrivateOrder feeCurrency
         * @property {boolean|null} [postOnly] PrivateOrder postOnly
         * @property {string|null} [groupId] PrivateOrder groupId
         * @property {boolean|null} [fillOrKill] PrivateOrder fillOrKill
         * @property {boolean|null} [immediateOrCancel] PrivateOrder immediateOrCancel
         */
        /**
         * Constructs a new PrivateOrder.
         * @memberof ProtobufBroker
         * @classdesc Represents a PrivateOrder.
         * @implements IPrivateOrder
         * @constructor
         * @param {ProtobufBroker.IPrivateOrder=} [properties] Properties to set
         */
        function PrivateOrder(properties) {
            this.priceParams = [];
            this.closingOrderPriceParams = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PrivateOrder id.
         * @member {string} id
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         */
        PrivateOrder.prototype.id = "";
        /**
         * PrivateOrder time.
         * @member {number|Long} time
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         */
        PrivateOrder.prototype.time = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * PrivateOrder side.
         * @member {number} side
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         */
        PrivateOrder.prototype.side = 0;
        /**
         * PrivateOrder type.
         * @member {ProtobufBroker.PrivateOrder.Type} type
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         */
        PrivateOrder.prototype.type = 0;
        /**
         * PrivateOrder fundingType.
         * @member {ProtobufBroker.FundingType} fundingType
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         */
        PrivateOrder.prototype.fundingType = 0;
        /**
         * PrivateOrder priceParams.
         * @member {Array.<ProtobufBroker.PrivateOrder.IPriceParam>} priceParams
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         */
        PrivateOrder.prototype.priceParams = $util.emptyArray;
        /**
         * PrivateOrder amountParamString.
         * @member {string} amountParamString
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         */
        PrivateOrder.prototype.amountParamString = "";
        /**
         * PrivateOrder amountFilledString.
         * @member {string} amountFilledString
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         */
        PrivateOrder.prototype.amountFilledString = "";
        /**
         * PrivateOrder leverage.
         * @member {string} leverage
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         */
        PrivateOrder.prototype.leverage = "";
        /**
         * PrivateOrder currentStopString.
         * @member {string} currentStopString
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         */
        PrivateOrder.prototype.currentStopString = "";
        /**
         * PrivateOrder initialStopString.
         * @member {string} initialStopString
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         */
        PrivateOrder.prototype.initialStopString = "";
        /**
         * PrivateOrder startTime.
         * @member {number|Long} startTime
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         */
        PrivateOrder.prototype.startTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * PrivateOrder expireTime.
         * @member {number|Long} expireTime
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         */
        PrivateOrder.prototype.expireTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * PrivateOrder rate.
         * @member {number} rate
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         */
        PrivateOrder.prototype.rate = 0;
        /**
         * PrivateOrder hasClosingOrder.
         * @member {boolean} hasClosingOrder
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         */
        PrivateOrder.prototype.hasClosingOrder = false;
        /**
         * PrivateOrder closingOrderType.
         * @member {ProtobufBroker.PrivateOrder.Type} closingOrderType
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         */
        PrivateOrder.prototype.closingOrderType = 0;
        /**
         * PrivateOrder closingOrderPriceParams.
         * @member {Array.<ProtobufBroker.PrivateOrder.IPriceParam>} closingOrderPriceParams
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         */
        PrivateOrder.prototype.closingOrderPriceParams = $util.emptyArray;
        /**
         * PrivateOrder feeCurrency.
         * @member {ProtobufBroker.PrivateOrder.CurrencyPairSide} feeCurrency
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         */
        PrivateOrder.prototype.feeCurrency = 0;
        /**
         * PrivateOrder postOnly.
         * @member {boolean} postOnly
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         */
        PrivateOrder.prototype.postOnly = false;
        /**
         * PrivateOrder groupId.
         * @member {string} groupId
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         */
        PrivateOrder.prototype.groupId = "";
        /**
         * PrivateOrder fillOrKill.
         * @member {boolean} fillOrKill
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         */
        PrivateOrder.prototype.fillOrKill = false;
        /**
         * PrivateOrder immediateOrCancel.
         * @member {boolean} immediateOrCancel
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         */
        PrivateOrder.prototype.immediateOrCancel = false;
        /**
         * Creates a new PrivateOrder instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.PrivateOrder
         * @static
         * @param {ProtobufBroker.IPrivateOrder=} [properties] Properties to set
         * @returns {ProtobufBroker.PrivateOrder} PrivateOrder instance
         */
        PrivateOrder.create = function create(properties) {
            return new PrivateOrder(properties);
        };
        /**
         * Encodes the specified PrivateOrder message. Does not implicitly {@link ProtobufBroker.PrivateOrder.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.PrivateOrder
         * @static
         * @param {ProtobufBroker.IPrivateOrder} message PrivateOrder message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivateOrder.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.time);
            if (message.side != null && Object.hasOwnProperty.call(message, "side"))
                writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.side);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 6, wireType 0 =*/ 48).int32(message.type);
            if (message.fundingType != null && Object.hasOwnProperty.call(message, "fundingType"))
                writer.uint32(/* id 7, wireType 0 =*/ 56).int32(message.fundingType);
            if (message.priceParams != null && message.priceParams.length)
                for (var i = 0; i < message.priceParams.length; ++i)
                    $root.ProtobufBroker.PrivateOrder.PriceParam.encode(message.priceParams[i], writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
            if (message.leverage != null && Object.hasOwnProperty.call(message, "leverage"))
                writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.leverage);
            if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
                writer.uint32(/* id 13, wireType 0 =*/ 104).int64(message.startTime);
            if (message.expireTime != null && Object.hasOwnProperty.call(message, "expireTime"))
                writer.uint32(/* id 14, wireType 0 =*/ 112).int64(message.expireTime);
            if (message.rate != null && Object.hasOwnProperty.call(message, "rate"))
                writer.uint32(/* id 15, wireType 5 =*/ 125).float(message.rate);
            if (message.amountParamString != null && Object.hasOwnProperty.call(message, "amountParamString"))
                writer.uint32(/* id 16, wireType 2 =*/ 130).string(message.amountParamString);
            if (message.amountFilledString != null && Object.hasOwnProperty.call(message, "amountFilledString"))
                writer.uint32(/* id 17, wireType 2 =*/ 138).string(message.amountFilledString);
            if (message.currentStopString != null && Object.hasOwnProperty.call(message, "currentStopString"))
                writer.uint32(/* id 18, wireType 2 =*/ 146).string(message.currentStopString);
            if (message.initialStopString != null && Object.hasOwnProperty.call(message, "initialStopString"))
                writer.uint32(/* id 19, wireType 2 =*/ 154).string(message.initialStopString);
            if (message.hasClosingOrder != null && Object.hasOwnProperty.call(message, "hasClosingOrder"))
                writer.uint32(/* id 20, wireType 0 =*/ 160).bool(message.hasClosingOrder);
            if (message.closingOrderType != null && Object.hasOwnProperty.call(message, "closingOrderType"))
                writer.uint32(/* id 21, wireType 0 =*/ 168).int32(message.closingOrderType);
            if (message.closingOrderPriceParams != null && message.closingOrderPriceParams.length)
                for (var i = 0; i < message.closingOrderPriceParams.length; ++i)
                    $root.ProtobufBroker.PrivateOrder.PriceParam.encode(message.closingOrderPriceParams[i], writer.uint32(/* id 22, wireType 2 =*/ 178).fork()).ldelim();
            if (message.feeCurrency != null && Object.hasOwnProperty.call(message, "feeCurrency"))
                writer.uint32(/* id 23, wireType 0 =*/ 184).int32(message.feeCurrency);
            if (message.postOnly != null && Object.hasOwnProperty.call(message, "postOnly"))
                writer.uint32(/* id 24, wireType 0 =*/ 192).bool(message.postOnly);
            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                writer.uint32(/* id 25, wireType 2 =*/ 202).string(message.groupId);
            if (message.fillOrKill != null && Object.hasOwnProperty.call(message, "fillOrKill"))
                writer.uint32(/* id 26, wireType 0 =*/ 208).bool(message.fillOrKill);
            if (message.immediateOrCancel != null && Object.hasOwnProperty.call(message, "immediateOrCancel"))
                writer.uint32(/* id 27, wireType 0 =*/ 216).bool(message.immediateOrCancel);
            return writer;
        };
        /**
         * Encodes the specified PrivateOrder message, length delimited. Does not implicitly {@link ProtobufBroker.PrivateOrder.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.PrivateOrder
         * @static
         * @param {ProtobufBroker.IPrivateOrder} message PrivateOrder message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivateOrder.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PrivateOrder message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.PrivateOrder
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.PrivateOrder} PrivateOrder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivateOrder.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.PrivateOrder();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.time = reader.int64();
                        break;
                    case 5:
                        message.side = reader.int32();
                        break;
                    case 6:
                        message.type = reader.int32();
                        break;
                    case 7:
                        message.fundingType = reader.int32();
                        break;
                    case 8:
                        if (!(message.priceParams && message.priceParams.length))
                            message.priceParams = [];
                        message.priceParams.push($root.ProtobufBroker.PrivateOrder.PriceParam.decode(reader, reader.uint32()));
                        break;
                    case 16:
                        message.amountParamString = reader.string();
                        break;
                    case 17:
                        message.amountFilledString = reader.string();
                        break;
                    case 10:
                        message.leverage = reader.string();
                        break;
                    case 18:
                        message.currentStopString = reader.string();
                        break;
                    case 19:
                        message.initialStopString = reader.string();
                        break;
                    case 13:
                        message.startTime = reader.int64();
                        break;
                    case 14:
                        message.expireTime = reader.int64();
                        break;
                    case 15:
                        message.rate = reader.float();
                        break;
                    case 20:
                        message.hasClosingOrder = reader.bool();
                        break;
                    case 21:
                        message.closingOrderType = reader.int32();
                        break;
                    case 22:
                        if (!(message.closingOrderPriceParams && message.closingOrderPriceParams.length))
                            message.closingOrderPriceParams = [];
                        message.closingOrderPriceParams.push($root.ProtobufBroker.PrivateOrder.PriceParam.decode(reader, reader.uint32()));
                        break;
                    case 23:
                        message.feeCurrency = reader.int32();
                        break;
                    case 24:
                        message.postOnly = reader.bool();
                        break;
                    case 25:
                        message.groupId = reader.string();
                        break;
                    case 26:
                        message.fillOrKill = reader.bool();
                        break;
                    case 27:
                        message.immediateOrCancel = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PrivateOrder message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.PrivateOrder
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.PrivateOrder} PrivateOrder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivateOrder.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PrivateOrder message.
         * @function verify
         * @memberof ProtobufBroker.PrivateOrder
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrivateOrder.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            if (message.side != null && message.hasOwnProperty("side"))
                if (!$util.isInteger(message.side))
                    return "side: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                        break;
                }
            if (message.fundingType != null && message.hasOwnProperty("fundingType"))
                switch (message.fundingType) {
                    default:
                        return "fundingType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                }
            if (message.priceParams != null && message.hasOwnProperty("priceParams")) {
                if (!Array.isArray(message.priceParams))
                    return "priceParams: array expected";
                for (var i = 0; i < message.priceParams.length; ++i) {
                    var error = $root.ProtobufBroker.PrivateOrder.PriceParam.verify(message.priceParams[i]);
                    if (error)
                        return "priceParams." + error;
                }
            }
            if (message.amountParamString != null && message.hasOwnProperty("amountParamString"))
                if (!$util.isString(message.amountParamString))
                    return "amountParamString: string expected";
            if (message.amountFilledString != null && message.hasOwnProperty("amountFilledString"))
                if (!$util.isString(message.amountFilledString))
                    return "amountFilledString: string expected";
            if (message.leverage != null && message.hasOwnProperty("leverage"))
                if (!$util.isString(message.leverage))
                    return "leverage: string expected";
            if (message.currentStopString != null && message.hasOwnProperty("currentStopString"))
                if (!$util.isString(message.currentStopString))
                    return "currentStopString: string expected";
            if (message.initialStopString != null && message.hasOwnProperty("initialStopString"))
                if (!$util.isString(message.initialStopString))
                    return "initialStopString: string expected";
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                    return "startTime: integer|Long expected";
            if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                if (!$util.isInteger(message.expireTime) && !(message.expireTime && $util.isInteger(message.expireTime.low) && $util.isInteger(message.expireTime.high)))
                    return "expireTime: integer|Long expected";
            if (message.rate != null && message.hasOwnProperty("rate"))
                if (typeof message.rate !== "number")
                    return "rate: number expected";
            if (message.hasClosingOrder != null && message.hasOwnProperty("hasClosingOrder"))
                if (typeof message.hasClosingOrder !== "boolean")
                    return "hasClosingOrder: boolean expected";
            if (message.closingOrderType != null && message.hasOwnProperty("closingOrderType"))
                switch (message.closingOrderType) {
                    default:
                        return "closingOrderType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                        break;
                }
            if (message.closingOrderPriceParams != null && message.hasOwnProperty("closingOrderPriceParams")) {
                if (!Array.isArray(message.closingOrderPriceParams))
                    return "closingOrderPriceParams: array expected";
                for (var i = 0; i < message.closingOrderPriceParams.length; ++i) {
                    var error = $root.ProtobufBroker.PrivateOrder.PriceParam.verify(message.closingOrderPriceParams[i]);
                    if (error)
                        return "closingOrderPriceParams." + error;
                }
            }
            if (message.feeCurrency != null && message.hasOwnProperty("feeCurrency"))
                switch (message.feeCurrency) {
                    default:
                        return "feeCurrency: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                }
            if (message.postOnly != null && message.hasOwnProperty("postOnly"))
                if (typeof message.postOnly !== "boolean")
                    return "postOnly: boolean expected";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (!$util.isString(message.groupId))
                    return "groupId: string expected";
            if (message.fillOrKill != null && message.hasOwnProperty("fillOrKill"))
                if (typeof message.fillOrKill !== "boolean")
                    return "fillOrKill: boolean expected";
            if (message.immediateOrCancel != null && message.hasOwnProperty("immediateOrCancel"))
                if (typeof message.immediateOrCancel !== "boolean")
                    return "immediateOrCancel: boolean expected";
            return null;
        };
        /**
         * Creates a PrivateOrder message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.PrivateOrder
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.PrivateOrder} PrivateOrder
         */
        PrivateOrder.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.PrivateOrder)
                return object;
            var message = new $root.ProtobufBroker.PrivateOrder();
            if (object.id != null)
                message.id = String(object.id);
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            if (object.side != null)
                message.side = object.side | 0;
            switch (object.type) {
                case "Market":
                case 0:
                    message.type = 0;
                    break;
                case "Limit":
                case 1:
                    message.type = 1;
                    break;
                case "StopLoss":
                case 2:
                    message.type = 2;
                    break;
                case "StopLossLimit":
                case 3:
                    message.type = 3;
                    break;
                case "TakeProfit":
                case 4:
                    message.type = 4;
                    break;
                case "TakeProfitLimit":
                case 5:
                    message.type = 5;
                    break;
                case "StopLossTakeProfit":
                case 6:
                    message.type = 6;
                    break;
                case "StopLossTakeProfitLimit":
                case 7:
                    message.type = 7;
                    break;
                case "TrailingStopLoss":
                case 8:
                    message.type = 8;
                    break;
                case "TrailingStopLossLimit":
                case 9:
                    message.type = 9;
                    break;
                case "StopLossAndLimit":
                case 10:
                    message.type = 10;
                    break;
                case "FillOrKill":
                case 11:
                    message.type = 11;
                    break;
                case "SettlePosition":
                case 12:
                    message.type = 12;
                    break;
            }
            switch (object.fundingType) {
                case "Spot":
                case 0:
                    message.fundingType = 0;
                    break;
                case "Margin":
                case 1:
                    message.fundingType = 1;
                    break;
                case "Staking":
                case 2:
                    message.fundingType = 2;
                    break;
            }
            if (object.priceParams) {
                if (!Array.isArray(object.priceParams))
                    throw TypeError(".ProtobufBroker.PrivateOrder.priceParams: array expected");
                message.priceParams = [];
                for (var i = 0; i < object.priceParams.length; ++i) {
                    if (typeof object.priceParams[i] !== "object")
                        throw TypeError(".ProtobufBroker.PrivateOrder.priceParams: object expected");
                    message.priceParams[i] = $root.ProtobufBroker.PrivateOrder.PriceParam.fromObject(object.priceParams[i]);
                }
            }
            if (object.amountParamString != null)
                message.amountParamString = String(object.amountParamString);
            if (object.amountFilledString != null)
                message.amountFilledString = String(object.amountFilledString);
            if (object.leverage != null)
                message.leverage = String(object.leverage);
            if (object.currentStopString != null)
                message.currentStopString = String(object.currentStopString);
            if (object.initialStopString != null)
                message.initialStopString = String(object.initialStopString);
            if (object.startTime != null)
                if ($util.Long)
                    (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = false;
                else if (typeof object.startTime === "string")
                    message.startTime = parseInt(object.startTime, 10);
                else if (typeof object.startTime === "number")
                    message.startTime = object.startTime;
                else if (typeof object.startTime === "object")
                    message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber();
            if (object.expireTime != null)
                if ($util.Long)
                    (message.expireTime = $util.Long.fromValue(object.expireTime)).unsigned = false;
                else if (typeof object.expireTime === "string")
                    message.expireTime = parseInt(object.expireTime, 10);
                else if (typeof object.expireTime === "number")
                    message.expireTime = object.expireTime;
                else if (typeof object.expireTime === "object")
                    message.expireTime = new $util.LongBits(object.expireTime.low >>> 0, object.expireTime.high >>> 0).toNumber();
            if (object.rate != null)
                message.rate = Number(object.rate);
            if (object.hasClosingOrder != null)
                message.hasClosingOrder = Boolean(object.hasClosingOrder);
            switch (object.closingOrderType) {
                case "Market":
                case 0:
                    message.closingOrderType = 0;
                    break;
                case "Limit":
                case 1:
                    message.closingOrderType = 1;
                    break;
                case "StopLoss":
                case 2:
                    message.closingOrderType = 2;
                    break;
                case "StopLossLimit":
                case 3:
                    message.closingOrderType = 3;
                    break;
                case "TakeProfit":
                case 4:
                    message.closingOrderType = 4;
                    break;
                case "TakeProfitLimit":
                case 5:
                    message.closingOrderType = 5;
                    break;
                case "StopLossTakeProfit":
                case 6:
                    message.closingOrderType = 6;
                    break;
                case "StopLossTakeProfitLimit":
                case 7:
                    message.closingOrderType = 7;
                    break;
                case "TrailingStopLoss":
                case 8:
                    message.closingOrderType = 8;
                    break;
                case "TrailingStopLossLimit":
                case 9:
                    message.closingOrderType = 9;
                    break;
                case "StopLossAndLimit":
                case 10:
                    message.closingOrderType = 10;
                    break;
                case "FillOrKill":
                case 11:
                    message.closingOrderType = 11;
                    break;
                case "SettlePosition":
                case 12:
                    message.closingOrderType = 12;
                    break;
            }
            if (object.closingOrderPriceParams) {
                if (!Array.isArray(object.closingOrderPriceParams))
                    throw TypeError(".ProtobufBroker.PrivateOrder.closingOrderPriceParams: array expected");
                message.closingOrderPriceParams = [];
                for (var i = 0; i < object.closingOrderPriceParams.length; ++i) {
                    if (typeof object.closingOrderPriceParams[i] !== "object")
                        throw TypeError(".ProtobufBroker.PrivateOrder.closingOrderPriceParams: object expected");
                    message.closingOrderPriceParams[i] = $root.ProtobufBroker.PrivateOrder.PriceParam.fromObject(object.closingOrderPriceParams[i]);
                }
            }
            switch (object.feeCurrency) {
                case "CURRENCY_PAIR_SIDE_UNKNOWN":
                case 0:
                    message.feeCurrency = 0;
                    break;
                case "CURRENCY_PAIR_SIDE_BASE":
                case 1:
                    message.feeCurrency = 1;
                    break;
                case "CURRENCY_PAIR_SIDE_QUOTE":
                case 2:
                    message.feeCurrency = 2;
                    break;
            }
            if (object.postOnly != null)
                message.postOnly = Boolean(object.postOnly);
            if (object.groupId != null)
                message.groupId = String(object.groupId);
            if (object.fillOrKill != null)
                message.fillOrKill = Boolean(object.fillOrKill);
            if (object.immediateOrCancel != null)
                message.immediateOrCancel = Boolean(object.immediateOrCancel);
            return message;
        };
        /**
         * Creates a plain object from a PrivateOrder message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.PrivateOrder
         * @static
         * @param {ProtobufBroker.PrivateOrder} message PrivateOrder
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PrivateOrder.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.priceParams = [];
                object.closingOrderPriceParams = [];
            }
            if (options.defaults) {
                object.id = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.time = options.longs === String ? "0" : 0;
                object.side = 0;
                object.type = options.enums === String ? "Market" : 0;
                object.fundingType = options.enums === String ? "Spot" : 0;
                object.leverage = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.startTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expireTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.expireTime = options.longs === String ? "0" : 0;
                object.rate = 0;
                object.amountParamString = "";
                object.amountFilledString = "";
                object.currentStopString = "";
                object.initialStopString = "";
                object.hasClosingOrder = false;
                object.closingOrderType = options.enums === String ? "Market" : 0;
                object.feeCurrency = options.enums === String ? "CURRENCY_PAIR_SIDE_UNKNOWN" : 0;
                object.postOnly = false;
                object.groupId = "";
                object.fillOrKill = false;
                object.immediateOrCancel = false;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            if (message.side != null && message.hasOwnProperty("side"))
                object.side = message.side;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ProtobufBroker.PrivateOrder.Type[message.type] : message.type;
            if (message.fundingType != null && message.hasOwnProperty("fundingType"))
                object.fundingType = options.enums === String ? $root.ProtobufBroker.FundingType[message.fundingType] : message.fundingType;
            if (message.priceParams && message.priceParams.length) {
                object.priceParams = [];
                for (var j = 0; j < message.priceParams.length; ++j)
                    object.priceParams[j] = $root.ProtobufBroker.PrivateOrder.PriceParam.toObject(message.priceParams[j], options);
            }
            if (message.leverage != null && message.hasOwnProperty("leverage"))
                object.leverage = message.leverage;
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (typeof message.startTime === "number")
                    object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
                else
                    object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber() : message.startTime;
            if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                if (typeof message.expireTime === "number")
                    object.expireTime = options.longs === String ? String(message.expireTime) : message.expireTime;
                else
                    object.expireTime = options.longs === String ? $util.Long.prototype.toString.call(message.expireTime) : options.longs === Number ? new $util.LongBits(message.expireTime.low >>> 0, message.expireTime.high >>> 0).toNumber() : message.expireTime;
            if (message.rate != null && message.hasOwnProperty("rate"))
                object.rate = options.json && !isFinite(message.rate) ? String(message.rate) : message.rate;
            if (message.amountParamString != null && message.hasOwnProperty("amountParamString"))
                object.amountParamString = message.amountParamString;
            if (message.amountFilledString != null && message.hasOwnProperty("amountFilledString"))
                object.amountFilledString = message.amountFilledString;
            if (message.currentStopString != null && message.hasOwnProperty("currentStopString"))
                object.currentStopString = message.currentStopString;
            if (message.initialStopString != null && message.hasOwnProperty("initialStopString"))
                object.initialStopString = message.initialStopString;
            if (message.hasClosingOrder != null && message.hasOwnProperty("hasClosingOrder"))
                object.hasClosingOrder = message.hasClosingOrder;
            if (message.closingOrderType != null && message.hasOwnProperty("closingOrderType"))
                object.closingOrderType = options.enums === String ? $root.ProtobufBroker.PrivateOrder.Type[message.closingOrderType] : message.closingOrderType;
            if (message.closingOrderPriceParams && message.closingOrderPriceParams.length) {
                object.closingOrderPriceParams = [];
                for (var j = 0; j < message.closingOrderPriceParams.length; ++j)
                    object.closingOrderPriceParams[j] = $root.ProtobufBroker.PrivateOrder.PriceParam.toObject(message.closingOrderPriceParams[j], options);
            }
            if (message.feeCurrency != null && message.hasOwnProperty("feeCurrency"))
                object.feeCurrency = options.enums === String ? $root.ProtobufBroker.PrivateOrder.CurrencyPairSide[message.feeCurrency] : message.feeCurrency;
            if (message.postOnly != null && message.hasOwnProperty("postOnly"))
                object.postOnly = message.postOnly;
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                object.groupId = message.groupId;
            if (message.fillOrKill != null && message.hasOwnProperty("fillOrKill"))
                object.fillOrKill = message.fillOrKill;
            if (message.immediateOrCancel != null && message.hasOwnProperty("immediateOrCancel"))
                object.immediateOrCancel = message.immediateOrCancel;
            return object;
        };
        /**
         * Converts this PrivateOrder to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.PrivateOrder
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PrivateOrder.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Type enum.
         * @name ProtobufBroker.PrivateOrder.Type
         * @enum {number}
         * @property {number} Market=0 Market value
         * @property {number} Limit=1 Limit value
         * @property {number} StopLoss=2 StopLoss value
         * @property {number} StopLossLimit=3 StopLossLimit value
         * @property {number} TakeProfit=4 TakeProfit value
         * @property {number} TakeProfitLimit=5 TakeProfitLimit value
         * @property {number} StopLossTakeProfit=6 StopLossTakeProfit value
         * @property {number} StopLossTakeProfitLimit=7 StopLossTakeProfitLimit value
         * @property {number} TrailingStopLoss=8 TrailingStopLoss value
         * @property {number} TrailingStopLossLimit=9 TrailingStopLossLimit value
         * @property {number} StopLossAndLimit=10 StopLossAndLimit value
         * @property {number} FillOrKill=11 FillOrKill value
         * @property {number} SettlePosition=12 SettlePosition value
         */
        PrivateOrder.Type = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Market"] = 0;
            values[valuesById[1] = "Limit"] = 1;
            values[valuesById[2] = "StopLoss"] = 2;
            values[valuesById[3] = "StopLossLimit"] = 3;
            values[valuesById[4] = "TakeProfit"] = 4;
            values[valuesById[5] = "TakeProfitLimit"] = 5;
            values[valuesById[6] = "StopLossTakeProfit"] = 6;
            values[valuesById[7] = "StopLossTakeProfitLimit"] = 7;
            values[valuesById[8] = "TrailingStopLoss"] = 8;
            values[valuesById[9] = "TrailingStopLossLimit"] = 9;
            values[valuesById[10] = "StopLossAndLimit"] = 10;
            values[valuesById[11] = "FillOrKill"] = 11;
            values[valuesById[12] = "SettlePosition"] = 12;
            return values;
        })();
        /**
         * PriceParamType enum.
         * @name ProtobufBroker.PrivateOrder.PriceParamType
         * @enum {number}
         * @property {number} AbsoluteValue=0 AbsoluteValue value
         * @property {number} OffsetValue=1 OffsetValue value
         * @property {number} PrecentageOffsetValue=2 PrecentageOffsetValue value
         */
        PrivateOrder.PriceParamType = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "AbsoluteValue"] = 0;
            values[valuesById[1] = "OffsetValue"] = 1;
            values[valuesById[2] = "PrecentageOffsetValue"] = 2;
            return values;
        })();
        PrivateOrder.PriceParam = (function () {
            /**
             * Properties of a PriceParam.
             * @memberof ProtobufBroker.PrivateOrder
             * @interface IPriceParam
             * @property {string|null} [valueString] PriceParam valueString
             * @property {ProtobufBroker.PrivateOrder.PriceParamType|null} [type] PriceParam type
             */
            /**
             * Constructs a new PriceParam.
             * @memberof ProtobufBroker.PrivateOrder
             * @classdesc Represents a PriceParam.
             * @implements IPriceParam
             * @constructor
             * @param {ProtobufBroker.PrivateOrder.IPriceParam=} [properties] Properties to set
             */
            function PriceParam(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * PriceParam valueString.
             * @member {string} valueString
             * @memberof ProtobufBroker.PrivateOrder.PriceParam
             * @instance
             */
            PriceParam.prototype.valueString = "";
            /**
             * PriceParam type.
             * @member {ProtobufBroker.PrivateOrder.PriceParamType} type
             * @memberof ProtobufBroker.PrivateOrder.PriceParam
             * @instance
             */
            PriceParam.prototype.type = 0;
            /**
             * Creates a new PriceParam instance using the specified properties.
             * @function create
             * @memberof ProtobufBroker.PrivateOrder.PriceParam
             * @static
             * @param {ProtobufBroker.PrivateOrder.IPriceParam=} [properties] Properties to set
             * @returns {ProtobufBroker.PrivateOrder.PriceParam} PriceParam instance
             */
            PriceParam.create = function create(properties) {
                return new PriceParam(properties);
            };
            /**
             * Encodes the specified PriceParam message. Does not implicitly {@link ProtobufBroker.PrivateOrder.PriceParam.verify|verify} messages.
             * @function encode
             * @memberof ProtobufBroker.PrivateOrder.PriceParam
             * @static
             * @param {ProtobufBroker.PrivateOrder.IPriceParam} message PriceParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PriceParam.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.type);
                if (message.valueString != null && Object.hasOwnProperty.call(message, "valueString"))
                    writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.valueString);
                return writer;
            };
            /**
             * Encodes the specified PriceParam message, length delimited. Does not implicitly {@link ProtobufBroker.PrivateOrder.PriceParam.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ProtobufBroker.PrivateOrder.PriceParam
             * @static
             * @param {ProtobufBroker.PrivateOrder.IPriceParam} message PriceParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PriceParam.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a PriceParam message from the specified reader or buffer.
             * @function decode
             * @memberof ProtobufBroker.PrivateOrder.PriceParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ProtobufBroker.PrivateOrder.PriceParam} PriceParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PriceParam.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.PrivateOrder.PriceParam();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 3:
                            message.valueString = reader.string();
                            break;
                        case 2:
                            message.type = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a PriceParam message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ProtobufBroker.PrivateOrder.PriceParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ProtobufBroker.PrivateOrder.PriceParam} PriceParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PriceParam.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a PriceParam message.
             * @function verify
             * @memberof ProtobufBroker.PrivateOrder.PriceParam
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PriceParam.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.valueString != null && message.hasOwnProperty("valueString"))
                    if (!$util.isString(message.valueString))
                        return "valueString: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                    }
                return null;
            };
            /**
             * Creates a PriceParam message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ProtobufBroker.PrivateOrder.PriceParam
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ProtobufBroker.PrivateOrder.PriceParam} PriceParam
             */
            PriceParam.fromObject = function fromObject(object) {
                if (object instanceof $root.ProtobufBroker.PrivateOrder.PriceParam)
                    return object;
                var message = new $root.ProtobufBroker.PrivateOrder.PriceParam();
                if (object.valueString != null)
                    message.valueString = String(object.valueString);
                switch (object.type) {
                    case "AbsoluteValue":
                    case 0:
                        message.type = 0;
                        break;
                    case "OffsetValue":
                    case 1:
                        message.type = 1;
                        break;
                    case "PrecentageOffsetValue":
                    case 2:
                        message.type = 2;
                        break;
                }
                return message;
            };
            /**
             * Creates a plain object from a PriceParam message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ProtobufBroker.PrivateOrder.PriceParam
             * @static
             * @param {ProtobufBroker.PrivateOrder.PriceParam} message PriceParam
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PriceParam.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "AbsoluteValue" : 0;
                    object.valueString = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.ProtobufBroker.PrivateOrder.PriceParamType[message.type] : message.type;
                if (message.valueString != null && message.hasOwnProperty("valueString"))
                    object.valueString = message.valueString;
                return object;
            };
            /**
             * Converts this PriceParam to JSON.
             * @function toJSON
             * @memberof ProtobufBroker.PrivateOrder.PriceParam
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PriceParam.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return PriceParam;
        })();
        /**
         * CurrencyPairSide enum.
         * @name ProtobufBroker.PrivateOrder.CurrencyPairSide
         * @enum {number}
         * @property {number} CURRENCY_PAIR_SIDE_UNKNOWN=0 CURRENCY_PAIR_SIDE_UNKNOWN value
         * @property {number} CURRENCY_PAIR_SIDE_BASE=1 CURRENCY_PAIR_SIDE_BASE value
         * @property {number} CURRENCY_PAIR_SIDE_QUOTE=2 CURRENCY_PAIR_SIDE_QUOTE value
         */
        PrivateOrder.CurrencyPairSide = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CURRENCY_PAIR_SIDE_UNKNOWN"] = 0;
            values[valuesById[1] = "CURRENCY_PAIR_SIDE_BASE"] = 1;
            values[valuesById[2] = "CURRENCY_PAIR_SIDE_QUOTE"] = 2;
            return values;
        })();
        return PrivateOrder;
    })();
    ProtobufBroker.PrivateTrade = (function () {
        /**
         * Properties of a PrivateTrade.
         * @memberof ProtobufBroker
         * @interface IPrivateTrade
         * @property {string|null} [externalId] PrivateTrade externalId
         * @property {string|null} [orderId] PrivateTrade orderId
         * @property {number|Long|null} [time] PrivateTrade time
         * @property {number|Long|null} [timeMillis] PrivateTrade timeMillis
         * @property {string|null} [priceString] PrivateTrade priceString
         * @property {string|null} [amountString] PrivateTrade amountString
         * @property {number|null} [side] PrivateTrade side
         * @property {number|Long|null} [id] PrivateTrade id
         */
        /**
         * Constructs a new PrivateTrade.
         * @memberof ProtobufBroker
         * @classdesc Represents a PrivateTrade.
         * @implements IPrivateTrade
         * @constructor
         * @param {ProtobufBroker.IPrivateTrade=} [properties] Properties to set
         */
        function PrivateTrade(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PrivateTrade externalId.
         * @member {string} externalId
         * @memberof ProtobufBroker.PrivateTrade
         * @instance
         */
        PrivateTrade.prototype.externalId = "";
        /**
         * PrivateTrade orderId.
         * @member {string} orderId
         * @memberof ProtobufBroker.PrivateTrade
         * @instance
         */
        PrivateTrade.prototype.orderId = "";
        /**
         * PrivateTrade time.
         * @member {number|Long} time
         * @memberof ProtobufBroker.PrivateTrade
         * @instance
         */
        PrivateTrade.prototype.time = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * PrivateTrade timeMillis.
         * @member {number|Long} timeMillis
         * @memberof ProtobufBroker.PrivateTrade
         * @instance
         */
        PrivateTrade.prototype.timeMillis = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * PrivateTrade priceString.
         * @member {string} priceString
         * @memberof ProtobufBroker.PrivateTrade
         * @instance
         */
        PrivateTrade.prototype.priceString = "";
        /**
         * PrivateTrade amountString.
         * @member {string} amountString
         * @memberof ProtobufBroker.PrivateTrade
         * @instance
         */
        PrivateTrade.prototype.amountString = "";
        /**
         * PrivateTrade side.
         * @member {number} side
         * @memberof ProtobufBroker.PrivateTrade
         * @instance
         */
        PrivateTrade.prototype.side = 0;
        /**
         * PrivateTrade id.
         * @member {number|Long} id
         * @memberof ProtobufBroker.PrivateTrade
         * @instance
         */
        PrivateTrade.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * Creates a new PrivateTrade instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.PrivateTrade
         * @static
         * @param {ProtobufBroker.IPrivateTrade=} [properties] Properties to set
         * @returns {ProtobufBroker.PrivateTrade} PrivateTrade instance
         */
        PrivateTrade.create = function create(properties) {
            return new PrivateTrade(properties);
        };
        /**
         * Encodes the specified PrivateTrade message. Does not implicitly {@link ProtobufBroker.PrivateTrade.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.PrivateTrade
         * @static
         * @param {ProtobufBroker.IPrivateTrade} message PrivateTrade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivateTrade.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.id);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.time);
            if (message.side != null && Object.hasOwnProperty.call(message, "side"))
                writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.side);
            if (message.timeMillis != null && Object.hasOwnProperty.call(message, "timeMillis"))
                writer.uint32(/* id 6, wireType 0 =*/ 48).int64(message.timeMillis);
            if (message.externalId != null && Object.hasOwnProperty.call(message, "externalId"))
                writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.externalId);
            if (message.orderId != null && Object.hasOwnProperty.call(message, "orderId"))
                writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.orderId);
            if (message.priceString != null && Object.hasOwnProperty.call(message, "priceString"))
                writer.uint32(/* id 9, wireType 2 =*/ 74).string(message.priceString);
            if (message.amountString != null && Object.hasOwnProperty.call(message, "amountString"))
                writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.amountString);
            return writer;
        };
        /**
         * Encodes the specified PrivateTrade message, length delimited. Does not implicitly {@link ProtobufBroker.PrivateTrade.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.PrivateTrade
         * @static
         * @param {ProtobufBroker.IPrivateTrade} message PrivateTrade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivateTrade.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PrivateTrade message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.PrivateTrade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.PrivateTrade} PrivateTrade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivateTrade.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.PrivateTrade();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 7:
                        message.externalId = reader.string();
                        break;
                    case 8:
                        message.orderId = reader.string();
                        break;
                    case 2:
                        message.time = reader.int64();
                        break;
                    case 6:
                        message.timeMillis = reader.int64();
                        break;
                    case 9:
                        message.priceString = reader.string();
                        break;
                    case 10:
                        message.amountString = reader.string();
                        break;
                    case 5:
                        message.side = reader.int32();
                        break;
                    case 1:
                        message.id = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PrivateTrade message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.PrivateTrade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.PrivateTrade} PrivateTrade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivateTrade.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PrivateTrade message.
         * @function verify
         * @memberof ProtobufBroker.PrivateTrade
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrivateTrade.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.externalId != null && message.hasOwnProperty("externalId"))
                if (!$util.isString(message.externalId))
                    return "externalId: string expected";
            if (message.orderId != null && message.hasOwnProperty("orderId"))
                if (!$util.isString(message.orderId))
                    return "orderId: string expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            if (message.timeMillis != null && message.hasOwnProperty("timeMillis"))
                if (!$util.isInteger(message.timeMillis) && !(message.timeMillis && $util.isInteger(message.timeMillis.low) && $util.isInteger(message.timeMillis.high)))
                    return "timeMillis: integer|Long expected";
            if (message.priceString != null && message.hasOwnProperty("priceString"))
                if (!$util.isString(message.priceString))
                    return "priceString: string expected";
            if (message.amountString != null && message.hasOwnProperty("amountString"))
                if (!$util.isString(message.amountString))
                    return "amountString: string expected";
            if (message.side != null && message.hasOwnProperty("side"))
                if (!$util.isInteger(message.side))
                    return "side: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };
        /**
         * Creates a PrivateTrade message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.PrivateTrade
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.PrivateTrade} PrivateTrade
         */
        PrivateTrade.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.PrivateTrade)
                return object;
            var message = new $root.ProtobufBroker.PrivateTrade();
            if (object.externalId != null)
                message.externalId = String(object.externalId);
            if (object.orderId != null)
                message.orderId = String(object.orderId);
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            if (object.timeMillis != null)
                if ($util.Long)
                    (message.timeMillis = $util.Long.fromValue(object.timeMillis)).unsigned = false;
                else if (typeof object.timeMillis === "string")
                    message.timeMillis = parseInt(object.timeMillis, 10);
                else if (typeof object.timeMillis === "number")
                    message.timeMillis = object.timeMillis;
                else if (typeof object.timeMillis === "object")
                    message.timeMillis = new $util.LongBits(object.timeMillis.low >>> 0, object.timeMillis.high >>> 0).toNumber();
            if (object.priceString != null)
                message.priceString = String(object.priceString);
            if (object.amountString != null)
                message.amountString = String(object.amountString);
            if (object.side != null)
                message.side = object.side | 0;
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            return message;
        };
        /**
         * Creates a plain object from a PrivateTrade message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.PrivateTrade
         * @static
         * @param {ProtobufBroker.PrivateTrade} message PrivateTrade
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PrivateTrade.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.id = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.time = options.longs === String ? "0" : 0;
                object.side = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timeMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.timeMillis = options.longs === String ? "0" : 0;
                object.externalId = "";
                object.orderId = "";
                object.priceString = "";
                object.amountString = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            if (message.side != null && message.hasOwnProperty("side"))
                object.side = message.side;
            if (message.timeMillis != null && message.hasOwnProperty("timeMillis"))
                if (typeof message.timeMillis === "number")
                    object.timeMillis = options.longs === String ? String(message.timeMillis) : message.timeMillis;
                else
                    object.timeMillis = options.longs === String ? $util.Long.prototype.toString.call(message.timeMillis) : options.longs === Number ? new $util.LongBits(message.timeMillis.low >>> 0, message.timeMillis.high >>> 0).toNumber() : message.timeMillis;
            if (message.externalId != null && message.hasOwnProperty("externalId"))
                object.externalId = message.externalId;
            if (message.orderId != null && message.hasOwnProperty("orderId"))
                object.orderId = message.orderId;
            if (message.priceString != null && message.hasOwnProperty("priceString"))
                object.priceString = message.priceString;
            if (message.amountString != null && message.hasOwnProperty("amountString"))
                object.amountString = message.amountString;
            return object;
        };
        /**
         * Converts this PrivateTrade to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.PrivateTrade
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PrivateTrade.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PrivateTrade;
    })();
    ProtobufBroker.PrivatePosition = (function () {
        /**
         * Properties of a PrivatePosition.
         * @memberof ProtobufBroker
         * @interface IPrivatePosition
         * @property {string|null} [id] PrivatePosition id
         * @property {number|Long|null} [time] PrivatePosition time
         * @property {number|null} [side] PrivatePosition side
         * @property {string|null} [avgPriceString] PrivatePosition avgPriceString
         * @property {string|null} [amountOpenString] PrivatePosition amountOpenString
         * @property {string|null} [amountClosedString] PrivatePosition amountClosedString
         * @property {string|null} [profitLoss] PrivatePosition profitLoss
         * @property {Array.<string>|null} [orderIds] PrivatePosition orderIds
         * @property {Array.<string>|null} [tradeIds] PrivatePosition tradeIds
         */
        /**
         * Constructs a new PrivatePosition.
         * @memberof ProtobufBroker
         * @classdesc Represents a PrivatePosition.
         * @implements IPrivatePosition
         * @constructor
         * @param {ProtobufBroker.IPrivatePosition=} [properties] Properties to set
         */
        function PrivatePosition(properties) {
            this.orderIds = [];
            this.tradeIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PrivatePosition id.
         * @member {string} id
         * @memberof ProtobufBroker.PrivatePosition
         * @instance
         */
        PrivatePosition.prototype.id = "";
        /**
         * PrivatePosition time.
         * @member {number|Long} time
         * @memberof ProtobufBroker.PrivatePosition
         * @instance
         */
        PrivatePosition.prototype.time = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * PrivatePosition side.
         * @member {number} side
         * @memberof ProtobufBroker.PrivatePosition
         * @instance
         */
        PrivatePosition.prototype.side = 0;
        /**
         * PrivatePosition avgPriceString.
         * @member {string} avgPriceString
         * @memberof ProtobufBroker.PrivatePosition
         * @instance
         */
        PrivatePosition.prototype.avgPriceString = "";
        /**
         * PrivatePosition amountOpenString.
         * @member {string} amountOpenString
         * @memberof ProtobufBroker.PrivatePosition
         * @instance
         */
        PrivatePosition.prototype.amountOpenString = "";
        /**
         * PrivatePosition amountClosedString.
         * @member {string} amountClosedString
         * @memberof ProtobufBroker.PrivatePosition
         * @instance
         */
        PrivatePosition.prototype.amountClosedString = "";
        /**
         * PrivatePosition profitLoss.
         * @member {string} profitLoss
         * @memberof ProtobufBroker.PrivatePosition
         * @instance
         */
        PrivatePosition.prototype.profitLoss = "";
        /**
         * PrivatePosition orderIds.
         * @member {Array.<string>} orderIds
         * @memberof ProtobufBroker.PrivatePosition
         * @instance
         */
        PrivatePosition.prototype.orderIds = $util.emptyArray;
        /**
         * PrivatePosition tradeIds.
         * @member {Array.<string>} tradeIds
         * @memberof ProtobufBroker.PrivatePosition
         * @instance
         */
        PrivatePosition.prototype.tradeIds = $util.emptyArray;
        /**
         * Creates a new PrivatePosition instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.PrivatePosition
         * @static
         * @param {ProtobufBroker.IPrivatePosition=} [properties] Properties to set
         * @returns {ProtobufBroker.PrivatePosition} PrivatePosition instance
         */
        PrivatePosition.create = function create(properties) {
            return new PrivatePosition(properties);
        };
        /**
         * Encodes the specified PrivatePosition message. Does not implicitly {@link ProtobufBroker.PrivatePosition.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.PrivatePosition
         * @static
         * @param {ProtobufBroker.IPrivatePosition} message PrivatePosition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivatePosition.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.time);
            if (message.side != null && Object.hasOwnProperty.call(message, "side"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.side);
            if (message.orderIds != null && message.orderIds.length)
                for (var i = 0; i < message.orderIds.length; ++i)
                    writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.orderIds[i]);
            if (message.tradeIds != null && message.tradeIds.length)
                for (var i = 0; i < message.tradeIds.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.tradeIds[i]);
            if (message.avgPriceString != null && Object.hasOwnProperty.call(message, "avgPriceString"))
                writer.uint32(/* id 9, wireType 2 =*/ 74).string(message.avgPriceString);
            if (message.amountOpenString != null && Object.hasOwnProperty.call(message, "amountOpenString"))
                writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.amountOpenString);
            if (message.amountClosedString != null && Object.hasOwnProperty.call(message, "amountClosedString"))
                writer.uint32(/* id 11, wireType 2 =*/ 90).string(message.amountClosedString);
            if (message.profitLoss != null && Object.hasOwnProperty.call(message, "profitLoss"))
                writer.uint32(/* id 12, wireType 2 =*/ 98).string(message.profitLoss);
            return writer;
        };
        /**
         * Encodes the specified PrivatePosition message, length delimited. Does not implicitly {@link ProtobufBroker.PrivatePosition.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.PrivatePosition
         * @static
         * @param {ProtobufBroker.IPrivatePosition} message PrivatePosition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivatePosition.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PrivatePosition message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.PrivatePosition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.PrivatePosition} PrivatePosition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivatePosition.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.PrivatePosition();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.time = reader.int64();
                        break;
                    case 3:
                        message.side = reader.int32();
                        break;
                    case 9:
                        message.avgPriceString = reader.string();
                        break;
                    case 10:
                        message.amountOpenString = reader.string();
                        break;
                    case 11:
                        message.amountClosedString = reader.string();
                        break;
                    case 12:
                        message.profitLoss = reader.string();
                        break;
                    case 7:
                        if (!(message.orderIds && message.orderIds.length))
                            message.orderIds = [];
                        message.orderIds.push(reader.string());
                        break;
                    case 8:
                        if (!(message.tradeIds && message.tradeIds.length))
                            message.tradeIds = [];
                        message.tradeIds.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PrivatePosition message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.PrivatePosition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.PrivatePosition} PrivatePosition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivatePosition.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PrivatePosition message.
         * @function verify
         * @memberof ProtobufBroker.PrivatePosition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrivatePosition.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            if (message.side != null && message.hasOwnProperty("side"))
                if (!$util.isInteger(message.side))
                    return "side: integer expected";
            if (message.avgPriceString != null && message.hasOwnProperty("avgPriceString"))
                if (!$util.isString(message.avgPriceString))
                    return "avgPriceString: string expected";
            if (message.amountOpenString != null && message.hasOwnProperty("amountOpenString"))
                if (!$util.isString(message.amountOpenString))
                    return "amountOpenString: string expected";
            if (message.amountClosedString != null && message.hasOwnProperty("amountClosedString"))
                if (!$util.isString(message.amountClosedString))
                    return "amountClosedString: string expected";
            if (message.profitLoss != null && message.hasOwnProperty("profitLoss"))
                if (!$util.isString(message.profitLoss))
                    return "profitLoss: string expected";
            if (message.orderIds != null && message.hasOwnProperty("orderIds")) {
                if (!Array.isArray(message.orderIds))
                    return "orderIds: array expected";
                for (var i = 0; i < message.orderIds.length; ++i)
                    if (!$util.isString(message.orderIds[i]))
                        return "orderIds: string[] expected";
            }
            if (message.tradeIds != null && message.hasOwnProperty("tradeIds")) {
                if (!Array.isArray(message.tradeIds))
                    return "tradeIds: array expected";
                for (var i = 0; i < message.tradeIds.length; ++i)
                    if (!$util.isString(message.tradeIds[i]))
                        return "tradeIds: string[] expected";
            }
            return null;
        };
        /**
         * Creates a PrivatePosition message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.PrivatePosition
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.PrivatePosition} PrivatePosition
         */
        PrivatePosition.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.PrivatePosition)
                return object;
            var message = new $root.ProtobufBroker.PrivatePosition();
            if (object.id != null)
                message.id = String(object.id);
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            if (object.side != null)
                message.side = object.side | 0;
            if (object.avgPriceString != null)
                message.avgPriceString = String(object.avgPriceString);
            if (object.amountOpenString != null)
                message.amountOpenString = String(object.amountOpenString);
            if (object.amountClosedString != null)
                message.amountClosedString = String(object.amountClosedString);
            if (object.profitLoss != null)
                message.profitLoss = String(object.profitLoss);
            if (object.orderIds) {
                if (!Array.isArray(object.orderIds))
                    throw TypeError(".ProtobufBroker.PrivatePosition.orderIds: array expected");
                message.orderIds = [];
                for (var i = 0; i < object.orderIds.length; ++i)
                    message.orderIds[i] = String(object.orderIds[i]);
            }
            if (object.tradeIds) {
                if (!Array.isArray(object.tradeIds))
                    throw TypeError(".ProtobufBroker.PrivatePosition.tradeIds: array expected");
                message.tradeIds = [];
                for (var i = 0; i < object.tradeIds.length; ++i)
                    message.tradeIds[i] = String(object.tradeIds[i]);
            }
            return message;
        };
        /**
         * Creates a plain object from a PrivatePosition message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.PrivatePosition
         * @static
         * @param {ProtobufBroker.PrivatePosition} message PrivatePosition
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PrivatePosition.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.orderIds = [];
                object.tradeIds = [];
            }
            if (options.defaults) {
                object.id = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.time = options.longs === String ? "0" : 0;
                object.side = 0;
                object.avgPriceString = "";
                object.amountOpenString = "";
                object.amountClosedString = "";
                object.profitLoss = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            if (message.side != null && message.hasOwnProperty("side"))
                object.side = message.side;
            if (message.orderIds && message.orderIds.length) {
                object.orderIds = [];
                for (var j = 0; j < message.orderIds.length; ++j)
                    object.orderIds[j] = message.orderIds[j];
            }
            if (message.tradeIds && message.tradeIds.length) {
                object.tradeIds = [];
                for (var j = 0; j < message.tradeIds.length; ++j)
                    object.tradeIds[j] = message.tradeIds[j];
            }
            if (message.avgPriceString != null && message.hasOwnProperty("avgPriceString"))
                object.avgPriceString = message.avgPriceString;
            if (message.amountOpenString != null && message.hasOwnProperty("amountOpenString"))
                object.amountOpenString = message.amountOpenString;
            if (message.amountClosedString != null && message.hasOwnProperty("amountClosedString"))
                object.amountClosedString = message.amountClosedString;
            if (message.profitLoss != null && message.hasOwnProperty("profitLoss"))
                object.profitLoss = message.profitLoss;
            return object;
        };
        /**
         * Converts this PrivatePosition to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.PrivatePosition
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PrivatePosition.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PrivatePosition;
    })();
    ProtobufBroker.Balance = (function () {
        /**
         * Properties of a Balance.
         * @memberof ProtobufBroker
         * @interface IBalance
         * @property {string|null} [currency] Balance currency
         * @property {string|null} [amountString] Balance amountString
         */
        /**
         * Constructs a new Balance.
         * @memberof ProtobufBroker
         * @classdesc Represents a Balance.
         * @implements IBalance
         * @constructor
         * @param {ProtobufBroker.IBalance=} [properties] Properties to set
         */
        function Balance(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Balance currency.
         * @member {string} currency
         * @memberof ProtobufBroker.Balance
         * @instance
         */
        Balance.prototype.currency = "";
        /**
         * Balance amountString.
         * @member {string} amountString
         * @memberof ProtobufBroker.Balance
         * @instance
         */
        Balance.prototype.amountString = "";
        /**
         * Creates a new Balance instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.Balance
         * @static
         * @param {ProtobufBroker.IBalance=} [properties] Properties to set
         * @returns {ProtobufBroker.Balance} Balance instance
         */
        Balance.create = function create(properties) {
            return new Balance(properties);
        };
        /**
         * Encodes the specified Balance message. Does not implicitly {@link ProtobufBroker.Balance.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.Balance
         * @static
         * @param {ProtobufBroker.IBalance} message Balance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Balance.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currency != null && Object.hasOwnProperty.call(message, "currency"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.currency);
            if (message.amountString != null && Object.hasOwnProperty.call(message, "amountString"))
                writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.amountString);
            return writer;
        };
        /**
         * Encodes the specified Balance message, length delimited. Does not implicitly {@link ProtobufBroker.Balance.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.Balance
         * @static
         * @param {ProtobufBroker.IBalance} message Balance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Balance.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a Balance message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.Balance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.Balance} Balance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Balance.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.Balance();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.currency = reader.string();
                        break;
                    case 3:
                        message.amountString = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a Balance message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.Balance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.Balance} Balance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Balance.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a Balance message.
         * @function verify
         * @memberof ProtobufBroker.Balance
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Balance.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currency != null && message.hasOwnProperty("currency"))
                if (!$util.isString(message.currency))
                    return "currency: string expected";
            if (message.amountString != null && message.hasOwnProperty("amountString"))
                if (!$util.isString(message.amountString))
                    return "amountString: string expected";
            return null;
        };
        /**
         * Creates a Balance message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.Balance
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.Balance} Balance
         */
        Balance.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.Balance)
                return object;
            var message = new $root.ProtobufBroker.Balance();
            if (object.currency != null)
                message.currency = String(object.currency);
            if (object.amountString != null)
                message.amountString = String(object.amountString);
            return message;
        };
        /**
         * Creates a plain object from a Balance message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.Balance
         * @static
         * @param {ProtobufBroker.Balance} message Balance
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Balance.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.currency = "";
                object.amountString = "";
            }
            if (message.currency != null && message.hasOwnProperty("currency"))
                object.currency = message.currency;
            if (message.amountString != null && message.hasOwnProperty("amountString"))
                object.amountString = message.amountString;
            return object;
        };
        /**
         * Converts this Balance to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.Balance
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Balance.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Balance;
    })();
    ProtobufBroker.Balances = (function () {
        /**
         * Properties of a Balances.
         * @memberof ProtobufBroker
         * @interface IBalances
         * @property {ProtobufBroker.FundingType|null} [fundingType] Balances fundingType
         * @property {Array.<ProtobufBroker.IBalance>|null} [balances] Balances balances
         */
        /**
         * Constructs a new Balances.
         * @memberof ProtobufBroker
         * @classdesc Represents a Balances.
         * @implements IBalances
         * @constructor
         * @param {ProtobufBroker.IBalances=} [properties] Properties to set
         */
        function Balances(properties) {
            this.balances = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Balances fundingType.
         * @member {ProtobufBroker.FundingType} fundingType
         * @memberof ProtobufBroker.Balances
         * @instance
         */
        Balances.prototype.fundingType = 0;
        /**
         * Balances balances.
         * @member {Array.<ProtobufBroker.IBalance>} balances
         * @memberof ProtobufBroker.Balances
         * @instance
         */
        Balances.prototype.balances = $util.emptyArray;
        /**
         * Creates a new Balances instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.Balances
         * @static
         * @param {ProtobufBroker.IBalances=} [properties] Properties to set
         * @returns {ProtobufBroker.Balances} Balances instance
         */
        Balances.create = function create(properties) {
            return new Balances(properties);
        };
        /**
         * Encodes the specified Balances message. Does not implicitly {@link ProtobufBroker.Balances.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.Balances
         * @static
         * @param {ProtobufBroker.IBalances} message Balances message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Balances.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fundingType != null && Object.hasOwnProperty.call(message, "fundingType"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.fundingType);
            if (message.balances != null && message.balances.length)
                for (var i = 0; i < message.balances.length; ++i)
                    $root.ProtobufBroker.Balance.encode(message.balances[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified Balances message, length delimited. Does not implicitly {@link ProtobufBroker.Balances.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.Balances
         * @static
         * @param {ProtobufBroker.IBalances} message Balances message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Balances.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a Balances message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.Balances
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.Balances} Balances
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Balances.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.Balances();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.fundingType = reader.int32();
                        break;
                    case 2:
                        if (!(message.balances && message.balances.length))
                            message.balances = [];
                        message.balances.push($root.ProtobufBroker.Balance.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a Balances message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.Balances
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.Balances} Balances
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Balances.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a Balances message.
         * @function verify
         * @memberof ProtobufBroker.Balances
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Balances.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fundingType != null && message.hasOwnProperty("fundingType"))
                switch (message.fundingType) {
                    default:
                        return "fundingType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                }
            if (message.balances != null && message.hasOwnProperty("balances")) {
                if (!Array.isArray(message.balances))
                    return "balances: array expected";
                for (var i = 0; i < message.balances.length; ++i) {
                    var error = $root.ProtobufBroker.Balance.verify(message.balances[i]);
                    if (error)
                        return "balances." + error;
                }
            }
            return null;
        };
        /**
         * Creates a Balances message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.Balances
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.Balances} Balances
         */
        Balances.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.Balances)
                return object;
            var message = new $root.ProtobufBroker.Balances();
            switch (object.fundingType) {
                case "Spot":
                case 0:
                    message.fundingType = 0;
                    break;
                case "Margin":
                case 1:
                    message.fundingType = 1;
                    break;
                case "Staking":
                case 2:
                    message.fundingType = 2;
                    break;
            }
            if (object.balances) {
                if (!Array.isArray(object.balances))
                    throw TypeError(".ProtobufBroker.Balances.balances: array expected");
                message.balances = [];
                for (var i = 0; i < object.balances.length; ++i) {
                    if (typeof object.balances[i] !== "object")
                        throw TypeError(".ProtobufBroker.Balances.balances: object expected");
                    message.balances[i] = $root.ProtobufBroker.Balance.fromObject(object.balances[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a Balances message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.Balances
         * @static
         * @param {ProtobufBroker.Balances} message Balances
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Balances.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.balances = [];
            if (options.defaults)
                object.fundingType = options.enums === String ? "Spot" : 0;
            if (message.fundingType != null && message.hasOwnProperty("fundingType"))
                object.fundingType = options.enums === String ? $root.ProtobufBroker.FundingType[message.fundingType] : message.fundingType;
            if (message.balances && message.balances.length) {
                object.balances = [];
                for (var j = 0; j < message.balances.length; ++j)
                    object.balances[j] = $root.ProtobufBroker.Balance.toObject(message.balances[j], options);
            }
            return object;
        };
        /**
         * Converts this Balances to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.Balances
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Balances.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Balances;
    })();
    ProtobufBroker.PrivateLedger = (function () {
        /**
         * Properties of a PrivateLedger.
         * @memberof ProtobufBroker
         * @interface IPrivateLedger
         * @property {string|null} [externalId] PrivateLedger externalId
         * @property {google.protobuf.ITimestamp|null} [time] PrivateLedger time
         * @property {ProtobufBroker.PrivateLedger.Type|null} [type] PrivateLedger type
         * @property {string|null} [symbol] PrivateLedger symbol
         * @property {string|null} [amountString] PrivateLedger amountString
         * @property {string|null} [feeAmountString] PrivateLedger feeAmountString
         * @property {string|null} [balanceString] PrivateLedger balanceString
         */
        /**
         * Constructs a new PrivateLedger.
         * @memberof ProtobufBroker
         * @classdesc Represents a PrivateLedger.
         * @implements IPrivateLedger
         * @constructor
         * @param {ProtobufBroker.IPrivateLedger=} [properties] Properties to set
         */
        function PrivateLedger(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PrivateLedger externalId.
         * @member {string} externalId
         * @memberof ProtobufBroker.PrivateLedger
         * @instance
         */
        PrivateLedger.prototype.externalId = "";
        /**
         * PrivateLedger time.
         * @member {google.protobuf.ITimestamp|null|undefined} time
         * @memberof ProtobufBroker.PrivateLedger
         * @instance
         */
        PrivateLedger.prototype.time = null;
        /**
         * PrivateLedger type.
         * @member {ProtobufBroker.PrivateLedger.Type} type
         * @memberof ProtobufBroker.PrivateLedger
         * @instance
         */
        PrivateLedger.prototype.type = 0;
        /**
         * PrivateLedger symbol.
         * @member {string} symbol
         * @memberof ProtobufBroker.PrivateLedger
         * @instance
         */
        PrivateLedger.prototype.symbol = "";
        /**
         * PrivateLedger amountString.
         * @member {string} amountString
         * @memberof ProtobufBroker.PrivateLedger
         * @instance
         */
        PrivateLedger.prototype.amountString = "";
        /**
         * PrivateLedger feeAmountString.
         * @member {string} feeAmountString
         * @memberof ProtobufBroker.PrivateLedger
         * @instance
         */
        PrivateLedger.prototype.feeAmountString = "";
        /**
         * PrivateLedger balanceString.
         * @member {string} balanceString
         * @memberof ProtobufBroker.PrivateLedger
         * @instance
         */
        PrivateLedger.prototype.balanceString = "";
        /**
         * Creates a new PrivateLedger instance using the specified properties.
         * @function create
         * @memberof ProtobufBroker.PrivateLedger
         * @static
         * @param {ProtobufBroker.IPrivateLedger=} [properties] Properties to set
         * @returns {ProtobufBroker.PrivateLedger} PrivateLedger instance
         */
        PrivateLedger.create = function create(properties) {
            return new PrivateLedger(properties);
        };
        /**
         * Encodes the specified PrivateLedger message. Does not implicitly {@link ProtobufBroker.PrivateLedger.verify|verify} messages.
         * @function encode
         * @memberof ProtobufBroker.PrivateLedger
         * @static
         * @param {ProtobufBroker.IPrivateLedger} message PrivateLedger message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivateLedger.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.externalId != null && Object.hasOwnProperty.call(message, "externalId"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.externalId);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                $root.google.protobuf.Timestamp.encode(message.time, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.type);
            if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.symbol);
            if (message.amountString != null && Object.hasOwnProperty.call(message, "amountString"))
                writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.amountString);
            if (message.feeAmountString != null && Object.hasOwnProperty.call(message, "feeAmountString"))
                writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.feeAmountString);
            if (message.balanceString != null && Object.hasOwnProperty.call(message, "balanceString"))
                writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.balanceString);
            return writer;
        };
        /**
         * Encodes the specified PrivateLedger message, length delimited. Does not implicitly {@link ProtobufBroker.PrivateLedger.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufBroker.PrivateLedger
         * @static
         * @param {ProtobufBroker.IPrivateLedger} message PrivateLedger message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivateLedger.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PrivateLedger message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufBroker.PrivateLedger
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufBroker.PrivateLedger} PrivateLedger
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivateLedger.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufBroker.PrivateLedger();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.externalId = reader.string();
                        break;
                    case 2:
                        message.time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.type = reader.int32();
                        break;
                    case 4:
                        message.symbol = reader.string();
                        break;
                    case 5:
                        message.amountString = reader.string();
                        break;
                    case 6:
                        message.feeAmountString = reader.string();
                        break;
                    case 7:
                        message.balanceString = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PrivateLedger message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufBroker.PrivateLedger
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufBroker.PrivateLedger} PrivateLedger
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivateLedger.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PrivateLedger message.
         * @function verify
         * @memberof ProtobufBroker.PrivateLedger
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrivateLedger.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.externalId != null && message.hasOwnProperty("externalId"))
                if (!$util.isString(message.externalId))
                    return "externalId: string expected";
            if (message.time != null && message.hasOwnProperty("time")) {
                var error = $root.google.protobuf.Timestamp.verify(message.time);
                if (error)
                    return "time." + error;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                }
            if (message.symbol != null && message.hasOwnProperty("symbol"))
                if (!$util.isString(message.symbol))
                    return "symbol: string expected";
            if (message.amountString != null && message.hasOwnProperty("amountString"))
                if (!$util.isString(message.amountString))
                    return "amountString: string expected";
            if (message.feeAmountString != null && message.hasOwnProperty("feeAmountString"))
                if (!$util.isString(message.feeAmountString))
                    return "feeAmountString: string expected";
            if (message.balanceString != null && message.hasOwnProperty("balanceString"))
                if (!$util.isString(message.balanceString))
                    return "balanceString: string expected";
            return null;
        };
        /**
         * Creates a PrivateLedger message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufBroker.PrivateLedger
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufBroker.PrivateLedger} PrivateLedger
         */
        PrivateLedger.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufBroker.PrivateLedger)
                return object;
            var message = new $root.ProtobufBroker.PrivateLedger();
            if (object.externalId != null)
                message.externalId = String(object.externalId);
            if (object.time != null) {
                if (typeof object.time !== "object")
                    throw TypeError(".ProtobufBroker.PrivateLedger.time: object expected");
                message.time = $root.google.protobuf.Timestamp.fromObject(object.time);
            }
            switch (object.type) {
                case "All":
                case 0:
                    message.type = 0;
                    break;
                case "Deposit":
                case 1:
                    message.type = 1;
                    break;
                case "Withdrawal":
                case 2:
                    message.type = 2;
                    break;
                case "Trade":
                case 3:
                    message.type = 3;
                    break;
                case "Margin":
                case 4:
                    message.type = 4;
                    break;
                case "Spend":
                case 5:
                    message.type = 5;
                    break;
                case "Receive":
                case 6:
                    message.type = 6;
                    break;
            }
            if (object.symbol != null)
                message.symbol = String(object.symbol);
            if (object.amountString != null)
                message.amountString = String(object.amountString);
            if (object.feeAmountString != null)
                message.feeAmountString = String(object.feeAmountString);
            if (object.balanceString != null)
                message.balanceString = String(object.balanceString);
            return message;
        };
        /**
         * Creates a plain object from a PrivateLedger message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufBroker.PrivateLedger
         * @static
         * @param {ProtobufBroker.PrivateLedger} message PrivateLedger
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PrivateLedger.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.externalId = "";
                object.time = null;
                object.type = options.enums === String ? "All" : 0;
                object.symbol = "";
                object.amountString = "";
                object.feeAmountString = "";
                object.balanceString = "";
            }
            if (message.externalId != null && message.hasOwnProperty("externalId"))
                object.externalId = message.externalId;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = $root.google.protobuf.Timestamp.toObject(message.time, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ProtobufBroker.PrivateLedger.Type[message.type] : message.type;
            if (message.symbol != null && message.hasOwnProperty("symbol"))
                object.symbol = message.symbol;
            if (message.amountString != null && message.hasOwnProperty("amountString"))
                object.amountString = message.amountString;
            if (message.feeAmountString != null && message.hasOwnProperty("feeAmountString"))
                object.feeAmountString = message.feeAmountString;
            if (message.balanceString != null && message.hasOwnProperty("balanceString"))
                object.balanceString = message.balanceString;
            return object;
        };
        /**
         * Converts this PrivateLedger to JSON.
         * @function toJSON
         * @memberof ProtobufBroker.PrivateLedger
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PrivateLedger.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Type enum.
         * @name ProtobufBroker.PrivateLedger.Type
         * @enum {number}
         * @property {number} All=0 All value
         * @property {number} Deposit=1 Deposit value
         * @property {number} Withdrawal=2 Withdrawal value
         * @property {number} Trade=3 Trade value
         * @property {number} Margin=4 Margin value
         * @property {number} Spend=5 Spend value
         * @property {number} Receive=6 Receive value
         */
        PrivateLedger.Type = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "All"] = 0;
            values[valuesById[1] = "Deposit"] = 1;
            values[valuesById[2] = "Withdrawal"] = 2;
            values[valuesById[3] = "Trade"] = 3;
            values[valuesById[4] = "Margin"] = 4;
            values[valuesById[5] = "Spend"] = 5;
            values[valuesById[6] = "Receive"] = 6;
            return values;
        })();
        return PrivateLedger;
    })();
    return ProtobufBroker;
})();
$root.ProtobufClient = (function () {
    /**
     * Namespace ProtobufClient.
     * @exports ProtobufClient
     * @namespace
     */
    var ProtobufClient = {};
    ProtobufClient.ClientMessage = (function () {
        /**
         * Properties of a ClientMessage.
         * @memberof ProtobufClient
         * @interface IClientMessage
         * @property {ProtobufClient.IClientIdentificationMessage|null} [identification] ClientMessage identification
         * @property {ProtobufClient.IClientSubscribeMessage|null} [subscribe] ClientMessage subscribe
         * @property {ProtobufClient.IClientUnsubscribeMessage|null} [unsubscribe] ClientMessage unsubscribe
         * @property {ProtobufClient.IWebAuthenticationMessage|null} [webAuthentication] ClientMessage webAuthentication
         * @property {ProtobufClient.IAPIAuthenticationMessage|null} [apiAuthentication] ClientMessage apiAuthentication
         * @property {ProtobufClient.IClientSessionMessage|null} [clientSession] ClientMessage clientSession
         */
        /**
         * Constructs a new ClientMessage.
         * @memberof ProtobufClient
         * @classdesc Represents a ClientMessage.
         * @implements IClientMessage
         * @constructor
         * @param {ProtobufClient.IClientMessage=} [properties] Properties to set
         */
        function ClientMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ClientMessage identification.
         * @member {ProtobufClient.IClientIdentificationMessage|null|undefined} identification
         * @memberof ProtobufClient.ClientMessage
         * @instance
         */
        ClientMessage.prototype.identification = null;
        /**
         * ClientMessage subscribe.
         * @member {ProtobufClient.IClientSubscribeMessage|null|undefined} subscribe
         * @memberof ProtobufClient.ClientMessage
         * @instance
         */
        ClientMessage.prototype.subscribe = null;
        /**
         * ClientMessage unsubscribe.
         * @member {ProtobufClient.IClientUnsubscribeMessage|null|undefined} unsubscribe
         * @memberof ProtobufClient.ClientMessage
         * @instance
         */
        ClientMessage.prototype.unsubscribe = null;
        /**
         * ClientMessage webAuthentication.
         * @member {ProtobufClient.IWebAuthenticationMessage|null|undefined} webAuthentication
         * @memberof ProtobufClient.ClientMessage
         * @instance
         */
        ClientMessage.prototype.webAuthentication = null;
        /**
         * ClientMessage apiAuthentication.
         * @member {ProtobufClient.IAPIAuthenticationMessage|null|undefined} apiAuthentication
         * @memberof ProtobufClient.ClientMessage
         * @instance
         */
        ClientMessage.prototype.apiAuthentication = null;
        /**
         * ClientMessage clientSession.
         * @member {ProtobufClient.IClientSessionMessage|null|undefined} clientSession
         * @memberof ProtobufClient.ClientMessage
         * @instance
         */
        ClientMessage.prototype.clientSession = null;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * ClientMessage body.
         * @member {"identification"|"subscribe"|"unsubscribe"|"webAuthentication"|"apiAuthentication"|"clientSession"|undefined} body
         * @memberof ProtobufClient.ClientMessage
         * @instance
         */
        Object.defineProperty(ClientMessage.prototype, "body", {
            get: $util.oneOfGetter($oneOfFields = ["identification", "subscribe", "unsubscribe", "webAuthentication", "apiAuthentication", "clientSession"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new ClientMessage instance using the specified properties.
         * @function create
         * @memberof ProtobufClient.ClientMessage
         * @static
         * @param {ProtobufClient.IClientMessage=} [properties] Properties to set
         * @returns {ProtobufClient.ClientMessage} ClientMessage instance
         */
        ClientMessage.create = function create(properties) {
            return new ClientMessage(properties);
        };
        /**
         * Encodes the specified ClientMessage message. Does not implicitly {@link ProtobufClient.ClientMessage.verify|verify} messages.
         * @function encode
         * @memberof ProtobufClient.ClientMessage
         * @static
         * @param {ProtobufClient.IClientMessage} message ClientMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identification != null && Object.hasOwnProperty.call(message, "identification"))
                $root.ProtobufClient.ClientIdentificationMessage.encode(message.identification, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.subscribe != null && Object.hasOwnProperty.call(message, "subscribe"))
                $root.ProtobufClient.ClientSubscribeMessage.encode(message.subscribe, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.unsubscribe != null && Object.hasOwnProperty.call(message, "unsubscribe"))
                $root.ProtobufClient.ClientUnsubscribeMessage.encode(message.unsubscribe, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.webAuthentication != null && Object.hasOwnProperty.call(message, "webAuthentication"))
                $root.ProtobufClient.WebAuthenticationMessage.encode(message.webAuthentication, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            if (message.apiAuthentication != null && Object.hasOwnProperty.call(message, "apiAuthentication"))
                $root.ProtobufClient.APIAuthenticationMessage.encode(message.apiAuthentication, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
            if (message.clientSession != null && Object.hasOwnProperty.call(message, "clientSession"))
                $root.ProtobufClient.ClientSessionMessage.encode(message.clientSession, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified ClientMessage message, length delimited. Does not implicitly {@link ProtobufClient.ClientMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufClient.ClientMessage
         * @static
         * @param {ProtobufClient.IClientMessage} message ClientMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ClientMessage message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufClient.ClientMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufClient.ClientMessage} ClientMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufClient.ClientMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.identification = $root.ProtobufClient.ClientIdentificationMessage.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.subscribe = $root.ProtobufClient.ClientSubscribeMessage.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.unsubscribe = $root.ProtobufClient.ClientUnsubscribeMessage.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.webAuthentication = $root.ProtobufClient.WebAuthenticationMessage.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.apiAuthentication = $root.ProtobufClient.APIAuthenticationMessage.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.clientSession = $root.ProtobufClient.ClientSessionMessage.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ClientMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufClient.ClientMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufClient.ClientMessage} ClientMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ClientMessage message.
         * @function verify
         * @memberof ProtobufClient.ClientMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.identification != null && message.hasOwnProperty("identification")) {
                properties.body = 1;
                {
                    var error = $root.ProtobufClient.ClientIdentificationMessage.verify(message.identification);
                    if (error)
                        return "identification." + error;
                }
            }
            if (message.subscribe != null && message.hasOwnProperty("subscribe")) {
                if (properties.body === 1)
                    return "body: multiple values";
                properties.body = 1;
                {
                    var error = $root.ProtobufClient.ClientSubscribeMessage.verify(message.subscribe);
                    if (error)
                        return "subscribe." + error;
                }
            }
            if (message.unsubscribe != null && message.hasOwnProperty("unsubscribe")) {
                if (properties.body === 1)
                    return "body: multiple values";
                properties.body = 1;
                {
                    var error = $root.ProtobufClient.ClientUnsubscribeMessage.verify(message.unsubscribe);
                    if (error)
                        return "unsubscribe." + error;
                }
            }
            if (message.webAuthentication != null && message.hasOwnProperty("webAuthentication")) {
                if (properties.body === 1)
                    return "body: multiple values";
                properties.body = 1;
                {
                    var error = $root.ProtobufClient.WebAuthenticationMessage.verify(message.webAuthentication);
                    if (error)
                        return "webAuthentication." + error;
                }
            }
            if (message.apiAuthentication != null && message.hasOwnProperty("apiAuthentication")) {
                if (properties.body === 1)
                    return "body: multiple values";
                properties.body = 1;
                {
                    var error = $root.ProtobufClient.APIAuthenticationMessage.verify(message.apiAuthentication);
                    if (error)
                        return "apiAuthentication." + error;
                }
            }
            if (message.clientSession != null && message.hasOwnProperty("clientSession")) {
                if (properties.body === 1)
                    return "body: multiple values";
                properties.body = 1;
                {
                    var error = $root.ProtobufClient.ClientSessionMessage.verify(message.clientSession);
                    if (error)
                        return "clientSession." + error;
                }
            }
            return null;
        };
        /**
         * Creates a ClientMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufClient.ClientMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufClient.ClientMessage} ClientMessage
         */
        ClientMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufClient.ClientMessage)
                return object;
            var message = new $root.ProtobufClient.ClientMessage();
            if (object.identification != null) {
                if (typeof object.identification !== "object")
                    throw TypeError(".ProtobufClient.ClientMessage.identification: object expected");
                message.identification = $root.ProtobufClient.ClientIdentificationMessage.fromObject(object.identification);
            }
            if (object.subscribe != null) {
                if (typeof object.subscribe !== "object")
                    throw TypeError(".ProtobufClient.ClientMessage.subscribe: object expected");
                message.subscribe = $root.ProtobufClient.ClientSubscribeMessage.fromObject(object.subscribe);
            }
            if (object.unsubscribe != null) {
                if (typeof object.unsubscribe !== "object")
                    throw TypeError(".ProtobufClient.ClientMessage.unsubscribe: object expected");
                message.unsubscribe = $root.ProtobufClient.ClientUnsubscribeMessage.fromObject(object.unsubscribe);
            }
            if (object.webAuthentication != null) {
                if (typeof object.webAuthentication !== "object")
                    throw TypeError(".ProtobufClient.ClientMessage.webAuthentication: object expected");
                message.webAuthentication = $root.ProtobufClient.WebAuthenticationMessage.fromObject(object.webAuthentication);
            }
            if (object.apiAuthentication != null) {
                if (typeof object.apiAuthentication !== "object")
                    throw TypeError(".ProtobufClient.ClientMessage.apiAuthentication: object expected");
                message.apiAuthentication = $root.ProtobufClient.APIAuthenticationMessage.fromObject(object.apiAuthentication);
            }
            if (object.clientSession != null) {
                if (typeof object.clientSession !== "object")
                    throw TypeError(".ProtobufClient.ClientMessage.clientSession: object expected");
                message.clientSession = $root.ProtobufClient.ClientSessionMessage.fromObject(object.clientSession);
            }
            return message;
        };
        /**
         * Creates a plain object from a ClientMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufClient.ClientMessage
         * @static
         * @param {ProtobufClient.ClientMessage} message ClientMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.identification != null && message.hasOwnProperty("identification")) {
                object.identification = $root.ProtobufClient.ClientIdentificationMessage.toObject(message.identification, options);
                if (options.oneofs)
                    object.body = "identification";
            }
            if (message.subscribe != null && message.hasOwnProperty("subscribe")) {
                object.subscribe = $root.ProtobufClient.ClientSubscribeMessage.toObject(message.subscribe, options);
                if (options.oneofs)
                    object.body = "subscribe";
            }
            if (message.unsubscribe != null && message.hasOwnProperty("unsubscribe")) {
                object.unsubscribe = $root.ProtobufClient.ClientUnsubscribeMessage.toObject(message.unsubscribe, options);
                if (options.oneofs)
                    object.body = "unsubscribe";
            }
            if (message.webAuthentication != null && message.hasOwnProperty("webAuthentication")) {
                object.webAuthentication = $root.ProtobufClient.WebAuthenticationMessage.toObject(message.webAuthentication, options);
                if (options.oneofs)
                    object.body = "webAuthentication";
            }
            if (message.apiAuthentication != null && message.hasOwnProperty("apiAuthentication")) {
                object.apiAuthentication = $root.ProtobufClient.APIAuthenticationMessage.toObject(message.apiAuthentication, options);
                if (options.oneofs)
                    object.body = "apiAuthentication";
            }
            if (message.clientSession != null && message.hasOwnProperty("clientSession")) {
                object.clientSession = $root.ProtobufClient.ClientSessionMessage.toObject(message.clientSession, options);
                if (options.oneofs)
                    object.body = "clientSession";
            }
            return object;
        };
        /**
         * Converts this ClientMessage to JSON.
         * @function toJSON
         * @memberof ProtobufClient.ClientMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ClientMessage;
    })();
    ProtobufClient.ClientIdentificationMessage = (function () {
        /**
         * Properties of a ClientIdentificationMessage.
         * @memberof ProtobufClient
         * @interface IClientIdentificationMessage
         * @property {string|null} [useragent] ClientIdentificationMessage useragent
         * @property {string|null} [revision] ClientIdentificationMessage revision
         * @property {string|null} [integration] ClientIdentificationMessage integration
         * @property {string|null} [locale] ClientIdentificationMessage locale
         * @property {Array.<string>|null} [subscriptions] ClientIdentificationMessage subscriptions
         * @property {Array.<ProtobufClient.IClientSubscription>|null} [clientSubscriptions] ClientIdentificationMessage clientSubscriptions
         */
        /**
         * Constructs a new ClientIdentificationMessage.
         * @memberof ProtobufClient
         * @classdesc Represents a ClientIdentificationMessage.
         * @implements IClientIdentificationMessage
         * @constructor
         * @param {ProtobufClient.IClientIdentificationMessage=} [properties] Properties to set
         */
        function ClientIdentificationMessage(properties) {
            this.subscriptions = [];
            this.clientSubscriptions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ClientIdentificationMessage useragent.
         * @member {string} useragent
         * @memberof ProtobufClient.ClientIdentificationMessage
         * @instance
         */
        ClientIdentificationMessage.prototype.useragent = "";
        /**
         * ClientIdentificationMessage revision.
         * @member {string} revision
         * @memberof ProtobufClient.ClientIdentificationMessage
         * @instance
         */
        ClientIdentificationMessage.prototype.revision = "";
        /**
         * ClientIdentificationMessage integration.
         * @member {string} integration
         * @memberof ProtobufClient.ClientIdentificationMessage
         * @instance
         */
        ClientIdentificationMessage.prototype.integration = "";
        /**
         * ClientIdentificationMessage locale.
         * @member {string} locale
         * @memberof ProtobufClient.ClientIdentificationMessage
         * @instance
         */
        ClientIdentificationMessage.prototype.locale = "";
        /**
         * ClientIdentificationMessage subscriptions.
         * @member {Array.<string>} subscriptions
         * @memberof ProtobufClient.ClientIdentificationMessage
         * @instance
         */
        ClientIdentificationMessage.prototype.subscriptions = $util.emptyArray;
        /**
         * ClientIdentificationMessage clientSubscriptions.
         * @member {Array.<ProtobufClient.IClientSubscription>} clientSubscriptions
         * @memberof ProtobufClient.ClientIdentificationMessage
         * @instance
         */
        ClientIdentificationMessage.prototype.clientSubscriptions = $util.emptyArray;
        /**
         * Creates a new ClientIdentificationMessage instance using the specified properties.
         * @function create
         * @memberof ProtobufClient.ClientIdentificationMessage
         * @static
         * @param {ProtobufClient.IClientIdentificationMessage=} [properties] Properties to set
         * @returns {ProtobufClient.ClientIdentificationMessage} ClientIdentificationMessage instance
         */
        ClientIdentificationMessage.create = function create(properties) {
            return new ClientIdentificationMessage(properties);
        };
        /**
         * Encodes the specified ClientIdentificationMessage message. Does not implicitly {@link ProtobufClient.ClientIdentificationMessage.verify|verify} messages.
         * @function encode
         * @memberof ProtobufClient.ClientIdentificationMessage
         * @static
         * @param {ProtobufClient.IClientIdentificationMessage} message ClientIdentificationMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientIdentificationMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.useragent != null && Object.hasOwnProperty.call(message, "useragent"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.useragent);
            if (message.revision != null && Object.hasOwnProperty.call(message, "revision"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.revision);
            if (message.integration != null && Object.hasOwnProperty.call(message, "integration"))
                writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.integration);
            if (message.locale != null && Object.hasOwnProperty.call(message, "locale"))
                writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.locale);
            if (message.subscriptions != null && message.subscriptions.length)
                for (var i = 0; i < message.subscriptions.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.subscriptions[i]);
            if (message.clientSubscriptions != null && message.clientSubscriptions.length)
                for (var i = 0; i < message.clientSubscriptions.length; ++i)
                    $root.ProtobufClient.ClientSubscription.encode(message.clientSubscriptions[i], writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified ClientIdentificationMessage message, length delimited. Does not implicitly {@link ProtobufClient.ClientIdentificationMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufClient.ClientIdentificationMessage
         * @static
         * @param {ProtobufClient.IClientIdentificationMessage} message ClientIdentificationMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientIdentificationMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ClientIdentificationMessage message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufClient.ClientIdentificationMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufClient.ClientIdentificationMessage} ClientIdentificationMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientIdentificationMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufClient.ClientIdentificationMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.useragent = reader.string();
                        break;
                    case 2:
                        message.revision = reader.string();
                        break;
                    case 3:
                        message.integration = reader.string();
                        break;
                    case 4:
                        message.locale = reader.string();
                        break;
                    case 5:
                        if (!(message.subscriptions && message.subscriptions.length))
                            message.subscriptions = [];
                        message.subscriptions.push(reader.string());
                        break;
                    case 6:
                        if (!(message.clientSubscriptions && message.clientSubscriptions.length))
                            message.clientSubscriptions = [];
                        message.clientSubscriptions.push($root.ProtobufClient.ClientSubscription.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ClientIdentificationMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufClient.ClientIdentificationMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufClient.ClientIdentificationMessage} ClientIdentificationMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientIdentificationMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ClientIdentificationMessage message.
         * @function verify
         * @memberof ProtobufClient.ClientIdentificationMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientIdentificationMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.useragent != null && message.hasOwnProperty("useragent"))
                if (!$util.isString(message.useragent))
                    return "useragent: string expected";
            if (message.revision != null && message.hasOwnProperty("revision"))
                if (!$util.isString(message.revision))
                    return "revision: string expected";
            if (message.integration != null && message.hasOwnProperty("integration"))
                if (!$util.isString(message.integration))
                    return "integration: string expected";
            if (message.locale != null && message.hasOwnProperty("locale"))
                if (!$util.isString(message.locale))
                    return "locale: string expected";
            if (message.subscriptions != null && message.hasOwnProperty("subscriptions")) {
                if (!Array.isArray(message.subscriptions))
                    return "subscriptions: array expected";
                for (var i = 0; i < message.subscriptions.length; ++i)
                    if (!$util.isString(message.subscriptions[i]))
                        return "subscriptions: string[] expected";
            }
            if (message.clientSubscriptions != null && message.hasOwnProperty("clientSubscriptions")) {
                if (!Array.isArray(message.clientSubscriptions))
                    return "clientSubscriptions: array expected";
                for (var i = 0; i < message.clientSubscriptions.length; ++i) {
                    var error = $root.ProtobufClient.ClientSubscription.verify(message.clientSubscriptions[i]);
                    if (error)
                        return "clientSubscriptions." + error;
                }
            }
            return null;
        };
        /**
         * Creates a ClientIdentificationMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufClient.ClientIdentificationMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufClient.ClientIdentificationMessage} ClientIdentificationMessage
         */
        ClientIdentificationMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufClient.ClientIdentificationMessage)
                return object;
            var message = new $root.ProtobufClient.ClientIdentificationMessage();
            if (object.useragent != null)
                message.useragent = String(object.useragent);
            if (object.revision != null)
                message.revision = String(object.revision);
            if (object.integration != null)
                message.integration = String(object.integration);
            if (object.locale != null)
                message.locale = String(object.locale);
            if (object.subscriptions) {
                if (!Array.isArray(object.subscriptions))
                    throw TypeError(".ProtobufClient.ClientIdentificationMessage.subscriptions: array expected");
                message.subscriptions = [];
                for (var i = 0; i < object.subscriptions.length; ++i)
                    message.subscriptions[i] = String(object.subscriptions[i]);
            }
            if (object.clientSubscriptions) {
                if (!Array.isArray(object.clientSubscriptions))
                    throw TypeError(".ProtobufClient.ClientIdentificationMessage.clientSubscriptions: array expected");
                message.clientSubscriptions = [];
                for (var i = 0; i < object.clientSubscriptions.length; ++i) {
                    if (typeof object.clientSubscriptions[i] !== "object")
                        throw TypeError(".ProtobufClient.ClientIdentificationMessage.clientSubscriptions: object expected");
                    message.clientSubscriptions[i] = $root.ProtobufClient.ClientSubscription.fromObject(object.clientSubscriptions[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a ClientIdentificationMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufClient.ClientIdentificationMessage
         * @static
         * @param {ProtobufClient.ClientIdentificationMessage} message ClientIdentificationMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientIdentificationMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.subscriptions = [];
                object.clientSubscriptions = [];
            }
            if (options.defaults) {
                object.useragent = "";
                object.revision = "";
                object.integration = "";
                object.locale = "";
            }
            if (message.useragent != null && message.hasOwnProperty("useragent"))
                object.useragent = message.useragent;
            if (message.revision != null && message.hasOwnProperty("revision"))
                object.revision = message.revision;
            if (message.integration != null && message.hasOwnProperty("integration"))
                object.integration = message.integration;
            if (message.locale != null && message.hasOwnProperty("locale"))
                object.locale = message.locale;
            if (message.subscriptions && message.subscriptions.length) {
                object.subscriptions = [];
                for (var j = 0; j < message.subscriptions.length; ++j)
                    object.subscriptions[j] = message.subscriptions[j];
            }
            if (message.clientSubscriptions && message.clientSubscriptions.length) {
                object.clientSubscriptions = [];
                for (var j = 0; j < message.clientSubscriptions.length; ++j)
                    object.clientSubscriptions[j] = $root.ProtobufClient.ClientSubscription.toObject(message.clientSubscriptions[j], options);
            }
            return object;
        };
        /**
         * Converts this ClientIdentificationMessage to JSON.
         * @function toJSON
         * @memberof ProtobufClient.ClientIdentificationMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientIdentificationMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ClientIdentificationMessage;
    })();
    ProtobufClient.WebAuthenticationMessage = (function () {
        /**
         * Properties of a WebAuthenticationMessage.
         * @memberof ProtobufClient
         * @interface IWebAuthenticationMessage
         * @property {ProtobufClient.IClientIdentificationMessage|null} [identification] WebAuthenticationMessage identification
         * @property {string|null} [token] WebAuthenticationMessage token
         * @property {string|null} [nonce] WebAuthenticationMessage nonce
         * @property {Array.<string>|null} [accessList] WebAuthenticationMessage accessList
         */
        /**
         * Constructs a new WebAuthenticationMessage.
         * @memberof ProtobufClient
         * @classdesc Represents a WebAuthenticationMessage.
         * @implements IWebAuthenticationMessage
         * @constructor
         * @param {ProtobufClient.IWebAuthenticationMessage=} [properties] Properties to set
         */
        function WebAuthenticationMessage(properties) {
            this.accessList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * WebAuthenticationMessage identification.
         * @member {ProtobufClient.IClientIdentificationMessage|null|undefined} identification
         * @memberof ProtobufClient.WebAuthenticationMessage
         * @instance
         */
        WebAuthenticationMessage.prototype.identification = null;
        /**
         * WebAuthenticationMessage token.
         * @member {string} token
         * @memberof ProtobufClient.WebAuthenticationMessage
         * @instance
         */
        WebAuthenticationMessage.prototype.token = "";
        /**
         * WebAuthenticationMessage nonce.
         * @member {string} nonce
         * @memberof ProtobufClient.WebAuthenticationMessage
         * @instance
         */
        WebAuthenticationMessage.prototype.nonce = "";
        /**
         * WebAuthenticationMessage accessList.
         * @member {Array.<string>} accessList
         * @memberof ProtobufClient.WebAuthenticationMessage
         * @instance
         */
        WebAuthenticationMessage.prototype.accessList = $util.emptyArray;
        /**
         * Creates a new WebAuthenticationMessage instance using the specified properties.
         * @function create
         * @memberof ProtobufClient.WebAuthenticationMessage
         * @static
         * @param {ProtobufClient.IWebAuthenticationMessage=} [properties] Properties to set
         * @returns {ProtobufClient.WebAuthenticationMessage} WebAuthenticationMessage instance
         */
        WebAuthenticationMessage.create = function create(properties) {
            return new WebAuthenticationMessage(properties);
        };
        /**
         * Encodes the specified WebAuthenticationMessage message. Does not implicitly {@link ProtobufClient.WebAuthenticationMessage.verify|verify} messages.
         * @function encode
         * @memberof ProtobufClient.WebAuthenticationMessage
         * @static
         * @param {ProtobufClient.IWebAuthenticationMessage} message WebAuthenticationMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebAuthenticationMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identification != null && Object.hasOwnProperty.call(message, "identification"))
                $root.ProtobufClient.ClientIdentificationMessage.encode(message.identification, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.token);
            if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nonce);
            if (message.accessList != null && message.accessList.length)
                for (var i = 0; i < message.accessList.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.accessList[i]);
            return writer;
        };
        /**
         * Encodes the specified WebAuthenticationMessage message, length delimited. Does not implicitly {@link ProtobufClient.WebAuthenticationMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufClient.WebAuthenticationMessage
         * @static
         * @param {ProtobufClient.IWebAuthenticationMessage} message WebAuthenticationMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebAuthenticationMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a WebAuthenticationMessage message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufClient.WebAuthenticationMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufClient.WebAuthenticationMessage} WebAuthenticationMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebAuthenticationMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufClient.WebAuthenticationMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.identification = $root.ProtobufClient.ClientIdentificationMessage.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.token = reader.string();
                        break;
                    case 3:
                        message.nonce = reader.string();
                        break;
                    case 4:
                        if (!(message.accessList && message.accessList.length))
                            message.accessList = [];
                        message.accessList.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a WebAuthenticationMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufClient.WebAuthenticationMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufClient.WebAuthenticationMessage} WebAuthenticationMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebAuthenticationMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a WebAuthenticationMessage message.
         * @function verify
         * @memberof ProtobufClient.WebAuthenticationMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WebAuthenticationMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identification != null && message.hasOwnProperty("identification")) {
                var error = $root.ProtobufClient.ClientIdentificationMessage.verify(message.identification);
                if (error)
                    return "identification." + error;
            }
            if (message.token != null && message.hasOwnProperty("token"))
                if (!$util.isString(message.token))
                    return "token: string expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!$util.isString(message.nonce))
                    return "nonce: string expected";
            if (message.accessList != null && message.hasOwnProperty("accessList")) {
                if (!Array.isArray(message.accessList))
                    return "accessList: array expected";
                for (var i = 0; i < message.accessList.length; ++i)
                    if (!$util.isString(message.accessList[i]))
                        return "accessList: string[] expected";
            }
            return null;
        };
        /**
         * Creates a WebAuthenticationMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufClient.WebAuthenticationMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufClient.WebAuthenticationMessage} WebAuthenticationMessage
         */
        WebAuthenticationMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufClient.WebAuthenticationMessage)
                return object;
            var message = new $root.ProtobufClient.WebAuthenticationMessage();
            if (object.identification != null) {
                if (typeof object.identification !== "object")
                    throw TypeError(".ProtobufClient.WebAuthenticationMessage.identification: object expected");
                message.identification = $root.ProtobufClient.ClientIdentificationMessage.fromObject(object.identification);
            }
            if (object.token != null)
                message.token = String(object.token);
            if (object.nonce != null)
                message.nonce = String(object.nonce);
            if (object.accessList) {
                if (!Array.isArray(object.accessList))
                    throw TypeError(".ProtobufClient.WebAuthenticationMessage.accessList: array expected");
                message.accessList = [];
                for (var i = 0; i < object.accessList.length; ++i)
                    message.accessList[i] = String(object.accessList[i]);
            }
            return message;
        };
        /**
         * Creates a plain object from a WebAuthenticationMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufClient.WebAuthenticationMessage
         * @static
         * @param {ProtobufClient.WebAuthenticationMessage} message WebAuthenticationMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WebAuthenticationMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.accessList = [];
            if (options.defaults) {
                object.identification = null;
                object.token = "";
                object.nonce = "";
            }
            if (message.identification != null && message.hasOwnProperty("identification"))
                object.identification = $root.ProtobufClient.ClientIdentificationMessage.toObject(message.identification, options);
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = message.token;
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = message.nonce;
            if (message.accessList && message.accessList.length) {
                object.accessList = [];
                for (var j = 0; j < message.accessList.length; ++j)
                    object.accessList[j] = message.accessList[j];
            }
            return object;
        };
        /**
         * Converts this WebAuthenticationMessage to JSON.
         * @function toJSON
         * @memberof ProtobufClient.WebAuthenticationMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WebAuthenticationMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return WebAuthenticationMessage;
    })();
    ProtobufClient.WebAuthenticationResult = (function () {
        /**
         * Properties of a WebAuthenticationResult.
         * @memberof ProtobufClient
         * @interface IWebAuthenticationResult
         * @property {ProtobufClient.WebAuthenticationResult.Status|null} [status] WebAuthenticationResult status
         */
        /**
         * Constructs a new WebAuthenticationResult.
         * @memberof ProtobufClient
         * @classdesc Represents a WebAuthenticationResult.
         * @implements IWebAuthenticationResult
         * @constructor
         * @param {ProtobufClient.IWebAuthenticationResult=} [properties] Properties to set
         */
        function WebAuthenticationResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * WebAuthenticationResult status.
         * @member {ProtobufClient.WebAuthenticationResult.Status} status
         * @memberof ProtobufClient.WebAuthenticationResult
         * @instance
         */
        WebAuthenticationResult.prototype.status = 0;
        /**
         * Creates a new WebAuthenticationResult instance using the specified properties.
         * @function create
         * @memberof ProtobufClient.WebAuthenticationResult
         * @static
         * @param {ProtobufClient.IWebAuthenticationResult=} [properties] Properties to set
         * @returns {ProtobufClient.WebAuthenticationResult} WebAuthenticationResult instance
         */
        WebAuthenticationResult.create = function create(properties) {
            return new WebAuthenticationResult(properties);
        };
        /**
         * Encodes the specified WebAuthenticationResult message. Does not implicitly {@link ProtobufClient.WebAuthenticationResult.verify|verify} messages.
         * @function encode
         * @memberof ProtobufClient.WebAuthenticationResult
         * @static
         * @param {ProtobufClient.IWebAuthenticationResult} message WebAuthenticationResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebAuthenticationResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.status);
            return writer;
        };
        /**
         * Encodes the specified WebAuthenticationResult message, length delimited. Does not implicitly {@link ProtobufClient.WebAuthenticationResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufClient.WebAuthenticationResult
         * @static
         * @param {ProtobufClient.IWebAuthenticationResult} message WebAuthenticationResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebAuthenticationResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a WebAuthenticationResult message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufClient.WebAuthenticationResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufClient.WebAuthenticationResult} WebAuthenticationResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebAuthenticationResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufClient.WebAuthenticationResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a WebAuthenticationResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufClient.WebAuthenticationResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufClient.WebAuthenticationResult} WebAuthenticationResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebAuthenticationResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a WebAuthenticationResult message.
         * @function verify
         * @memberof ProtobufClient.WebAuthenticationResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WebAuthenticationResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                }
            return null;
        };
        /**
         * Creates a WebAuthenticationResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufClient.WebAuthenticationResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufClient.WebAuthenticationResult} WebAuthenticationResult
         */
        WebAuthenticationResult.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufClient.WebAuthenticationResult)
                return object;
            var message = new $root.ProtobufClient.WebAuthenticationResult();
            switch (object.status) {
                case "UNKNOWN":
                case 0:
                    message.status = 0;
                    break;
                case "AUTHENTICATED":
                case 1:
                    message.status = 1;
                    break;
                case "INVALID_SESSION":
                case 2:
                    message.status = 2;
                    break;
                case "MFA_REQUIRED":
                case 3:
                    message.status = 3;
                    break;
            }
            return message;
        };
        /**
         * Creates a plain object from a WebAuthenticationResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufClient.WebAuthenticationResult
         * @static
         * @param {ProtobufClient.WebAuthenticationResult} message WebAuthenticationResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WebAuthenticationResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = options.enums === String ? "UNKNOWN" : 0;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.ProtobufClient.WebAuthenticationResult.Status[message.status] : message.status;
            return object;
        };
        /**
         * Converts this WebAuthenticationResult to JSON.
         * @function toJSON
         * @memberof ProtobufClient.WebAuthenticationResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WebAuthenticationResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Status enum.
         * @name ProtobufClient.WebAuthenticationResult.Status
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} AUTHENTICATED=1 AUTHENTICATED value
         * @property {number} INVALID_SESSION=2 INVALID_SESSION value
         * @property {number} MFA_REQUIRED=3 MFA_REQUIRED value
         */
        WebAuthenticationResult.Status = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "AUTHENTICATED"] = 1;
            values[valuesById[2] = "INVALID_SESSION"] = 2;
            values[valuesById[3] = "MFA_REQUIRED"] = 3;
            return values;
        })();
        return WebAuthenticationResult;
    })();
    ProtobufClient.TradeSessionAuth = (function () {
        /**
         * Properties of a TradeSessionAuth.
         * @memberof ProtobufClient
         * @interface ITradeSessionAuth
         * @property {string|null} [apiKey] TradeSessionAuth apiKey
         * @property {string|null} [apiSecret] TradeSessionAuth apiSecret
         * @property {string|null} [customerId] TradeSessionAuth customerId
         * @property {string|null} [keyPassphrase] TradeSessionAuth keyPassphrase
         */
        /**
         * Constructs a new TradeSessionAuth.
         * @memberof ProtobufClient
         * @classdesc Represents a TradeSessionAuth.
         * @implements ITradeSessionAuth
         * @constructor
         * @param {ProtobufClient.ITradeSessionAuth=} [properties] Properties to set
         */
        function TradeSessionAuth(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * TradeSessionAuth apiKey.
         * @member {string} apiKey
         * @memberof ProtobufClient.TradeSessionAuth
         * @instance
         */
        TradeSessionAuth.prototype.apiKey = "";
        /**
         * TradeSessionAuth apiSecret.
         * @member {string} apiSecret
         * @memberof ProtobufClient.TradeSessionAuth
         * @instance
         */
        TradeSessionAuth.prototype.apiSecret = "";
        /**
         * TradeSessionAuth customerId.
         * @member {string} customerId
         * @memberof ProtobufClient.TradeSessionAuth
         * @instance
         */
        TradeSessionAuth.prototype.customerId = "";
        /**
         * TradeSessionAuth keyPassphrase.
         * @member {string} keyPassphrase
         * @memberof ProtobufClient.TradeSessionAuth
         * @instance
         */
        TradeSessionAuth.prototype.keyPassphrase = "";
        /**
         * Creates a new TradeSessionAuth instance using the specified properties.
         * @function create
         * @memberof ProtobufClient.TradeSessionAuth
         * @static
         * @param {ProtobufClient.ITradeSessionAuth=} [properties] Properties to set
         * @returns {ProtobufClient.TradeSessionAuth} TradeSessionAuth instance
         */
        TradeSessionAuth.create = function create(properties) {
            return new TradeSessionAuth(properties);
        };
        /**
         * Encodes the specified TradeSessionAuth message. Does not implicitly {@link ProtobufClient.TradeSessionAuth.verify|verify} messages.
         * @function encode
         * @memberof ProtobufClient.TradeSessionAuth
         * @static
         * @param {ProtobufClient.ITradeSessionAuth} message TradeSessionAuth message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeSessionAuth.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.apiKey != null && Object.hasOwnProperty.call(message, "apiKey"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.apiKey);
            if (message.apiSecret != null && Object.hasOwnProperty.call(message, "apiSecret"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.apiSecret);
            if (message.customerId != null && Object.hasOwnProperty.call(message, "customerId"))
                writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.customerId);
            if (message.keyPassphrase != null && Object.hasOwnProperty.call(message, "keyPassphrase"))
                writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.keyPassphrase);
            return writer;
        };
        /**
         * Encodes the specified TradeSessionAuth message, length delimited. Does not implicitly {@link ProtobufClient.TradeSessionAuth.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufClient.TradeSessionAuth
         * @static
         * @param {ProtobufClient.ITradeSessionAuth} message TradeSessionAuth message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeSessionAuth.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a TradeSessionAuth message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufClient.TradeSessionAuth
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufClient.TradeSessionAuth} TradeSessionAuth
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeSessionAuth.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufClient.TradeSessionAuth();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.apiKey = reader.string();
                        break;
                    case 2:
                        message.apiSecret = reader.string();
                        break;
                    case 3:
                        message.customerId = reader.string();
                        break;
                    case 4:
                        message.keyPassphrase = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a TradeSessionAuth message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufClient.TradeSessionAuth
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufClient.TradeSessionAuth} TradeSessionAuth
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeSessionAuth.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a TradeSessionAuth message.
         * @function verify
         * @memberof ProtobufClient.TradeSessionAuth
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TradeSessionAuth.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.apiKey != null && message.hasOwnProperty("apiKey"))
                if (!$util.isString(message.apiKey))
                    return "apiKey: string expected";
            if (message.apiSecret != null && message.hasOwnProperty("apiSecret"))
                if (!$util.isString(message.apiSecret))
                    return "apiSecret: string expected";
            if (message.customerId != null && message.hasOwnProperty("customerId"))
                if (!$util.isString(message.customerId))
                    return "customerId: string expected";
            if (message.keyPassphrase != null && message.hasOwnProperty("keyPassphrase"))
                if (!$util.isString(message.keyPassphrase))
                    return "keyPassphrase: string expected";
            return null;
        };
        /**
         * Creates a TradeSessionAuth message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufClient.TradeSessionAuth
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufClient.TradeSessionAuth} TradeSessionAuth
         */
        TradeSessionAuth.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufClient.TradeSessionAuth)
                return object;
            var message = new $root.ProtobufClient.TradeSessionAuth();
            if (object.apiKey != null)
                message.apiKey = String(object.apiKey);
            if (object.apiSecret != null)
                message.apiSecret = String(object.apiSecret);
            if (object.customerId != null)
                message.customerId = String(object.customerId);
            if (object.keyPassphrase != null)
                message.keyPassphrase = String(object.keyPassphrase);
            return message;
        };
        /**
         * Creates a plain object from a TradeSessionAuth message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufClient.TradeSessionAuth
         * @static
         * @param {ProtobufClient.TradeSessionAuth} message TradeSessionAuth
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TradeSessionAuth.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.apiKey = "";
                object.apiSecret = "";
                object.customerId = "";
                object.keyPassphrase = "";
            }
            if (message.apiKey != null && message.hasOwnProperty("apiKey"))
                object.apiKey = message.apiKey;
            if (message.apiSecret != null && message.hasOwnProperty("apiSecret"))
                object.apiSecret = message.apiSecret;
            if (message.customerId != null && message.hasOwnProperty("customerId"))
                object.customerId = message.customerId;
            if (message.keyPassphrase != null && message.hasOwnProperty("keyPassphrase"))
                object.keyPassphrase = message.keyPassphrase;
            return object;
        };
        /**
         * Converts this TradeSessionAuth to JSON.
         * @function toJSON
         * @memberof ProtobufClient.TradeSessionAuth
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TradeSessionAuth.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return TradeSessionAuth;
    })();
    ProtobufClient.TradeSubscription = (function () {
        /**
         * Properties of a TradeSubscription.
         * @memberof ProtobufClient
         * @interface ITradeSubscription
         * @property {string|null} [marketId] TradeSubscription marketId
         * @property {ProtobufClient.ITradeSessionAuth|null} [auth] TradeSubscription auth
         */
        /**
         * Constructs a new TradeSubscription.
         * @memberof ProtobufClient
         * @classdesc Represents a TradeSubscription.
         * @implements ITradeSubscription
         * @constructor
         * @param {ProtobufClient.ITradeSubscription=} [properties] Properties to set
         */
        function TradeSubscription(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * TradeSubscription marketId.
         * @member {string} marketId
         * @memberof ProtobufClient.TradeSubscription
         * @instance
         */
        TradeSubscription.prototype.marketId = "";
        /**
         * TradeSubscription auth.
         * @member {ProtobufClient.ITradeSessionAuth|null|undefined} auth
         * @memberof ProtobufClient.TradeSubscription
         * @instance
         */
        TradeSubscription.prototype.auth = null;
        /**
         * Creates a new TradeSubscription instance using the specified properties.
         * @function create
         * @memberof ProtobufClient.TradeSubscription
         * @static
         * @param {ProtobufClient.ITradeSubscription=} [properties] Properties to set
         * @returns {ProtobufClient.TradeSubscription} TradeSubscription instance
         */
        TradeSubscription.create = function create(properties) {
            return new TradeSubscription(properties);
        };
        /**
         * Encodes the specified TradeSubscription message. Does not implicitly {@link ProtobufClient.TradeSubscription.verify|verify} messages.
         * @function encode
         * @memberof ProtobufClient.TradeSubscription
         * @static
         * @param {ProtobufClient.ITradeSubscription} message TradeSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeSubscription.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.marketId != null && Object.hasOwnProperty.call(message, "marketId"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.marketId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.ProtobufClient.TradeSessionAuth.encode(message.auth, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified TradeSubscription message, length delimited. Does not implicitly {@link ProtobufClient.TradeSubscription.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufClient.TradeSubscription
         * @static
         * @param {ProtobufClient.ITradeSubscription} message TradeSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeSubscription.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a TradeSubscription message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufClient.TradeSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufClient.TradeSubscription} TradeSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeSubscription.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufClient.TradeSubscription();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.marketId = reader.string();
                        break;
                    case 2:
                        message.auth = $root.ProtobufClient.TradeSessionAuth.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a TradeSubscription message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufClient.TradeSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufClient.TradeSubscription} TradeSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeSubscription.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a TradeSubscription message.
         * @function verify
         * @memberof ProtobufClient.TradeSubscription
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TradeSubscription.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.marketId != null && message.hasOwnProperty("marketId"))
                if (!$util.isString(message.marketId))
                    return "marketId: string expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.ProtobufClient.TradeSessionAuth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            return null;
        };
        /**
         * Creates a TradeSubscription message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufClient.TradeSubscription
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufClient.TradeSubscription} TradeSubscription
         */
        TradeSubscription.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufClient.TradeSubscription)
                return object;
            var message = new $root.ProtobufClient.TradeSubscription();
            if (object.marketId != null)
                message.marketId = String(object.marketId);
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".ProtobufClient.TradeSubscription.auth: object expected");
                message.auth = $root.ProtobufClient.TradeSessionAuth.fromObject(object.auth);
            }
            return message;
        };
        /**
         * Creates a plain object from a TradeSubscription message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufClient.TradeSubscription
         * @static
         * @param {ProtobufClient.TradeSubscription} message TradeSubscription
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TradeSubscription.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.marketId = "";
                object.auth = null;
            }
            if (message.marketId != null && message.hasOwnProperty("marketId"))
                object.marketId = message.marketId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.ProtobufClient.TradeSessionAuth.toObject(message.auth, options);
            return object;
        };
        /**
         * Converts this TradeSubscription to JSON.
         * @function toJSON
         * @memberof ProtobufClient.TradeSubscription
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TradeSubscription.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return TradeSubscription;
    })();
    ProtobufClient.StreamSubscription = (function () {
        /**
         * Properties of a StreamSubscription.
         * @memberof ProtobufClient
         * @interface IStreamSubscription
         * @property {string|null} [resource] StreamSubscription resource
         */
        /**
         * Constructs a new StreamSubscription.
         * @memberof ProtobufClient
         * @classdesc Represents a StreamSubscription.
         * @implements IStreamSubscription
         * @constructor
         * @param {ProtobufClient.IStreamSubscription=} [properties] Properties to set
         */
        function StreamSubscription(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * StreamSubscription resource.
         * @member {string} resource
         * @memberof ProtobufClient.StreamSubscription
         * @instance
         */
        StreamSubscription.prototype.resource = "";
        /**
         * Creates a new StreamSubscription instance using the specified properties.
         * @function create
         * @memberof ProtobufClient.StreamSubscription
         * @static
         * @param {ProtobufClient.IStreamSubscription=} [properties] Properties to set
         * @returns {ProtobufClient.StreamSubscription} StreamSubscription instance
         */
        StreamSubscription.create = function create(properties) {
            return new StreamSubscription(properties);
        };
        /**
         * Encodes the specified StreamSubscription message. Does not implicitly {@link ProtobufClient.StreamSubscription.verify|verify} messages.
         * @function encode
         * @memberof ProtobufClient.StreamSubscription
         * @static
         * @param {ProtobufClient.IStreamSubscription} message StreamSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamSubscription.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resource != null && Object.hasOwnProperty.call(message, "resource"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.resource);
            return writer;
        };
        /**
         * Encodes the specified StreamSubscription message, length delimited. Does not implicitly {@link ProtobufClient.StreamSubscription.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufClient.StreamSubscription
         * @static
         * @param {ProtobufClient.IStreamSubscription} message StreamSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamSubscription.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a StreamSubscription message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufClient.StreamSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufClient.StreamSubscription} StreamSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamSubscription.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufClient.StreamSubscription();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.resource = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a StreamSubscription message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufClient.StreamSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufClient.StreamSubscription} StreamSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamSubscription.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a StreamSubscription message.
         * @function verify
         * @memberof ProtobufClient.StreamSubscription
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StreamSubscription.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resource != null && message.hasOwnProperty("resource"))
                if (!$util.isString(message.resource))
                    return "resource: string expected";
            return null;
        };
        /**
         * Creates a StreamSubscription message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufClient.StreamSubscription
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufClient.StreamSubscription} StreamSubscription
         */
        StreamSubscription.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufClient.StreamSubscription)
                return object;
            var message = new $root.ProtobufClient.StreamSubscription();
            if (object.resource != null)
                message.resource = String(object.resource);
            return message;
        };
        /**
         * Creates a plain object from a StreamSubscription message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufClient.StreamSubscription
         * @static
         * @param {ProtobufClient.StreamSubscription} message StreamSubscription
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StreamSubscription.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.resource = "";
            if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = message.resource;
            return object;
        };
        /**
         * Converts this StreamSubscription to JSON.
         * @function toJSON
         * @memberof ProtobufClient.StreamSubscription
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StreamSubscription.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return StreamSubscription;
    })();
    ProtobufClient.UserPushSubscription = (function () {
        /**
         * Properties of a UserPushSubscription.
         * @memberof ProtobufClient
         * @interface IUserPushSubscription
         * @property {ProtobufClient.UserPushSubscription.ITriggeredHandlers|null} [triggeredHandlers] UserPushSubscription triggeredHandlers
         * @property {ProtobufClient.UserPushSubscription.IAchievements|null} [achievements] UserPushSubscription achievements
         */
        /**
         * Constructs a new UserPushSubscription.
         * @memberof ProtobufClient
         * @classdesc Represents a UserPushSubscription.
         * @implements IUserPushSubscription
         * @constructor
         * @param {ProtobufClient.IUserPushSubscription=} [properties] Properties to set
         */
        function UserPushSubscription(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * UserPushSubscription triggeredHandlers.
         * @member {ProtobufClient.UserPushSubscription.ITriggeredHandlers|null|undefined} triggeredHandlers
         * @memberof ProtobufClient.UserPushSubscription
         * @instance
         */
        UserPushSubscription.prototype.triggeredHandlers = null;
        /**
         * UserPushSubscription achievements.
         * @member {ProtobufClient.UserPushSubscription.IAchievements|null|undefined} achievements
         * @memberof ProtobufClient.UserPushSubscription
         * @instance
         */
        UserPushSubscription.prototype.achievements = null;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * UserPushSubscription body.
         * @member {"triggeredHandlers"|"achievements"|undefined} body
         * @memberof ProtobufClient.UserPushSubscription
         * @instance
         */
        Object.defineProperty(UserPushSubscription.prototype, "body", {
            get: $util.oneOfGetter($oneOfFields = ["triggeredHandlers", "achievements"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new UserPushSubscription instance using the specified properties.
         * @function create
         * @memberof ProtobufClient.UserPushSubscription
         * @static
         * @param {ProtobufClient.IUserPushSubscription=} [properties] Properties to set
         * @returns {ProtobufClient.UserPushSubscription} UserPushSubscription instance
         */
        UserPushSubscription.create = function create(properties) {
            return new UserPushSubscription(properties);
        };
        /**
         * Encodes the specified UserPushSubscription message. Does not implicitly {@link ProtobufClient.UserPushSubscription.verify|verify} messages.
         * @function encode
         * @memberof ProtobufClient.UserPushSubscription
         * @static
         * @param {ProtobufClient.IUserPushSubscription} message UserPushSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserPushSubscription.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.triggeredHandlers != null && Object.hasOwnProperty.call(message, "triggeredHandlers"))
                $root.ProtobufClient.UserPushSubscription.TriggeredHandlers.encode(message.triggeredHandlers, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.achievements != null && Object.hasOwnProperty.call(message, "achievements"))
                $root.ProtobufClient.UserPushSubscription.Achievements.encode(message.achievements, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified UserPushSubscription message, length delimited. Does not implicitly {@link ProtobufClient.UserPushSubscription.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufClient.UserPushSubscription
         * @static
         * @param {ProtobufClient.IUserPushSubscription} message UserPushSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserPushSubscription.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a UserPushSubscription message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufClient.UserPushSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufClient.UserPushSubscription} UserPushSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserPushSubscription.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufClient.UserPushSubscription();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.triggeredHandlers = $root.ProtobufClient.UserPushSubscription.TriggeredHandlers.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.achievements = $root.ProtobufClient.UserPushSubscription.Achievements.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a UserPushSubscription message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufClient.UserPushSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufClient.UserPushSubscription} UserPushSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserPushSubscription.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a UserPushSubscription message.
         * @function verify
         * @memberof ProtobufClient.UserPushSubscription
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserPushSubscription.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.triggeredHandlers != null && message.hasOwnProperty("triggeredHandlers")) {
                properties.body = 1;
                {
                    var error = $root.ProtobufClient.UserPushSubscription.TriggeredHandlers.verify(message.triggeredHandlers);
                    if (error)
                        return "triggeredHandlers." + error;
                }
            }
            if (message.achievements != null && message.hasOwnProperty("achievements")) {
                if (properties.body === 1)
                    return "body: multiple values";
                properties.body = 1;
                {
                    var error = $root.ProtobufClient.UserPushSubscription.Achievements.verify(message.achievements);
                    if (error)
                        return "achievements." + error;
                }
            }
            return null;
        };
        /**
         * Creates a UserPushSubscription message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufClient.UserPushSubscription
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufClient.UserPushSubscription} UserPushSubscription
         */
        UserPushSubscription.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufClient.UserPushSubscription)
                return object;
            var message = new $root.ProtobufClient.UserPushSubscription();
            if (object.triggeredHandlers != null) {
                if (typeof object.triggeredHandlers !== "object")
                    throw TypeError(".ProtobufClient.UserPushSubscription.triggeredHandlers: object expected");
                message.triggeredHandlers = $root.ProtobufClient.UserPushSubscription.TriggeredHandlers.fromObject(object.triggeredHandlers);
            }
            if (object.achievements != null) {
                if (typeof object.achievements !== "object")
                    throw TypeError(".ProtobufClient.UserPushSubscription.achievements: object expected");
                message.achievements = $root.ProtobufClient.UserPushSubscription.Achievements.fromObject(object.achievements);
            }
            return message;
        };
        /**
         * Creates a plain object from a UserPushSubscription message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufClient.UserPushSubscription
         * @static
         * @param {ProtobufClient.UserPushSubscription} message UserPushSubscription
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserPushSubscription.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.triggeredHandlers != null && message.hasOwnProperty("triggeredHandlers")) {
                object.triggeredHandlers = $root.ProtobufClient.UserPushSubscription.TriggeredHandlers.toObject(message.triggeredHandlers, options);
                if (options.oneofs)
                    object.body = "triggeredHandlers";
            }
            if (message.achievements != null && message.hasOwnProperty("achievements")) {
                object.achievements = $root.ProtobufClient.UserPushSubscription.Achievements.toObject(message.achievements, options);
                if (options.oneofs)
                    object.body = "achievements";
            }
            return object;
        };
        /**
         * Converts this UserPushSubscription to JSON.
         * @function toJSON
         * @memberof ProtobufClient.UserPushSubscription
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserPushSubscription.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        UserPushSubscription.TriggeredHandlers = (function () {
            /**
             * Properties of a TriggeredHandlers.
             * @memberof ProtobufClient.UserPushSubscription
             * @interface ITriggeredHandlers
             */
            /**
             * Constructs a new TriggeredHandlers.
             * @memberof ProtobufClient.UserPushSubscription
             * @classdesc Represents a TriggeredHandlers.
             * @implements ITriggeredHandlers
             * @constructor
             * @param {ProtobufClient.UserPushSubscription.ITriggeredHandlers=} [properties] Properties to set
             */
            function TriggeredHandlers(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Creates a new TriggeredHandlers instance using the specified properties.
             * @function create
             * @memberof ProtobufClient.UserPushSubscription.TriggeredHandlers
             * @static
             * @param {ProtobufClient.UserPushSubscription.ITriggeredHandlers=} [properties] Properties to set
             * @returns {ProtobufClient.UserPushSubscription.TriggeredHandlers} TriggeredHandlers instance
             */
            TriggeredHandlers.create = function create(properties) {
                return new TriggeredHandlers(properties);
            };
            /**
             * Encodes the specified TriggeredHandlers message. Does not implicitly {@link ProtobufClient.UserPushSubscription.TriggeredHandlers.verify|verify} messages.
             * @function encode
             * @memberof ProtobufClient.UserPushSubscription.TriggeredHandlers
             * @static
             * @param {ProtobufClient.UserPushSubscription.ITriggeredHandlers} message TriggeredHandlers message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TriggeredHandlers.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
            /**
             * Encodes the specified TriggeredHandlers message, length delimited. Does not implicitly {@link ProtobufClient.UserPushSubscription.TriggeredHandlers.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ProtobufClient.UserPushSubscription.TriggeredHandlers
             * @static
             * @param {ProtobufClient.UserPushSubscription.ITriggeredHandlers} message TriggeredHandlers message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TriggeredHandlers.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a TriggeredHandlers message from the specified reader or buffer.
             * @function decode
             * @memberof ProtobufClient.UserPushSubscription.TriggeredHandlers
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ProtobufClient.UserPushSubscription.TriggeredHandlers} TriggeredHandlers
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TriggeredHandlers.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufClient.UserPushSubscription.TriggeredHandlers();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a TriggeredHandlers message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ProtobufClient.UserPushSubscription.TriggeredHandlers
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ProtobufClient.UserPushSubscription.TriggeredHandlers} TriggeredHandlers
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TriggeredHandlers.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a TriggeredHandlers message.
             * @function verify
             * @memberof ProtobufClient.UserPushSubscription.TriggeredHandlers
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TriggeredHandlers.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
            /**
             * Creates a TriggeredHandlers message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ProtobufClient.UserPushSubscription.TriggeredHandlers
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ProtobufClient.UserPushSubscription.TriggeredHandlers} TriggeredHandlers
             */
            TriggeredHandlers.fromObject = function fromObject(object) {
                if (object instanceof $root.ProtobufClient.UserPushSubscription.TriggeredHandlers)
                    return object;
                return new $root.ProtobufClient.UserPushSubscription.TriggeredHandlers();
            };
            /**
             * Creates a plain object from a TriggeredHandlers message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ProtobufClient.UserPushSubscription.TriggeredHandlers
             * @static
             * @param {ProtobufClient.UserPushSubscription.TriggeredHandlers} message TriggeredHandlers
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TriggeredHandlers.toObject = function toObject() {
                return {};
            };
            /**
             * Converts this TriggeredHandlers to JSON.
             * @function toJSON
             * @memberof ProtobufClient.UserPushSubscription.TriggeredHandlers
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TriggeredHandlers.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return TriggeredHandlers;
        })();
        UserPushSubscription.Achievements = (function () {
            /**
             * Properties of an Achievements.
             * @memberof ProtobufClient.UserPushSubscription
             * @interface IAchievements
             */
            /**
             * Constructs a new Achievements.
             * @memberof ProtobufClient.UserPushSubscription
             * @classdesc Represents an Achievements.
             * @implements IAchievements
             * @constructor
             * @param {ProtobufClient.UserPushSubscription.IAchievements=} [properties] Properties to set
             */
            function Achievements(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Creates a new Achievements instance using the specified properties.
             * @function create
             * @memberof ProtobufClient.UserPushSubscription.Achievements
             * @static
             * @param {ProtobufClient.UserPushSubscription.IAchievements=} [properties] Properties to set
             * @returns {ProtobufClient.UserPushSubscription.Achievements} Achievements instance
             */
            Achievements.create = function create(properties) {
                return new Achievements(properties);
            };
            /**
             * Encodes the specified Achievements message. Does not implicitly {@link ProtobufClient.UserPushSubscription.Achievements.verify|verify} messages.
             * @function encode
             * @memberof ProtobufClient.UserPushSubscription.Achievements
             * @static
             * @param {ProtobufClient.UserPushSubscription.IAchievements} message Achievements message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Achievements.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
            /**
             * Encodes the specified Achievements message, length delimited. Does not implicitly {@link ProtobufClient.UserPushSubscription.Achievements.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ProtobufClient.UserPushSubscription.Achievements
             * @static
             * @param {ProtobufClient.UserPushSubscription.IAchievements} message Achievements message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Achievements.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an Achievements message from the specified reader or buffer.
             * @function decode
             * @memberof ProtobufClient.UserPushSubscription.Achievements
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ProtobufClient.UserPushSubscription.Achievements} Achievements
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Achievements.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufClient.UserPushSubscription.Achievements();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes an Achievements message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ProtobufClient.UserPushSubscription.Achievements
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ProtobufClient.UserPushSubscription.Achievements} Achievements
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Achievements.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an Achievements message.
             * @function verify
             * @memberof ProtobufClient.UserPushSubscription.Achievements
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Achievements.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
            /**
             * Creates an Achievements message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ProtobufClient.UserPushSubscription.Achievements
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ProtobufClient.UserPushSubscription.Achievements} Achievements
             */
            Achievements.fromObject = function fromObject(object) {
                if (object instanceof $root.ProtobufClient.UserPushSubscription.Achievements)
                    return object;
                return new $root.ProtobufClient.UserPushSubscription.Achievements();
            };
            /**
             * Creates a plain object from an Achievements message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ProtobufClient.UserPushSubscription.Achievements
             * @static
             * @param {ProtobufClient.UserPushSubscription.Achievements} message Achievements
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Achievements.toObject = function toObject() {
                return {};
            };
            /**
             * Converts this Achievements to JSON.
             * @function toJSON
             * @memberof ProtobufClient.UserPushSubscription.Achievements
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Achievements.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Achievements;
        })();
        return UserPushSubscription;
    })();
    ProtobufClient.TriggerSubscription = (function () {
        /**
         * Properties of a TriggerSubscription.
         * @memberof ProtobufClient
         * @interface ITriggerSubscription
         */
        /**
         * Constructs a new TriggerSubscription.
         * @memberof ProtobufClient
         * @classdesc Represents a TriggerSubscription.
         * @implements ITriggerSubscription
         * @constructor
         * @param {ProtobufClient.ITriggerSubscription=} [properties] Properties to set
         */
        function TriggerSubscription(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Creates a new TriggerSubscription instance using the specified properties.
         * @function create
         * @memberof ProtobufClient.TriggerSubscription
         * @static
         * @param {ProtobufClient.ITriggerSubscription=} [properties] Properties to set
         * @returns {ProtobufClient.TriggerSubscription} TriggerSubscription instance
         */
        TriggerSubscription.create = function create(properties) {
            return new TriggerSubscription(properties);
        };
        /**
         * Encodes the specified TriggerSubscription message. Does not implicitly {@link ProtobufClient.TriggerSubscription.verify|verify} messages.
         * @function encode
         * @memberof ProtobufClient.TriggerSubscription
         * @static
         * @param {ProtobufClient.ITriggerSubscription} message TriggerSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TriggerSubscription.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
        /**
         * Encodes the specified TriggerSubscription message, length delimited. Does not implicitly {@link ProtobufClient.TriggerSubscription.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufClient.TriggerSubscription
         * @static
         * @param {ProtobufClient.ITriggerSubscription} message TriggerSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TriggerSubscription.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a TriggerSubscription message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufClient.TriggerSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufClient.TriggerSubscription} TriggerSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TriggerSubscription.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufClient.TriggerSubscription();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a TriggerSubscription message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufClient.TriggerSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufClient.TriggerSubscription} TriggerSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TriggerSubscription.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a TriggerSubscription message.
         * @function verify
         * @memberof ProtobufClient.TriggerSubscription
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TriggerSubscription.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
        /**
         * Creates a TriggerSubscription message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufClient.TriggerSubscription
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufClient.TriggerSubscription} TriggerSubscription
         */
        TriggerSubscription.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufClient.TriggerSubscription)
                return object;
            return new $root.ProtobufClient.TriggerSubscription();
        };
        /**
         * Creates a plain object from a TriggerSubscription message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufClient.TriggerSubscription
         * @static
         * @param {ProtobufClient.TriggerSubscription} message TriggerSubscription
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TriggerSubscription.toObject = function toObject() {
            return {};
        };
        /**
         * Converts this TriggerSubscription to JSON.
         * @function toJSON
         * @memberof ProtobufClient.TriggerSubscription
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TriggerSubscription.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return TriggerSubscription;
    })();
    ProtobufClient.ClientSubscription = (function () {
        /**
         * Properties of a ClientSubscription.
         * @memberof ProtobufClient
         * @interface IClientSubscription
         * @property {ProtobufClient.IStreamSubscription|null} [streamSubscription] ClientSubscription streamSubscription
         * @property {ProtobufClient.ITradeSubscription|null} [tradeSubscription] ClientSubscription tradeSubscription
         * @property {ProtobufClient.ITriggerSubscription|null} [triggerSubscription] ClientSubscription triggerSubscription
         * @property {ProtobufClient.IUserPushSubscription|null} [userPushSubscription] ClientSubscription userPushSubscription
         */
        /**
         * Constructs a new ClientSubscription.
         * @memberof ProtobufClient
         * @classdesc Represents a ClientSubscription.
         * @implements IClientSubscription
         * @constructor
         * @param {ProtobufClient.IClientSubscription=} [properties] Properties to set
         */
        function ClientSubscription(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ClientSubscription streamSubscription.
         * @member {ProtobufClient.IStreamSubscription|null|undefined} streamSubscription
         * @memberof ProtobufClient.ClientSubscription
         * @instance
         */
        ClientSubscription.prototype.streamSubscription = null;
        /**
         * ClientSubscription tradeSubscription.
         * @member {ProtobufClient.ITradeSubscription|null|undefined} tradeSubscription
         * @memberof ProtobufClient.ClientSubscription
         * @instance
         */
        ClientSubscription.prototype.tradeSubscription = null;
        /**
         * ClientSubscription triggerSubscription.
         * @member {ProtobufClient.ITriggerSubscription|null|undefined} triggerSubscription
         * @memberof ProtobufClient.ClientSubscription
         * @instance
         */
        ClientSubscription.prototype.triggerSubscription = null;
        /**
         * ClientSubscription userPushSubscription.
         * @member {ProtobufClient.IUserPushSubscription|null|undefined} userPushSubscription
         * @memberof ProtobufClient.ClientSubscription
         * @instance
         */
        ClientSubscription.prototype.userPushSubscription = null;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * ClientSubscription body.
         * @member {"streamSubscription"|"tradeSubscription"|"triggerSubscription"|"userPushSubscription"|undefined} body
         * @memberof ProtobufClient.ClientSubscription
         * @instance
         */
        Object.defineProperty(ClientSubscription.prototype, "body", {
            get: $util.oneOfGetter($oneOfFields = ["streamSubscription", "tradeSubscription", "triggerSubscription", "userPushSubscription"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new ClientSubscription instance using the specified properties.
         * @function create
         * @memberof ProtobufClient.ClientSubscription
         * @static
         * @param {ProtobufClient.IClientSubscription=} [properties] Properties to set
         * @returns {ProtobufClient.ClientSubscription} ClientSubscription instance
         */
        ClientSubscription.create = function create(properties) {
            return new ClientSubscription(properties);
        };
        /**
         * Encodes the specified ClientSubscription message. Does not implicitly {@link ProtobufClient.ClientSubscription.verify|verify} messages.
         * @function encode
         * @memberof ProtobufClient.ClientSubscription
         * @static
         * @param {ProtobufClient.IClientSubscription} message ClientSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientSubscription.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.streamSubscription != null && Object.hasOwnProperty.call(message, "streamSubscription"))
                $root.ProtobufClient.StreamSubscription.encode(message.streamSubscription, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.tradeSubscription != null && Object.hasOwnProperty.call(message, "tradeSubscription"))
                $root.ProtobufClient.TradeSubscription.encode(message.tradeSubscription, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.triggerSubscription != null && Object.hasOwnProperty.call(message, "triggerSubscription"))
                $root.ProtobufClient.TriggerSubscription.encode(message.triggerSubscription, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.userPushSubscription != null && Object.hasOwnProperty.call(message, "userPushSubscription"))
                $root.ProtobufClient.UserPushSubscription.encode(message.userPushSubscription, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified ClientSubscription message, length delimited. Does not implicitly {@link ProtobufClient.ClientSubscription.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufClient.ClientSubscription
         * @static
         * @param {ProtobufClient.IClientSubscription} message ClientSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientSubscription.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ClientSubscription message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufClient.ClientSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufClient.ClientSubscription} ClientSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientSubscription.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufClient.ClientSubscription();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.streamSubscription = $root.ProtobufClient.StreamSubscription.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.tradeSubscription = $root.ProtobufClient.TradeSubscription.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.triggerSubscription = $root.ProtobufClient.TriggerSubscription.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.userPushSubscription = $root.ProtobufClient.UserPushSubscription.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ClientSubscription message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufClient.ClientSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufClient.ClientSubscription} ClientSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientSubscription.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ClientSubscription message.
         * @function verify
         * @memberof ProtobufClient.ClientSubscription
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientSubscription.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.streamSubscription != null && message.hasOwnProperty("streamSubscription")) {
                properties.body = 1;
                {
                    var error = $root.ProtobufClient.StreamSubscription.verify(message.streamSubscription);
                    if (error)
                        return "streamSubscription." + error;
                }
            }
            if (message.tradeSubscription != null && message.hasOwnProperty("tradeSubscription")) {
                if (properties.body === 1)
                    return "body: multiple values";
                properties.body = 1;
                {
                    var error = $root.ProtobufClient.TradeSubscription.verify(message.tradeSubscription);
                    if (error)
                        return "tradeSubscription." + error;
                }
            }
            if (message.triggerSubscription != null && message.hasOwnProperty("triggerSubscription")) {
                if (properties.body === 1)
                    return "body: multiple values";
                properties.body = 1;
                {
                    var error = $root.ProtobufClient.TriggerSubscription.verify(message.triggerSubscription);
                    if (error)
                        return "triggerSubscription." + error;
                }
            }
            if (message.userPushSubscription != null && message.hasOwnProperty("userPushSubscription")) {
                if (properties.body === 1)
                    return "body: multiple values";
                properties.body = 1;
                {
                    var error = $root.ProtobufClient.UserPushSubscription.verify(message.userPushSubscription);
                    if (error)
                        return "userPushSubscription." + error;
                }
            }
            return null;
        };
        /**
         * Creates a ClientSubscription message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufClient.ClientSubscription
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufClient.ClientSubscription} ClientSubscription
         */
        ClientSubscription.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufClient.ClientSubscription)
                return object;
            var message = new $root.ProtobufClient.ClientSubscription();
            if (object.streamSubscription != null) {
                if (typeof object.streamSubscription !== "object")
                    throw TypeError(".ProtobufClient.ClientSubscription.streamSubscription: object expected");
                message.streamSubscription = $root.ProtobufClient.StreamSubscription.fromObject(object.streamSubscription);
            }
            if (object.tradeSubscription != null) {
                if (typeof object.tradeSubscription !== "object")
                    throw TypeError(".ProtobufClient.ClientSubscription.tradeSubscription: object expected");
                message.tradeSubscription = $root.ProtobufClient.TradeSubscription.fromObject(object.tradeSubscription);
            }
            if (object.triggerSubscription != null) {
                if (typeof object.triggerSubscription !== "object")
                    throw TypeError(".ProtobufClient.ClientSubscription.triggerSubscription: object expected");
                message.triggerSubscription = $root.ProtobufClient.TriggerSubscription.fromObject(object.triggerSubscription);
            }
            if (object.userPushSubscription != null) {
                if (typeof object.userPushSubscription !== "object")
                    throw TypeError(".ProtobufClient.ClientSubscription.userPushSubscription: object expected");
                message.userPushSubscription = $root.ProtobufClient.UserPushSubscription.fromObject(object.userPushSubscription);
            }
            return message;
        };
        /**
         * Creates a plain object from a ClientSubscription message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufClient.ClientSubscription
         * @static
         * @param {ProtobufClient.ClientSubscription} message ClientSubscription
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientSubscription.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.streamSubscription != null && message.hasOwnProperty("streamSubscription")) {
                object.streamSubscription = $root.ProtobufClient.StreamSubscription.toObject(message.streamSubscription, options);
                if (options.oneofs)
                    object.body = "streamSubscription";
            }
            if (message.tradeSubscription != null && message.hasOwnProperty("tradeSubscription")) {
                object.tradeSubscription = $root.ProtobufClient.TradeSubscription.toObject(message.tradeSubscription, options);
                if (options.oneofs)
                    object.body = "tradeSubscription";
            }
            if (message.triggerSubscription != null && message.hasOwnProperty("triggerSubscription")) {
                object.triggerSubscription = $root.ProtobufClient.TriggerSubscription.toObject(message.triggerSubscription, options);
                if (options.oneofs)
                    object.body = "triggerSubscription";
            }
            if (message.userPushSubscription != null && message.hasOwnProperty("userPushSubscription")) {
                object.userPushSubscription = $root.ProtobufClient.UserPushSubscription.toObject(message.userPushSubscription, options);
                if (options.oneofs)
                    object.body = "userPushSubscription";
            }
            return object;
        };
        /**
         * Converts this ClientSubscription to JSON.
         * @function toJSON
         * @memberof ProtobufClient.ClientSubscription
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientSubscription.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ClientSubscription;
    })();
    ProtobufClient.APIAuthenticationMessage = (function () {
        /**
         * Properties of a APIAuthenticationMessage.
         * @memberof ProtobufClient
         * @interface IAPIAuthenticationMessage
         * @property {string|null} [token] APIAuthenticationMessage token
         * @property {string|null} [nonce] APIAuthenticationMessage nonce
         * @property {string|null} [apiKey] APIAuthenticationMessage apiKey
         * @property {ProtobufClient.APIAuthenticationMessage.Source|null} [source] APIAuthenticationMessage source
         * @property {string|null} [version] APIAuthenticationMessage version
         * @property {Array.<string>|null} [subscriptions] APIAuthenticationMessage subscriptions
         * @property {Array.<ProtobufClient.IClientSubscription>|null} [clientSubscriptions] APIAuthenticationMessage clientSubscriptions
         */
        /**
         * Constructs a new APIAuthenticationMessage.
         * @memberof ProtobufClient
         * @classdesc Represents a APIAuthenticationMessage.
         * @implements IAPIAuthenticationMessage
         * @constructor
         * @param {ProtobufClient.IAPIAuthenticationMessage=} [properties] Properties to set
         */
        function APIAuthenticationMessage(properties) {
            this.subscriptions = [];
            this.clientSubscriptions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * APIAuthenticationMessage token.
         * @member {string} token
         * @memberof ProtobufClient.APIAuthenticationMessage
         * @instance
         */
        APIAuthenticationMessage.prototype.token = "";
        /**
         * APIAuthenticationMessage nonce.
         * @member {string} nonce
         * @memberof ProtobufClient.APIAuthenticationMessage
         * @instance
         */
        APIAuthenticationMessage.prototype.nonce = "";
        /**
         * APIAuthenticationMessage apiKey.
         * @member {string} apiKey
         * @memberof ProtobufClient.APIAuthenticationMessage
         * @instance
         */
        APIAuthenticationMessage.prototype.apiKey = "";
        /**
         * APIAuthenticationMessage source.
         * @member {ProtobufClient.APIAuthenticationMessage.Source} source
         * @memberof ProtobufClient.APIAuthenticationMessage
         * @instance
         */
        APIAuthenticationMessage.prototype.source = 0;
        /**
         * APIAuthenticationMessage version.
         * @member {string} version
         * @memberof ProtobufClient.APIAuthenticationMessage
         * @instance
         */
        APIAuthenticationMessage.prototype.version = "";
        /**
         * APIAuthenticationMessage subscriptions.
         * @member {Array.<string>} subscriptions
         * @memberof ProtobufClient.APIAuthenticationMessage
         * @instance
         */
        APIAuthenticationMessage.prototype.subscriptions = $util.emptyArray;
        /**
         * APIAuthenticationMessage clientSubscriptions.
         * @member {Array.<ProtobufClient.IClientSubscription>} clientSubscriptions
         * @memberof ProtobufClient.APIAuthenticationMessage
         * @instance
         */
        APIAuthenticationMessage.prototype.clientSubscriptions = $util.emptyArray;
        /**
         * Creates a new APIAuthenticationMessage instance using the specified properties.
         * @function create
         * @memberof ProtobufClient.APIAuthenticationMessage
         * @static
         * @param {ProtobufClient.IAPIAuthenticationMessage=} [properties] Properties to set
         * @returns {ProtobufClient.APIAuthenticationMessage} APIAuthenticationMessage instance
         */
        APIAuthenticationMessage.create = function create(properties) {
            return new APIAuthenticationMessage(properties);
        };
        /**
         * Encodes the specified APIAuthenticationMessage message. Does not implicitly {@link ProtobufClient.APIAuthenticationMessage.verify|verify} messages.
         * @function encode
         * @memberof ProtobufClient.APIAuthenticationMessage
         * @static
         * @param {ProtobufClient.IAPIAuthenticationMessage} message APIAuthenticationMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        APIAuthenticationMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.token);
            if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nonce);
            if (message.apiKey != null && Object.hasOwnProperty.call(message, "apiKey"))
                writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.apiKey);
            if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.source);
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.version);
            if (message.subscriptions != null && message.subscriptions.length)
                for (var i = 0; i < message.subscriptions.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.subscriptions[i]);
            if (message.clientSubscriptions != null && message.clientSubscriptions.length)
                for (var i = 0; i < message.clientSubscriptions.length; ++i)
                    $root.ProtobufClient.ClientSubscription.encode(message.clientSubscriptions[i], writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified APIAuthenticationMessage message, length delimited. Does not implicitly {@link ProtobufClient.APIAuthenticationMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufClient.APIAuthenticationMessage
         * @static
         * @param {ProtobufClient.IAPIAuthenticationMessage} message APIAuthenticationMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        APIAuthenticationMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a APIAuthenticationMessage message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufClient.APIAuthenticationMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufClient.APIAuthenticationMessage} APIAuthenticationMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        APIAuthenticationMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufClient.APIAuthenticationMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.token = reader.string();
                        break;
                    case 2:
                        message.nonce = reader.string();
                        break;
                    case 3:
                        message.apiKey = reader.string();
                        break;
                    case 4:
                        message.source = reader.int32();
                        break;
                    case 5:
                        message.version = reader.string();
                        break;
                    case 6:
                        if (!(message.subscriptions && message.subscriptions.length))
                            message.subscriptions = [];
                        message.subscriptions.push(reader.string());
                        break;
                    case 7:
                        if (!(message.clientSubscriptions && message.clientSubscriptions.length))
                            message.clientSubscriptions = [];
                        message.clientSubscriptions.push($root.ProtobufClient.ClientSubscription.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a APIAuthenticationMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufClient.APIAuthenticationMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufClient.APIAuthenticationMessage} APIAuthenticationMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        APIAuthenticationMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a APIAuthenticationMessage message.
         * @function verify
         * @memberof ProtobufClient.APIAuthenticationMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        APIAuthenticationMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!$util.isString(message.token))
                    return "token: string expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!$util.isString(message.nonce))
                    return "nonce: string expected";
            if (message.apiKey != null && message.hasOwnProperty("apiKey"))
                if (!$util.isString(message.apiKey))
                    return "apiKey: string expected";
            if (message.source != null && message.hasOwnProperty("source"))
                switch (message.source) {
                    default:
                        return "source: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 5:
                    case 4:
                        break;
                }
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            if (message.subscriptions != null && message.hasOwnProperty("subscriptions")) {
                if (!Array.isArray(message.subscriptions))
                    return "subscriptions: array expected";
                for (var i = 0; i < message.subscriptions.length; ++i)
                    if (!$util.isString(message.subscriptions[i]))
                        return "subscriptions: string[] expected";
            }
            if (message.clientSubscriptions != null && message.hasOwnProperty("clientSubscriptions")) {
                if (!Array.isArray(message.clientSubscriptions))
                    return "clientSubscriptions: array expected";
                for (var i = 0; i < message.clientSubscriptions.length; ++i) {
                    var error = $root.ProtobufClient.ClientSubscription.verify(message.clientSubscriptions[i]);
                    if (error)
                        return "clientSubscriptions." + error;
                }
            }
            return null;
        };
        /**
         * Creates a APIAuthenticationMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufClient.APIAuthenticationMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufClient.APIAuthenticationMessage} APIAuthenticationMessage
         */
        APIAuthenticationMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufClient.APIAuthenticationMessage)
                return object;
            var message = new $root.ProtobufClient.APIAuthenticationMessage();
            if (object.token != null)
                message.token = String(object.token);
            if (object.nonce != null)
                message.nonce = String(object.nonce);
            if (object.apiKey != null)
                message.apiKey = String(object.apiKey);
            switch (object.source) {
                case "UNKNOWN":
                case 0:
                    message.source = 0;
                    break;
                case "GOLANG_SDK":
                case 1:
                    message.source = 1;
                    break;
                case "JAVASCRIPT_SDK":
                case 2:
                    message.source = 2;
                    break;
                case "NODE_SDK":
                case 3:
                    message.source = 3;
                    break;
                case "RUST_SDK":
                case 5:
                    message.source = 5;
                    break;
                case "CW_WEB":
                case 4:
                    message.source = 4;
                    break;
            }
            if (object.version != null)
                message.version = String(object.version);
            if (object.subscriptions) {
                if (!Array.isArray(object.subscriptions))
                    throw TypeError(".ProtobufClient.APIAuthenticationMessage.subscriptions: array expected");
                message.subscriptions = [];
                for (var i = 0; i < object.subscriptions.length; ++i)
                    message.subscriptions[i] = String(object.subscriptions[i]);
            }
            if (object.clientSubscriptions) {
                if (!Array.isArray(object.clientSubscriptions))
                    throw TypeError(".ProtobufClient.APIAuthenticationMessage.clientSubscriptions: array expected");
                message.clientSubscriptions = [];
                for (var i = 0; i < object.clientSubscriptions.length; ++i) {
                    if (typeof object.clientSubscriptions[i] !== "object")
                        throw TypeError(".ProtobufClient.APIAuthenticationMessage.clientSubscriptions: object expected");
                    message.clientSubscriptions[i] = $root.ProtobufClient.ClientSubscription.fromObject(object.clientSubscriptions[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a APIAuthenticationMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufClient.APIAuthenticationMessage
         * @static
         * @param {ProtobufClient.APIAuthenticationMessage} message APIAuthenticationMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        APIAuthenticationMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.subscriptions = [];
                object.clientSubscriptions = [];
            }
            if (options.defaults) {
                object.token = "";
                object.nonce = "";
                object.apiKey = "";
                object.source = options.enums === String ? "UNKNOWN" : 0;
                object.version = "";
            }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = message.token;
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = message.nonce;
            if (message.apiKey != null && message.hasOwnProperty("apiKey"))
                object.apiKey = message.apiKey;
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = options.enums === String ? $root.ProtobufClient.APIAuthenticationMessage.Source[message.source] : message.source;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.subscriptions && message.subscriptions.length) {
                object.subscriptions = [];
                for (var j = 0; j < message.subscriptions.length; ++j)
                    object.subscriptions[j] = message.subscriptions[j];
            }
            if (message.clientSubscriptions && message.clientSubscriptions.length) {
                object.clientSubscriptions = [];
                for (var j = 0; j < message.clientSubscriptions.length; ++j)
                    object.clientSubscriptions[j] = $root.ProtobufClient.ClientSubscription.toObject(message.clientSubscriptions[j], options);
            }
            return object;
        };
        /**
         * Converts this APIAuthenticationMessage to JSON.
         * @function toJSON
         * @memberof ProtobufClient.APIAuthenticationMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        APIAuthenticationMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Source enum.
         * @name ProtobufClient.APIAuthenticationMessage.Source
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} GOLANG_SDK=1 GOLANG_SDK value
         * @property {number} JAVASCRIPT_SDK=2 JAVASCRIPT_SDK value
         * @property {number} NODE_SDK=3 NODE_SDK value
         * @property {number} RUST_SDK=5 RUST_SDK value
         * @property {number} CW_WEB=4 CW_WEB value
         */
        APIAuthenticationMessage.Source = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "GOLANG_SDK"] = 1;
            values[valuesById[2] = "JAVASCRIPT_SDK"] = 2;
            values[valuesById[3] = "NODE_SDK"] = 3;
            values[valuesById[5] = "RUST_SDK"] = 5;
            values[valuesById[4] = "CW_WEB"] = 4;
            return values;
        })();
        return APIAuthenticationMessage;
    })();
    ProtobufClient.ClientSessionMessage = (function () {
        /**
         * Properties of a ClientSessionMessage.
         * @memberof ProtobufClient
         * @interface IClientSessionMessage
         * @property {ProtobufClient.ClientSessionMessage.ISession|null} [session] ClientSessionMessage session
         * @property {ProtobufClient.ClientSessionMessage.IAnonymousTradingSession|null} [anonymousTradingSession] ClientSessionMessage anonymousTradingSession
         * @property {ProtobufClient.ClientSessionMessage.IAnonymousUserSession|null} [anonymousUserSession] ClientSessionMessage anonymousUserSession
         * @property {ProtobufClient.IClientIdentificationMessage|null} [identification] ClientSessionMessage identification
         */
        /**
         * Constructs a new ClientSessionMessage.
         * @memberof ProtobufClient
         * @classdesc Represents a ClientSessionMessage.
         * @implements IClientSessionMessage
         * @constructor
         * @param {ProtobufClient.IClientSessionMessage=} [properties] Properties to set
         */
        function ClientSessionMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ClientSessionMessage session.
         * @member {ProtobufClient.ClientSessionMessage.ISession|null|undefined} session
         * @memberof ProtobufClient.ClientSessionMessage
         * @instance
         */
        ClientSessionMessage.prototype.session = null;
        /**
         * ClientSessionMessage anonymousTradingSession.
         * @member {ProtobufClient.ClientSessionMessage.IAnonymousTradingSession|null|undefined} anonymousTradingSession
         * @memberof ProtobufClient.ClientSessionMessage
         * @instance
         */
        ClientSessionMessage.prototype.anonymousTradingSession = null;
        /**
         * ClientSessionMessage anonymousUserSession.
         * @member {ProtobufClient.ClientSessionMessage.IAnonymousUserSession|null|undefined} anonymousUserSession
         * @memberof ProtobufClient.ClientSessionMessage
         * @instance
         */
        ClientSessionMessage.prototype.anonymousUserSession = null;
        /**
         * ClientSessionMessage identification.
         * @member {ProtobufClient.IClientIdentificationMessage|null|undefined} identification
         * @memberof ProtobufClient.ClientSessionMessage
         * @instance
         */
        ClientSessionMessage.prototype.identification = null;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * ClientSessionMessage SessionConfig.
         * @member {"session"|"anonymousTradingSession"|"anonymousUserSession"|undefined} SessionConfig
         * @memberof ProtobufClient.ClientSessionMessage
         * @instance
         */
        Object.defineProperty(ClientSessionMessage.prototype, "SessionConfig", {
            get: $util.oneOfGetter($oneOfFields = ["session", "anonymousTradingSession", "anonymousUserSession"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new ClientSessionMessage instance using the specified properties.
         * @function create
         * @memberof ProtobufClient.ClientSessionMessage
         * @static
         * @param {ProtobufClient.IClientSessionMessage=} [properties] Properties to set
         * @returns {ProtobufClient.ClientSessionMessage} ClientSessionMessage instance
         */
        ClientSessionMessage.create = function create(properties) {
            return new ClientSessionMessage(properties);
        };
        /**
         * Encodes the specified ClientSessionMessage message. Does not implicitly {@link ProtobufClient.ClientSessionMessage.verify|verify} messages.
         * @function encode
         * @memberof ProtobufClient.ClientSessionMessage
         * @static
         * @param {ProtobufClient.IClientSessionMessage} message ClientSessionMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientSessionMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.session != null && Object.hasOwnProperty.call(message, "session"))
                $root.ProtobufClient.ClientSessionMessage.Session.encode(message.session, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.anonymousTradingSession != null && Object.hasOwnProperty.call(message, "anonymousTradingSession"))
                $root.ProtobufClient.ClientSessionMessage.AnonymousTradingSession.encode(message.anonymousTradingSession, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.identification != null && Object.hasOwnProperty.call(message, "identification"))
                $root.ProtobufClient.ClientIdentificationMessage.encode(message.identification, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.anonymousUserSession != null && Object.hasOwnProperty.call(message, "anonymousUserSession"))
                $root.ProtobufClient.ClientSessionMessage.AnonymousUserSession.encode(message.anonymousUserSession, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified ClientSessionMessage message, length delimited. Does not implicitly {@link ProtobufClient.ClientSessionMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufClient.ClientSessionMessage
         * @static
         * @param {ProtobufClient.IClientSessionMessage} message ClientSessionMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientSessionMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ClientSessionMessage message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufClient.ClientSessionMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufClient.ClientSessionMessage} ClientSessionMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientSessionMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufClient.ClientSessionMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.session = $root.ProtobufClient.ClientSessionMessage.Session.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.anonymousTradingSession = $root.ProtobufClient.ClientSessionMessage.AnonymousTradingSession.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.anonymousUserSession = $root.ProtobufClient.ClientSessionMessage.AnonymousUserSession.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.identification = $root.ProtobufClient.ClientIdentificationMessage.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ClientSessionMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufClient.ClientSessionMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufClient.ClientSessionMessage} ClientSessionMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientSessionMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ClientSessionMessage message.
         * @function verify
         * @memberof ProtobufClient.ClientSessionMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientSessionMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.session != null && message.hasOwnProperty("session")) {
                properties.SessionConfig = 1;
                {
                    var error = $root.ProtobufClient.ClientSessionMessage.Session.verify(message.session);
                    if (error)
                        return "session." + error;
                }
            }
            if (message.anonymousTradingSession != null && message.hasOwnProperty("anonymousTradingSession")) {
                if (properties.SessionConfig === 1)
                    return "SessionConfig: multiple values";
                properties.SessionConfig = 1;
                {
                    var error = $root.ProtobufClient.ClientSessionMessage.AnonymousTradingSession.verify(message.anonymousTradingSession);
                    if (error)
                        return "anonymousTradingSession." + error;
                }
            }
            if (message.anonymousUserSession != null && message.hasOwnProperty("anonymousUserSession")) {
                if (properties.SessionConfig === 1)
                    return "SessionConfig: multiple values";
                properties.SessionConfig = 1;
                {
                    var error = $root.ProtobufClient.ClientSessionMessage.AnonymousUserSession.verify(message.anonymousUserSession);
                    if (error)
                        return "anonymousUserSession." + error;
                }
            }
            if (message.identification != null && message.hasOwnProperty("identification")) {
                var error = $root.ProtobufClient.ClientIdentificationMessage.verify(message.identification);
                if (error)
                    return "identification." + error;
            }
            return null;
        };
        /**
         * Creates a ClientSessionMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufClient.ClientSessionMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufClient.ClientSessionMessage} ClientSessionMessage
         */
        ClientSessionMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufClient.ClientSessionMessage)
                return object;
            var message = new $root.ProtobufClient.ClientSessionMessage();
            if (object.session != null) {
                if (typeof object.session !== "object")
                    throw TypeError(".ProtobufClient.ClientSessionMessage.session: object expected");
                message.session = $root.ProtobufClient.ClientSessionMessage.Session.fromObject(object.session);
            }
            if (object.anonymousTradingSession != null) {
                if (typeof object.anonymousTradingSession !== "object")
                    throw TypeError(".ProtobufClient.ClientSessionMessage.anonymousTradingSession: object expected");
                message.anonymousTradingSession = $root.ProtobufClient.ClientSessionMessage.AnonymousTradingSession.fromObject(object.anonymousTradingSession);
            }
            if (object.anonymousUserSession != null) {
                if (typeof object.anonymousUserSession !== "object")
                    throw TypeError(".ProtobufClient.ClientSessionMessage.anonymousUserSession: object expected");
                message.anonymousUserSession = $root.ProtobufClient.ClientSessionMessage.AnonymousUserSession.fromObject(object.anonymousUserSession);
            }
            if (object.identification != null) {
                if (typeof object.identification !== "object")
                    throw TypeError(".ProtobufClient.ClientSessionMessage.identification: object expected");
                message.identification = $root.ProtobufClient.ClientIdentificationMessage.fromObject(object.identification);
            }
            return message;
        };
        /**
         * Creates a plain object from a ClientSessionMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufClient.ClientSessionMessage
         * @static
         * @param {ProtobufClient.ClientSessionMessage} message ClientSessionMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientSessionMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.identification = null;
            if (message.session != null && message.hasOwnProperty("session")) {
                object.session = $root.ProtobufClient.ClientSessionMessage.Session.toObject(message.session, options);
                if (options.oneofs)
                    object.SessionConfig = "session";
            }
            if (message.anonymousTradingSession != null && message.hasOwnProperty("anonymousTradingSession")) {
                object.anonymousTradingSession = $root.ProtobufClient.ClientSessionMessage.AnonymousTradingSession.toObject(message.anonymousTradingSession, options);
                if (options.oneofs)
                    object.SessionConfig = "anonymousTradingSession";
            }
            if (message.identification != null && message.hasOwnProperty("identification"))
                object.identification = $root.ProtobufClient.ClientIdentificationMessage.toObject(message.identification, options);
            if (message.anonymousUserSession != null && message.hasOwnProperty("anonymousUserSession")) {
                object.anonymousUserSession = $root.ProtobufClient.ClientSessionMessage.AnonymousUserSession.toObject(message.anonymousUserSession, options);
                if (options.oneofs)
                    object.SessionConfig = "anonymousUserSession";
            }
            return object;
        };
        /**
         * Converts this ClientSessionMessage to JSON.
         * @function toJSON
         * @memberof ProtobufClient.ClientSessionMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientSessionMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        ClientSessionMessage.Session = (function () {
            /**
             * Properties of a Session.
             * @memberof ProtobufClient.ClientSessionMessage
             * @interface ISession
             * @property {string|null} [userId] Session userId
             * @property {number|Long|null} [expires] Session expires
             * @property {string|null} [token] Session token
             * @property {string|null} [mfaToken] Session mfaToken
             */
            /**
             * Constructs a new Session.
             * @memberof ProtobufClient.ClientSessionMessage
             * @classdesc Represents a Session.
             * @implements ISession
             * @constructor
             * @param {ProtobufClient.ClientSessionMessage.ISession=} [properties] Properties to set
             */
            function Session(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Session userId.
             * @member {string} userId
             * @memberof ProtobufClient.ClientSessionMessage.Session
             * @instance
             */
            Session.prototype.userId = "";
            /**
             * Session expires.
             * @member {number|Long} expires
             * @memberof ProtobufClient.ClientSessionMessage.Session
             * @instance
             */
            Session.prototype.expires = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Session token.
             * @member {string} token
             * @memberof ProtobufClient.ClientSessionMessage.Session
             * @instance
             */
            Session.prototype.token = "";
            /**
             * Session mfaToken.
             * @member {string} mfaToken
             * @memberof ProtobufClient.ClientSessionMessage.Session
             * @instance
             */
            Session.prototype.mfaToken = "";
            /**
             * Creates a new Session instance using the specified properties.
             * @function create
             * @memberof ProtobufClient.ClientSessionMessage.Session
             * @static
             * @param {ProtobufClient.ClientSessionMessage.ISession=} [properties] Properties to set
             * @returns {ProtobufClient.ClientSessionMessage.Session} Session instance
             */
            Session.create = function create(properties) {
                return new Session(properties);
            };
            /**
             * Encodes the specified Session message. Does not implicitly {@link ProtobufClient.ClientSessionMessage.Session.verify|verify} messages.
             * @function encode
             * @memberof ProtobufClient.ClientSessionMessage.Session
             * @static
             * @param {ProtobufClient.ClientSessionMessage.ISession} message Session message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Session.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.userId);
                if (message.expires != null && Object.hasOwnProperty.call(message, "expires"))
                    writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.expires);
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.token);
                if (message.mfaToken != null && Object.hasOwnProperty.call(message, "mfaToken"))
                    writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.mfaToken);
                return writer;
            };
            /**
             * Encodes the specified Session message, length delimited. Does not implicitly {@link ProtobufClient.ClientSessionMessage.Session.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ProtobufClient.ClientSessionMessage.Session
             * @static
             * @param {ProtobufClient.ClientSessionMessage.ISession} message Session message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Session.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Session message from the specified reader or buffer.
             * @function decode
             * @memberof ProtobufClient.ClientSessionMessage.Session
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ProtobufClient.ClientSessionMessage.Session} Session
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Session.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufClient.ClientSessionMessage.Session();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.userId = reader.string();
                            break;
                        case 2:
                            message.expires = reader.int64();
                            break;
                        case 3:
                            message.token = reader.string();
                            break;
                        case 4:
                            message.mfaToken = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a Session message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ProtobufClient.ClientSessionMessage.Session
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ProtobufClient.ClientSessionMessage.Session} Session
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Session.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Session message.
             * @function verify
             * @memberof ProtobufClient.ClientSessionMessage.Session
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Session.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userId != null && message.hasOwnProperty("userId"))
                    if (!$util.isString(message.userId))
                        return "userId: string expected";
                if (message.expires != null && message.hasOwnProperty("expires"))
                    if (!$util.isInteger(message.expires) && !(message.expires && $util.isInteger(message.expires.low) && $util.isInteger(message.expires.high)))
                        return "expires: integer|Long expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                if (message.mfaToken != null && message.hasOwnProperty("mfaToken"))
                    if (!$util.isString(message.mfaToken))
                        return "mfaToken: string expected";
                return null;
            };
            /**
             * Creates a Session message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ProtobufClient.ClientSessionMessage.Session
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ProtobufClient.ClientSessionMessage.Session} Session
             */
            Session.fromObject = function fromObject(object) {
                if (object instanceof $root.ProtobufClient.ClientSessionMessage.Session)
                    return object;
                var message = new $root.ProtobufClient.ClientSessionMessage.Session();
                if (object.userId != null)
                    message.userId = String(object.userId);
                if (object.expires != null)
                    if ($util.Long)
                        (message.expires = $util.Long.fromValue(object.expires)).unsigned = false;
                    else if (typeof object.expires === "string")
                        message.expires = parseInt(object.expires, 10);
                    else if (typeof object.expires === "number")
                        message.expires = object.expires;
                    else if (typeof object.expires === "object")
                        message.expires = new $util.LongBits(object.expires.low >>> 0, object.expires.high >>> 0).toNumber();
                if (object.token != null)
                    message.token = String(object.token);
                if (object.mfaToken != null)
                    message.mfaToken = String(object.mfaToken);
                return message;
            };
            /**
             * Creates a plain object from a Session message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ProtobufClient.ClientSessionMessage.Session
             * @static
             * @param {ProtobufClient.ClientSessionMessage.Session} message Session
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Session.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.userId = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.expires = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.expires = options.longs === String ? "0" : 0;
                    object.token = "";
                    object.mfaToken = "";
                }
                if (message.userId != null && message.hasOwnProperty("userId"))
                    object.userId = message.userId;
                if (message.expires != null && message.hasOwnProperty("expires"))
                    if (typeof message.expires === "number")
                        object.expires = options.longs === String ? String(message.expires) : message.expires;
                    else
                        object.expires = options.longs === String ? $util.Long.prototype.toString.call(message.expires) : options.longs === Number ? new $util.LongBits(message.expires.low >>> 0, message.expires.high >>> 0).toNumber() : message.expires;
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = message.token;
                if (message.mfaToken != null && message.hasOwnProperty("mfaToken"))
                    object.mfaToken = message.mfaToken;
                return object;
            };
            /**
             * Converts this Session to JSON.
             * @function toJSON
             * @memberof ProtobufClient.ClientSessionMessage.Session
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Session.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Session;
        })();
        ClientSessionMessage.AnonymousTradingSession = (function () {
            /**
             * Properties of an AnonymousTradingSession.
             * @memberof ProtobufClient.ClientSessionMessage
             * @interface IAnonymousTradingSession
             * @property {string|null} [exchange] AnonymousTradingSession exchange
             * @property {string|null} [token] AnonymousTradingSession token
             * @property {number|Long|null} [expiration] AnonymousTradingSession expiration
             */
            /**
             * Constructs a new AnonymousTradingSession.
             * @memberof ProtobufClient.ClientSessionMessage
             * @classdesc Represents an AnonymousTradingSession.
             * @implements IAnonymousTradingSession
             * @constructor
             * @param {ProtobufClient.ClientSessionMessage.IAnonymousTradingSession=} [properties] Properties to set
             */
            function AnonymousTradingSession(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * AnonymousTradingSession exchange.
             * @member {string} exchange
             * @memberof ProtobufClient.ClientSessionMessage.AnonymousTradingSession
             * @instance
             */
            AnonymousTradingSession.prototype.exchange = "";
            /**
             * AnonymousTradingSession token.
             * @member {string} token
             * @memberof ProtobufClient.ClientSessionMessage.AnonymousTradingSession
             * @instance
             */
            AnonymousTradingSession.prototype.token = "";
            /**
             * AnonymousTradingSession expiration.
             * @member {number|Long} expiration
             * @memberof ProtobufClient.ClientSessionMessage.AnonymousTradingSession
             * @instance
             */
            AnonymousTradingSession.prototype.expiration = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Creates a new AnonymousTradingSession instance using the specified properties.
             * @function create
             * @memberof ProtobufClient.ClientSessionMessage.AnonymousTradingSession
             * @static
             * @param {ProtobufClient.ClientSessionMessage.IAnonymousTradingSession=} [properties] Properties to set
             * @returns {ProtobufClient.ClientSessionMessage.AnonymousTradingSession} AnonymousTradingSession instance
             */
            AnonymousTradingSession.create = function create(properties) {
                return new AnonymousTradingSession(properties);
            };
            /**
             * Encodes the specified AnonymousTradingSession message. Does not implicitly {@link ProtobufClient.ClientSessionMessage.AnonymousTradingSession.verify|verify} messages.
             * @function encode
             * @memberof ProtobufClient.ClientSessionMessage.AnonymousTradingSession
             * @static
             * @param {ProtobufClient.ClientSessionMessage.IAnonymousTradingSession} message AnonymousTradingSession message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnonymousTradingSession.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.exchange != null && Object.hasOwnProperty.call(message, "exchange"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.exchange);
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.token);
                if (message.expiration != null && Object.hasOwnProperty.call(message, "expiration"))
                    writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.expiration);
                return writer;
            };
            /**
             * Encodes the specified AnonymousTradingSession message, length delimited. Does not implicitly {@link ProtobufClient.ClientSessionMessage.AnonymousTradingSession.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ProtobufClient.ClientSessionMessage.AnonymousTradingSession
             * @static
             * @param {ProtobufClient.ClientSessionMessage.IAnonymousTradingSession} message AnonymousTradingSession message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnonymousTradingSession.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an AnonymousTradingSession message from the specified reader or buffer.
             * @function decode
             * @memberof ProtobufClient.ClientSessionMessage.AnonymousTradingSession
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ProtobufClient.ClientSessionMessage.AnonymousTradingSession} AnonymousTradingSession
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnonymousTradingSession.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufClient.ClientSessionMessage.AnonymousTradingSession();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.exchange = reader.string();
                            break;
                        case 2:
                            message.token = reader.string();
                            break;
                        case 3:
                            message.expiration = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes an AnonymousTradingSession message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ProtobufClient.ClientSessionMessage.AnonymousTradingSession
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ProtobufClient.ClientSessionMessage.AnonymousTradingSession} AnonymousTradingSession
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnonymousTradingSession.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an AnonymousTradingSession message.
             * @function verify
             * @memberof ProtobufClient.ClientSessionMessage.AnonymousTradingSession
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AnonymousTradingSession.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.exchange != null && message.hasOwnProperty("exchange"))
                    if (!$util.isString(message.exchange))
                        return "exchange: string expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                if (message.expiration != null && message.hasOwnProperty("expiration"))
                    if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                        return "expiration: integer|Long expected";
                return null;
            };
            /**
             * Creates an AnonymousTradingSession message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ProtobufClient.ClientSessionMessage.AnonymousTradingSession
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ProtobufClient.ClientSessionMessage.AnonymousTradingSession} AnonymousTradingSession
             */
            AnonymousTradingSession.fromObject = function fromObject(object) {
                if (object instanceof $root.ProtobufClient.ClientSessionMessage.AnonymousTradingSession)
                    return object;
                var message = new $root.ProtobufClient.ClientSessionMessage.AnonymousTradingSession();
                if (object.exchange != null)
                    message.exchange = String(object.exchange);
                if (object.token != null)
                    message.token = String(object.token);
                if (object.expiration != null)
                    if ($util.Long)
                        (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                    else if (typeof object.expiration === "string")
                        message.expiration = parseInt(object.expiration, 10);
                    else if (typeof object.expiration === "number")
                        message.expiration = object.expiration;
                    else if (typeof object.expiration === "object")
                        message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
                return message;
            };
            /**
             * Creates a plain object from an AnonymousTradingSession message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ProtobufClient.ClientSessionMessage.AnonymousTradingSession
             * @static
             * @param {ProtobufClient.ClientSessionMessage.AnonymousTradingSession} message AnonymousTradingSession
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AnonymousTradingSession.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.exchange = "";
                    object.token = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.expiration = options.longs === String ? "0" : 0;
                }
                if (message.exchange != null && message.hasOwnProperty("exchange"))
                    object.exchange = message.exchange;
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = message.token;
                if (message.expiration != null && message.hasOwnProperty("expiration"))
                    if (typeof message.expiration === "number")
                        object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                    else
                        object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
                return object;
            };
            /**
             * Converts this AnonymousTradingSession to JSON.
             * @function toJSON
             * @memberof ProtobufClient.ClientSessionMessage.AnonymousTradingSession
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AnonymousTradingSession.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return AnonymousTradingSession;
        })();
        ClientSessionMessage.AnonymousUserSession = (function () {
            /**
             * Properties of an AnonymousUserSession.
             * @memberof ProtobufClient.ClientSessionMessage
             * @interface IAnonymousUserSession
             * @property {string|null} [token] AnonymousUserSession token
             */
            /**
             * Constructs a new AnonymousUserSession.
             * @memberof ProtobufClient.ClientSessionMessage
             * @classdesc Represents an AnonymousUserSession.
             * @implements IAnonymousUserSession
             * @constructor
             * @param {ProtobufClient.ClientSessionMessage.IAnonymousUserSession=} [properties] Properties to set
             */
            function AnonymousUserSession(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * AnonymousUserSession token.
             * @member {string} token
             * @memberof ProtobufClient.ClientSessionMessage.AnonymousUserSession
             * @instance
             */
            AnonymousUserSession.prototype.token = "";
            /**
             * Creates a new AnonymousUserSession instance using the specified properties.
             * @function create
             * @memberof ProtobufClient.ClientSessionMessage.AnonymousUserSession
             * @static
             * @param {ProtobufClient.ClientSessionMessage.IAnonymousUserSession=} [properties] Properties to set
             * @returns {ProtobufClient.ClientSessionMessage.AnonymousUserSession} AnonymousUserSession instance
             */
            AnonymousUserSession.create = function create(properties) {
                return new AnonymousUserSession(properties);
            };
            /**
             * Encodes the specified AnonymousUserSession message. Does not implicitly {@link ProtobufClient.ClientSessionMessage.AnonymousUserSession.verify|verify} messages.
             * @function encode
             * @memberof ProtobufClient.ClientSessionMessage.AnonymousUserSession
             * @static
             * @param {ProtobufClient.ClientSessionMessage.IAnonymousUserSession} message AnonymousUserSession message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnonymousUserSession.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.token);
                return writer;
            };
            /**
             * Encodes the specified AnonymousUserSession message, length delimited. Does not implicitly {@link ProtobufClient.ClientSessionMessage.AnonymousUserSession.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ProtobufClient.ClientSessionMessage.AnonymousUserSession
             * @static
             * @param {ProtobufClient.ClientSessionMessage.IAnonymousUserSession} message AnonymousUserSession message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnonymousUserSession.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an AnonymousUserSession message from the specified reader or buffer.
             * @function decode
             * @memberof ProtobufClient.ClientSessionMessage.AnonymousUserSession
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ProtobufClient.ClientSessionMessage.AnonymousUserSession} AnonymousUserSession
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnonymousUserSession.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufClient.ClientSessionMessage.AnonymousUserSession();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.token = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes an AnonymousUserSession message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ProtobufClient.ClientSessionMessage.AnonymousUserSession
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ProtobufClient.ClientSessionMessage.AnonymousUserSession} AnonymousUserSession
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnonymousUserSession.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an AnonymousUserSession message.
             * @function verify
             * @memberof ProtobufClient.ClientSessionMessage.AnonymousUserSession
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AnonymousUserSession.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                return null;
            };
            /**
             * Creates an AnonymousUserSession message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ProtobufClient.ClientSessionMessage.AnonymousUserSession
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ProtobufClient.ClientSessionMessage.AnonymousUserSession} AnonymousUserSession
             */
            AnonymousUserSession.fromObject = function fromObject(object) {
                if (object instanceof $root.ProtobufClient.ClientSessionMessage.AnonymousUserSession)
                    return object;
                var message = new $root.ProtobufClient.ClientSessionMessage.AnonymousUserSession();
                if (object.token != null)
                    message.token = String(object.token);
                return message;
            };
            /**
             * Creates a plain object from an AnonymousUserSession message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ProtobufClient.ClientSessionMessage.AnonymousUserSession
             * @static
             * @param {ProtobufClient.ClientSessionMessage.AnonymousUserSession} message AnonymousUserSession
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AnonymousUserSession.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.token = "";
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = message.token;
                return object;
            };
            /**
             * Converts this AnonymousUserSession to JSON.
             * @function toJSON
             * @memberof ProtobufClient.ClientSessionMessage.AnonymousUserSession
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AnonymousUserSession.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return AnonymousUserSession;
        })();
        return ClientSessionMessage;
    })();
    ProtobufClient.ClientSubscribeMessage = (function () {
        /**
         * Properties of a ClientSubscribeMessage.
         * @memberof ProtobufClient
         * @interface IClientSubscribeMessage
         * @property {Array.<string>|null} [subscriptionKeys] ClientSubscribeMessage subscriptionKeys
         * @property {Array.<ProtobufClient.IClientSubscription>|null} [subscriptions] ClientSubscribeMessage subscriptions
         */
        /**
         * Constructs a new ClientSubscribeMessage.
         * @memberof ProtobufClient
         * @classdesc Represents a ClientSubscribeMessage.
         * @implements IClientSubscribeMessage
         * @constructor
         * @param {ProtobufClient.IClientSubscribeMessage=} [properties] Properties to set
         */
        function ClientSubscribeMessage(properties) {
            this.subscriptionKeys = [];
            this.subscriptions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ClientSubscribeMessage subscriptionKeys.
         * @member {Array.<string>} subscriptionKeys
         * @memberof ProtobufClient.ClientSubscribeMessage
         * @instance
         */
        ClientSubscribeMessage.prototype.subscriptionKeys = $util.emptyArray;
        /**
         * ClientSubscribeMessage subscriptions.
         * @member {Array.<ProtobufClient.IClientSubscription>} subscriptions
         * @memberof ProtobufClient.ClientSubscribeMessage
         * @instance
         */
        ClientSubscribeMessage.prototype.subscriptions = $util.emptyArray;
        /**
         * Creates a new ClientSubscribeMessage instance using the specified properties.
         * @function create
         * @memberof ProtobufClient.ClientSubscribeMessage
         * @static
         * @param {ProtobufClient.IClientSubscribeMessage=} [properties] Properties to set
         * @returns {ProtobufClient.ClientSubscribeMessage} ClientSubscribeMessage instance
         */
        ClientSubscribeMessage.create = function create(properties) {
            return new ClientSubscribeMessage(properties);
        };
        /**
         * Encodes the specified ClientSubscribeMessage message. Does not implicitly {@link ProtobufClient.ClientSubscribeMessage.verify|verify} messages.
         * @function encode
         * @memberof ProtobufClient.ClientSubscribeMessage
         * @static
         * @param {ProtobufClient.IClientSubscribeMessage} message ClientSubscribeMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientSubscribeMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.subscriptionKeys != null && message.subscriptionKeys.length)
                for (var i = 0; i < message.subscriptionKeys.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.subscriptionKeys[i]);
            if (message.subscriptions != null && message.subscriptions.length)
                for (var i = 0; i < message.subscriptions.length; ++i)
                    $root.ProtobufClient.ClientSubscription.encode(message.subscriptions[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified ClientSubscribeMessage message, length delimited. Does not implicitly {@link ProtobufClient.ClientSubscribeMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufClient.ClientSubscribeMessage
         * @static
         * @param {ProtobufClient.IClientSubscribeMessage} message ClientSubscribeMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientSubscribeMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ClientSubscribeMessage message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufClient.ClientSubscribeMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufClient.ClientSubscribeMessage} ClientSubscribeMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientSubscribeMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufClient.ClientSubscribeMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.subscriptionKeys && message.subscriptionKeys.length))
                            message.subscriptionKeys = [];
                        message.subscriptionKeys.push(reader.string());
                        break;
                    case 2:
                        if (!(message.subscriptions && message.subscriptions.length))
                            message.subscriptions = [];
                        message.subscriptions.push($root.ProtobufClient.ClientSubscription.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ClientSubscribeMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufClient.ClientSubscribeMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufClient.ClientSubscribeMessage} ClientSubscribeMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientSubscribeMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ClientSubscribeMessage message.
         * @function verify
         * @memberof ProtobufClient.ClientSubscribeMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientSubscribeMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.subscriptionKeys != null && message.hasOwnProperty("subscriptionKeys")) {
                if (!Array.isArray(message.subscriptionKeys))
                    return "subscriptionKeys: array expected";
                for (var i = 0; i < message.subscriptionKeys.length; ++i)
                    if (!$util.isString(message.subscriptionKeys[i]))
                        return "subscriptionKeys: string[] expected";
            }
            if (message.subscriptions != null && message.hasOwnProperty("subscriptions")) {
                if (!Array.isArray(message.subscriptions))
                    return "subscriptions: array expected";
                for (var i = 0; i < message.subscriptions.length; ++i) {
                    var error = $root.ProtobufClient.ClientSubscription.verify(message.subscriptions[i]);
                    if (error)
                        return "subscriptions." + error;
                }
            }
            return null;
        };
        /**
         * Creates a ClientSubscribeMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufClient.ClientSubscribeMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufClient.ClientSubscribeMessage} ClientSubscribeMessage
         */
        ClientSubscribeMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufClient.ClientSubscribeMessage)
                return object;
            var message = new $root.ProtobufClient.ClientSubscribeMessage();
            if (object.subscriptionKeys) {
                if (!Array.isArray(object.subscriptionKeys))
                    throw TypeError(".ProtobufClient.ClientSubscribeMessage.subscriptionKeys: array expected");
                message.subscriptionKeys = [];
                for (var i = 0; i < object.subscriptionKeys.length; ++i)
                    message.subscriptionKeys[i] = String(object.subscriptionKeys[i]);
            }
            if (object.subscriptions) {
                if (!Array.isArray(object.subscriptions))
                    throw TypeError(".ProtobufClient.ClientSubscribeMessage.subscriptions: array expected");
                message.subscriptions = [];
                for (var i = 0; i < object.subscriptions.length; ++i) {
                    if (typeof object.subscriptions[i] !== "object")
                        throw TypeError(".ProtobufClient.ClientSubscribeMessage.subscriptions: object expected");
                    message.subscriptions[i] = $root.ProtobufClient.ClientSubscription.fromObject(object.subscriptions[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a ClientSubscribeMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufClient.ClientSubscribeMessage
         * @static
         * @param {ProtobufClient.ClientSubscribeMessage} message ClientSubscribeMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientSubscribeMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.subscriptionKeys = [];
                object.subscriptions = [];
            }
            if (message.subscriptionKeys && message.subscriptionKeys.length) {
                object.subscriptionKeys = [];
                for (var j = 0; j < message.subscriptionKeys.length; ++j)
                    object.subscriptionKeys[j] = message.subscriptionKeys[j];
            }
            if (message.subscriptions && message.subscriptions.length) {
                object.subscriptions = [];
                for (var j = 0; j < message.subscriptions.length; ++j)
                    object.subscriptions[j] = $root.ProtobufClient.ClientSubscription.toObject(message.subscriptions[j], options);
            }
            return object;
        };
        /**
         * Converts this ClientSubscribeMessage to JSON.
         * @function toJSON
         * @memberof ProtobufClient.ClientSubscribeMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientSubscribeMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ClientSubscribeMessage;
    })();
    ProtobufClient.ClientUnsubscribeMessage = (function () {
        /**
         * Properties of a ClientUnsubscribeMessage.
         * @memberof ProtobufClient
         * @interface IClientUnsubscribeMessage
         * @property {Array.<string>|null} [subscriptionKeys] ClientUnsubscribeMessage subscriptionKeys
         * @property {Array.<ProtobufClient.IClientSubscription>|null} [subscriptions] ClientUnsubscribeMessage subscriptions
         */
        /**
         * Constructs a new ClientUnsubscribeMessage.
         * @memberof ProtobufClient
         * @classdesc Represents a ClientUnsubscribeMessage.
         * @implements IClientUnsubscribeMessage
         * @constructor
         * @param {ProtobufClient.IClientUnsubscribeMessage=} [properties] Properties to set
         */
        function ClientUnsubscribeMessage(properties) {
            this.subscriptionKeys = [];
            this.subscriptions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ClientUnsubscribeMessage subscriptionKeys.
         * @member {Array.<string>} subscriptionKeys
         * @memberof ProtobufClient.ClientUnsubscribeMessage
         * @instance
         */
        ClientUnsubscribeMessage.prototype.subscriptionKeys = $util.emptyArray;
        /**
         * ClientUnsubscribeMessage subscriptions.
         * @member {Array.<ProtobufClient.IClientSubscription>} subscriptions
         * @memberof ProtobufClient.ClientUnsubscribeMessage
         * @instance
         */
        ClientUnsubscribeMessage.prototype.subscriptions = $util.emptyArray;
        /**
         * Creates a new ClientUnsubscribeMessage instance using the specified properties.
         * @function create
         * @memberof ProtobufClient.ClientUnsubscribeMessage
         * @static
         * @param {ProtobufClient.IClientUnsubscribeMessage=} [properties] Properties to set
         * @returns {ProtobufClient.ClientUnsubscribeMessage} ClientUnsubscribeMessage instance
         */
        ClientUnsubscribeMessage.create = function create(properties) {
            return new ClientUnsubscribeMessage(properties);
        };
        /**
         * Encodes the specified ClientUnsubscribeMessage message. Does not implicitly {@link ProtobufClient.ClientUnsubscribeMessage.verify|verify} messages.
         * @function encode
         * @memberof ProtobufClient.ClientUnsubscribeMessage
         * @static
         * @param {ProtobufClient.IClientUnsubscribeMessage} message ClientUnsubscribeMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientUnsubscribeMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.subscriptionKeys != null && message.subscriptionKeys.length)
                for (var i = 0; i < message.subscriptionKeys.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.subscriptionKeys[i]);
            if (message.subscriptions != null && message.subscriptions.length)
                for (var i = 0; i < message.subscriptions.length; ++i)
                    $root.ProtobufClient.ClientSubscription.encode(message.subscriptions[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified ClientUnsubscribeMessage message, length delimited. Does not implicitly {@link ProtobufClient.ClientUnsubscribeMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufClient.ClientUnsubscribeMessage
         * @static
         * @param {ProtobufClient.IClientUnsubscribeMessage} message ClientUnsubscribeMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientUnsubscribeMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ClientUnsubscribeMessage message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufClient.ClientUnsubscribeMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufClient.ClientUnsubscribeMessage} ClientUnsubscribeMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientUnsubscribeMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufClient.ClientUnsubscribeMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.subscriptionKeys && message.subscriptionKeys.length))
                            message.subscriptionKeys = [];
                        message.subscriptionKeys.push(reader.string());
                        break;
                    case 2:
                        if (!(message.subscriptions && message.subscriptions.length))
                            message.subscriptions = [];
                        message.subscriptions.push($root.ProtobufClient.ClientSubscription.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ClientUnsubscribeMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufClient.ClientUnsubscribeMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufClient.ClientUnsubscribeMessage} ClientUnsubscribeMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientUnsubscribeMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ClientUnsubscribeMessage message.
         * @function verify
         * @memberof ProtobufClient.ClientUnsubscribeMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientUnsubscribeMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.subscriptionKeys != null && message.hasOwnProperty("subscriptionKeys")) {
                if (!Array.isArray(message.subscriptionKeys))
                    return "subscriptionKeys: array expected";
                for (var i = 0; i < message.subscriptionKeys.length; ++i)
                    if (!$util.isString(message.subscriptionKeys[i]))
                        return "subscriptionKeys: string[] expected";
            }
            if (message.subscriptions != null && message.hasOwnProperty("subscriptions")) {
                if (!Array.isArray(message.subscriptions))
                    return "subscriptions: array expected";
                for (var i = 0; i < message.subscriptions.length; ++i) {
                    var error = $root.ProtobufClient.ClientSubscription.verify(message.subscriptions[i]);
                    if (error)
                        return "subscriptions." + error;
                }
            }
            return null;
        };
        /**
         * Creates a ClientUnsubscribeMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufClient.ClientUnsubscribeMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufClient.ClientUnsubscribeMessage} ClientUnsubscribeMessage
         */
        ClientUnsubscribeMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufClient.ClientUnsubscribeMessage)
                return object;
            var message = new $root.ProtobufClient.ClientUnsubscribeMessage();
            if (object.subscriptionKeys) {
                if (!Array.isArray(object.subscriptionKeys))
                    throw TypeError(".ProtobufClient.ClientUnsubscribeMessage.subscriptionKeys: array expected");
                message.subscriptionKeys = [];
                for (var i = 0; i < object.subscriptionKeys.length; ++i)
                    message.subscriptionKeys[i] = String(object.subscriptionKeys[i]);
            }
            if (object.subscriptions) {
                if (!Array.isArray(object.subscriptions))
                    throw TypeError(".ProtobufClient.ClientUnsubscribeMessage.subscriptions: array expected");
                message.subscriptions = [];
                for (var i = 0; i < object.subscriptions.length; ++i) {
                    if (typeof object.subscriptions[i] !== "object")
                        throw TypeError(".ProtobufClient.ClientUnsubscribeMessage.subscriptions: object expected");
                    message.subscriptions[i] = $root.ProtobufClient.ClientSubscription.fromObject(object.subscriptions[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a ClientUnsubscribeMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufClient.ClientUnsubscribeMessage
         * @static
         * @param {ProtobufClient.ClientUnsubscribeMessage} message ClientUnsubscribeMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientUnsubscribeMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.subscriptionKeys = [];
                object.subscriptions = [];
            }
            if (message.subscriptionKeys && message.subscriptionKeys.length) {
                object.subscriptionKeys = [];
                for (var j = 0; j < message.subscriptionKeys.length; ++j)
                    object.subscriptionKeys[j] = message.subscriptionKeys[j];
            }
            if (message.subscriptions && message.subscriptions.length) {
                object.subscriptions = [];
                for (var j = 0; j < message.subscriptions.length; ++j)
                    object.subscriptions[j] = $root.ProtobufClient.ClientSubscription.toObject(message.subscriptions[j], options);
            }
            return object;
        };
        /**
         * Converts this ClientUnsubscribeMessage to JSON.
         * @function toJSON
         * @memberof ProtobufClient.ClientUnsubscribeMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientUnsubscribeMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ClientUnsubscribeMessage;
    })();
    return ProtobufClient;
})();
$root.ProtobufMarkets = (function () {
    /**
     * Namespace ProtobufMarkets.
     * @exports ProtobufMarkets
     * @namespace
     */
    var ProtobufMarkets = {};
    ProtobufMarkets.AssetUpdateMessage = (function () {
        /**
         * Properties of an AssetUpdateMessage.
         * @memberof ProtobufMarkets
         * @interface IAssetUpdateMessage
         * @property {number|null} [asset] AssetUpdateMessage asset
         * @property {ProtobufMarkets.IAssetUSDVolumeUpdate|null} [usdVolumeUpdate] AssetUpdateMessage usdVolumeUpdate
         */
        /**
         * Constructs a new AssetUpdateMessage.
         * @memberof ProtobufMarkets
         * @classdesc Represents an AssetUpdateMessage.
         * @implements IAssetUpdateMessage
         * @constructor
         * @param {ProtobufMarkets.IAssetUpdateMessage=} [properties] Properties to set
         */
        function AssetUpdateMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * AssetUpdateMessage asset.
         * @member {number} asset
         * @memberof ProtobufMarkets.AssetUpdateMessage
         * @instance
         */
        AssetUpdateMessage.prototype.asset = 0;
        /**
         * AssetUpdateMessage usdVolumeUpdate.
         * @member {ProtobufMarkets.IAssetUSDVolumeUpdate|null|undefined} usdVolumeUpdate
         * @memberof ProtobufMarkets.AssetUpdateMessage
         * @instance
         */
        AssetUpdateMessage.prototype.usdVolumeUpdate = null;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * AssetUpdateMessage Update.
         * @member {"usdVolumeUpdate"|undefined} Update
         * @memberof ProtobufMarkets.AssetUpdateMessage
         * @instance
         */
        Object.defineProperty(AssetUpdateMessage.prototype, "Update", {
            get: $util.oneOfGetter($oneOfFields = ["usdVolumeUpdate"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new AssetUpdateMessage instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.AssetUpdateMessage
         * @static
         * @param {ProtobufMarkets.IAssetUpdateMessage=} [properties] Properties to set
         * @returns {ProtobufMarkets.AssetUpdateMessage} AssetUpdateMessage instance
         */
        AssetUpdateMessage.create = function create(properties) {
            return new AssetUpdateMessage(properties);
        };
        /**
         * Encodes the specified AssetUpdateMessage message. Does not implicitly {@link ProtobufMarkets.AssetUpdateMessage.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.AssetUpdateMessage
         * @static
         * @param {ProtobufMarkets.IAssetUpdateMessage} message AssetUpdateMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AssetUpdateMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.asset != null && Object.hasOwnProperty.call(message, "asset"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.asset);
            if (message.usdVolumeUpdate != null && Object.hasOwnProperty.call(message, "usdVolumeUpdate"))
                $root.ProtobufMarkets.AssetUSDVolumeUpdate.encode(message.usdVolumeUpdate, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified AssetUpdateMessage message, length delimited. Does not implicitly {@link ProtobufMarkets.AssetUpdateMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.AssetUpdateMessage
         * @static
         * @param {ProtobufMarkets.IAssetUpdateMessage} message AssetUpdateMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AssetUpdateMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an AssetUpdateMessage message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.AssetUpdateMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.AssetUpdateMessage} AssetUpdateMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AssetUpdateMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.AssetUpdateMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.asset = reader.int32();
                        break;
                    case 2:
                        message.usdVolumeUpdate = $root.ProtobufMarkets.AssetUSDVolumeUpdate.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an AssetUpdateMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.AssetUpdateMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.AssetUpdateMessage} AssetUpdateMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AssetUpdateMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an AssetUpdateMessage message.
         * @function verify
         * @memberof ProtobufMarkets.AssetUpdateMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AssetUpdateMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.asset != null && message.hasOwnProperty("asset"))
                if (!$util.isInteger(message.asset))
                    return "asset: integer expected";
            if (message.usdVolumeUpdate != null && message.hasOwnProperty("usdVolumeUpdate")) {
                properties.Update = 1;
                {
                    var error = $root.ProtobufMarkets.AssetUSDVolumeUpdate.verify(message.usdVolumeUpdate);
                    if (error)
                        return "usdVolumeUpdate." + error;
                }
            }
            return null;
        };
        /**
         * Creates an AssetUpdateMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.AssetUpdateMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.AssetUpdateMessage} AssetUpdateMessage
         */
        AssetUpdateMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.AssetUpdateMessage)
                return object;
            var message = new $root.ProtobufMarkets.AssetUpdateMessage();
            if (object.asset != null)
                message.asset = object.asset | 0;
            if (object.usdVolumeUpdate != null) {
                if (typeof object.usdVolumeUpdate !== "object")
                    throw TypeError(".ProtobufMarkets.AssetUpdateMessage.usdVolumeUpdate: object expected");
                message.usdVolumeUpdate = $root.ProtobufMarkets.AssetUSDVolumeUpdate.fromObject(object.usdVolumeUpdate);
            }
            return message;
        };
        /**
         * Creates a plain object from an AssetUpdateMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.AssetUpdateMessage
         * @static
         * @param {ProtobufMarkets.AssetUpdateMessage} message AssetUpdateMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AssetUpdateMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.asset = 0;
            if (message.asset != null && message.hasOwnProperty("asset"))
                object.asset = message.asset;
            if (message.usdVolumeUpdate != null && message.hasOwnProperty("usdVolumeUpdate")) {
                object.usdVolumeUpdate = $root.ProtobufMarkets.AssetUSDVolumeUpdate.toObject(message.usdVolumeUpdate, options);
                if (options.oneofs)
                    object.Update = "usdVolumeUpdate";
            }
            return object;
        };
        /**
         * Converts this AssetUpdateMessage to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.AssetUpdateMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AssetUpdateMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return AssetUpdateMessage;
    })();
    ProtobufMarkets.AssetUSDVolumeUpdate = (function () {
        /**
         * Properties of an AssetUSDVolumeUpdate.
         * @memberof ProtobufMarkets
         * @interface IAssetUSDVolumeUpdate
         * @property {string|null} [volume] AssetUSDVolumeUpdate volume
         */
        /**
         * Constructs a new AssetUSDVolumeUpdate.
         * @memberof ProtobufMarkets
         * @classdesc Represents an AssetUSDVolumeUpdate.
         * @implements IAssetUSDVolumeUpdate
         * @constructor
         * @param {ProtobufMarkets.IAssetUSDVolumeUpdate=} [properties] Properties to set
         */
        function AssetUSDVolumeUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * AssetUSDVolumeUpdate volume.
         * @member {string} volume
         * @memberof ProtobufMarkets.AssetUSDVolumeUpdate
         * @instance
         */
        AssetUSDVolumeUpdate.prototype.volume = "";
        /**
         * Creates a new AssetUSDVolumeUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.AssetUSDVolumeUpdate
         * @static
         * @param {ProtobufMarkets.IAssetUSDVolumeUpdate=} [properties] Properties to set
         * @returns {ProtobufMarkets.AssetUSDVolumeUpdate} AssetUSDVolumeUpdate instance
         */
        AssetUSDVolumeUpdate.create = function create(properties) {
            return new AssetUSDVolumeUpdate(properties);
        };
        /**
         * Encodes the specified AssetUSDVolumeUpdate message. Does not implicitly {@link ProtobufMarkets.AssetUSDVolumeUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.AssetUSDVolumeUpdate
         * @static
         * @param {ProtobufMarkets.IAssetUSDVolumeUpdate} message AssetUSDVolumeUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AssetUSDVolumeUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.volume != null && Object.hasOwnProperty.call(message, "volume"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.volume);
            return writer;
        };
        /**
         * Encodes the specified AssetUSDVolumeUpdate message, length delimited. Does not implicitly {@link ProtobufMarkets.AssetUSDVolumeUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.AssetUSDVolumeUpdate
         * @static
         * @param {ProtobufMarkets.IAssetUSDVolumeUpdate} message AssetUSDVolumeUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AssetUSDVolumeUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an AssetUSDVolumeUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.AssetUSDVolumeUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.AssetUSDVolumeUpdate} AssetUSDVolumeUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AssetUSDVolumeUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.AssetUSDVolumeUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.volume = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an AssetUSDVolumeUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.AssetUSDVolumeUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.AssetUSDVolumeUpdate} AssetUSDVolumeUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AssetUSDVolumeUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an AssetUSDVolumeUpdate message.
         * @function verify
         * @memberof ProtobufMarkets.AssetUSDVolumeUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AssetUSDVolumeUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (!$util.isString(message.volume))
                    return "volume: string expected";
            return null;
        };
        /**
         * Creates an AssetUSDVolumeUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.AssetUSDVolumeUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.AssetUSDVolumeUpdate} AssetUSDVolumeUpdate
         */
        AssetUSDVolumeUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.AssetUSDVolumeUpdate)
                return object;
            var message = new $root.ProtobufMarkets.AssetUSDVolumeUpdate();
            if (object.volume != null)
                message.volume = String(object.volume);
            return message;
        };
        /**
         * Creates a plain object from an AssetUSDVolumeUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.AssetUSDVolumeUpdate
         * @static
         * @param {ProtobufMarkets.AssetUSDVolumeUpdate} message AssetUSDVolumeUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AssetUSDVolumeUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.volume = "";
            if (message.volume != null && message.hasOwnProperty("volume"))
                object.volume = message.volume;
            return object;
        };
        /**
         * Converts this AssetUSDVolumeUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.AssetUSDVolumeUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AssetUSDVolumeUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return AssetUSDVolumeUpdate;
    })();
    ProtobufMarkets.Index = (function () {
        /**
         * Properties of an Index.
         * @memberof ProtobufMarkets
         * @interface IIndex
         * @property {number|Long|null} [id] Index id
         * @property {string|null} [symbol] Index symbol
         * @property {string|null} [indexType] Index indexType
         * @property {boolean|null} [cwIndex] Index cwIndex
         * @property {number|Long|null} [exchangeId] Index exchangeId
         * @property {number|Long|null} [instrumentId] Index instrumentId
         */
        /**
         * Constructs a new Index.
         * @memberof ProtobufMarkets
         * @classdesc Represents an Index.
         * @implements IIndex
         * @constructor
         * @param {ProtobufMarkets.IIndex=} [properties] Properties to set
         */
        function Index(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Index id.
         * @member {number|Long} id
         * @memberof ProtobufMarkets.Index
         * @instance
         */
        Index.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * Index symbol.
         * @member {string} symbol
         * @memberof ProtobufMarkets.Index
         * @instance
         */
        Index.prototype.symbol = "";
        /**
         * Index indexType.
         * @member {string} indexType
         * @memberof ProtobufMarkets.Index
         * @instance
         */
        Index.prototype.indexType = "";
        /**
         * Index cwIndex.
         * @member {boolean} cwIndex
         * @memberof ProtobufMarkets.Index
         * @instance
         */
        Index.prototype.cwIndex = false;
        /**
         * Index exchangeId.
         * @member {number|Long} exchangeId
         * @memberof ProtobufMarkets.Index
         * @instance
         */
        Index.prototype.exchangeId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * Index instrumentId.
         * @member {number|Long} instrumentId
         * @memberof ProtobufMarkets.Index
         * @instance
         */
        Index.prototype.instrumentId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * Creates a new Index instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.Index
         * @static
         * @param {ProtobufMarkets.IIndex=} [properties] Properties to set
         * @returns {ProtobufMarkets.Index} Index instance
         */
        Index.create = function create(properties) {
            return new Index(properties);
        };
        /**
         * Encodes the specified Index message. Does not implicitly {@link ProtobufMarkets.Index.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.Index
         * @static
         * @param {ProtobufMarkets.IIndex} message Index message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Index.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.id);
            if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.symbol);
            if (message.indexType != null && Object.hasOwnProperty.call(message, "indexType"))
                writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.indexType);
            if (message.cwIndex != null && Object.hasOwnProperty.call(message, "cwIndex"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.cwIndex);
            if (message.exchangeId != null && Object.hasOwnProperty.call(message, "exchangeId"))
                writer.uint32(/* id 5, wireType 0 =*/ 40).uint64(message.exchangeId);
            if (message.instrumentId != null && Object.hasOwnProperty.call(message, "instrumentId"))
                writer.uint32(/* id 6, wireType 0 =*/ 48).uint64(message.instrumentId);
            return writer;
        };
        /**
         * Encodes the specified Index message, length delimited. Does not implicitly {@link ProtobufMarkets.Index.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.Index
         * @static
         * @param {ProtobufMarkets.IIndex} message Index message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Index.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an Index message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.Index
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.Index} Index
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Index.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.Index();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.id = reader.uint64();
                        break;
                    case 2:
                        message.symbol = reader.string();
                        break;
                    case 3:
                        message.indexType = reader.string();
                        break;
                    case 4:
                        message.cwIndex = reader.bool();
                        break;
                    case 5:
                        message.exchangeId = reader.uint64();
                        break;
                    case 6:
                        message.instrumentId = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an Index message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.Index
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.Index} Index
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Index.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an Index message.
         * @function verify
         * @memberof ProtobufMarkets.Index
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Index.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.symbol != null && message.hasOwnProperty("symbol"))
                if (!$util.isString(message.symbol))
                    return "symbol: string expected";
            if (message.indexType != null && message.hasOwnProperty("indexType"))
                if (!$util.isString(message.indexType))
                    return "indexType: string expected";
            if (message.cwIndex != null && message.hasOwnProperty("cwIndex"))
                if (typeof message.cwIndex !== "boolean")
                    return "cwIndex: boolean expected";
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (!$util.isInteger(message.exchangeId) && !(message.exchangeId && $util.isInteger(message.exchangeId.low) && $util.isInteger(message.exchangeId.high)))
                    return "exchangeId: integer|Long expected";
            if (message.instrumentId != null && message.hasOwnProperty("instrumentId"))
                if (!$util.isInteger(message.instrumentId) && !(message.instrumentId && $util.isInteger(message.instrumentId.low) && $util.isInteger(message.instrumentId.high)))
                    return "instrumentId: integer|Long expected";
            return null;
        };
        /**
         * Creates an Index message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.Index
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.Index} Index
         */
        Index.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.Index)
                return object;
            var message = new $root.ProtobufMarkets.Index();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            if (object.symbol != null)
                message.symbol = String(object.symbol);
            if (object.indexType != null)
                message.indexType = String(object.indexType);
            if (object.cwIndex != null)
                message.cwIndex = Boolean(object.cwIndex);
            if (object.exchangeId != null)
                if ($util.Long)
                    (message.exchangeId = $util.Long.fromValue(object.exchangeId)).unsigned = true;
                else if (typeof object.exchangeId === "string")
                    message.exchangeId = parseInt(object.exchangeId, 10);
                else if (typeof object.exchangeId === "number")
                    message.exchangeId = object.exchangeId;
                else if (typeof object.exchangeId === "object")
                    message.exchangeId = new $util.LongBits(object.exchangeId.low >>> 0, object.exchangeId.high >>> 0).toNumber(true);
            if (object.instrumentId != null)
                if ($util.Long)
                    (message.instrumentId = $util.Long.fromValue(object.instrumentId)).unsigned = true;
                else if (typeof object.instrumentId === "string")
                    message.instrumentId = parseInt(object.instrumentId, 10);
                else if (typeof object.instrumentId === "number")
                    message.instrumentId = object.instrumentId;
                else if (typeof object.instrumentId === "object")
                    message.instrumentId = new $util.LongBits(object.instrumentId.low >>> 0, object.instrumentId.high >>> 0).toNumber(true);
            return message;
        };
        /**
         * Creates a plain object from an Index message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.Index
         * @static
         * @param {ProtobufMarkets.Index} message Index
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Index.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.id = options.longs === String ? "0" : 0;
                object.symbol = "";
                object.indexType = "";
                object.cwIndex = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.exchangeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.exchangeId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.instrumentId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.instrumentId = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            if (message.symbol != null && message.hasOwnProperty("symbol"))
                object.symbol = message.symbol;
            if (message.indexType != null && message.hasOwnProperty("indexType"))
                object.indexType = message.indexType;
            if (message.cwIndex != null && message.hasOwnProperty("cwIndex"))
                object.cwIndex = message.cwIndex;
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (typeof message.exchangeId === "number")
                    object.exchangeId = options.longs === String ? String(message.exchangeId) : message.exchangeId;
                else
                    object.exchangeId = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeId) : options.longs === Number ? new $util.LongBits(message.exchangeId.low >>> 0, message.exchangeId.high >>> 0).toNumber(true) : message.exchangeId;
            if (message.instrumentId != null && message.hasOwnProperty("instrumentId"))
                if (typeof message.instrumentId === "number")
                    object.instrumentId = options.longs === String ? String(message.instrumentId) : message.instrumentId;
                else
                    object.instrumentId = options.longs === String ? $util.Long.prototype.toString.call(message.instrumentId) : options.longs === Number ? new $util.LongBits(message.instrumentId.low >>> 0, message.instrumentId.high >>> 0).toNumber(true) : message.instrumentId;
            return object;
        };
        /**
         * Converts this Index to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.Index
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Index.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Index;
    })();
    ProtobufMarkets.IndexUpdateMessage = (function () {
        /**
         * Properties of an IndexUpdateMessage.
         * @memberof ProtobufMarkets
         * @interface IIndexUpdateMessage
         * @property {ProtobufMarkets.IIndex|null} [index] IndexUpdateMessage index
         * @property {ProtobufMarkets.ITickerUpdate|null} [tickerUpdate] IndexUpdateMessage tickerUpdate
         * @property {ProtobufMarkets.IIntervalsUpdate|null} [intervalsUpdate] IndexUpdateMessage intervalsUpdate
         * @property {ProtobufMarkets.ISummaryUpdate|null} [summaryUpdate] IndexUpdateMessage summaryUpdate
         * @property {ProtobufMarkets.ISparklineUpdate|null} [sparklineUpdate] IndexUpdateMessage sparklineUpdate
         */
        /**
         * Constructs a new IndexUpdateMessage.
         * @memberof ProtobufMarkets
         * @classdesc Represents an IndexUpdateMessage.
         * @implements IIndexUpdateMessage
         * @constructor
         * @param {ProtobufMarkets.IIndexUpdateMessage=} [properties] Properties to set
         */
        function IndexUpdateMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * IndexUpdateMessage index.
         * @member {ProtobufMarkets.IIndex|null|undefined} index
         * @memberof ProtobufMarkets.IndexUpdateMessage
         * @instance
         */
        IndexUpdateMessage.prototype.index = null;
        /**
         * IndexUpdateMessage tickerUpdate.
         * @member {ProtobufMarkets.ITickerUpdate|null|undefined} tickerUpdate
         * @memberof ProtobufMarkets.IndexUpdateMessage
         * @instance
         */
        IndexUpdateMessage.prototype.tickerUpdate = null;
        /**
         * IndexUpdateMessage intervalsUpdate.
         * @member {ProtobufMarkets.IIntervalsUpdate|null|undefined} intervalsUpdate
         * @memberof ProtobufMarkets.IndexUpdateMessage
         * @instance
         */
        IndexUpdateMessage.prototype.intervalsUpdate = null;
        /**
         * IndexUpdateMessage summaryUpdate.
         * @member {ProtobufMarkets.ISummaryUpdate|null|undefined} summaryUpdate
         * @memberof ProtobufMarkets.IndexUpdateMessage
         * @instance
         */
        IndexUpdateMessage.prototype.summaryUpdate = null;
        /**
         * IndexUpdateMessage sparklineUpdate.
         * @member {ProtobufMarkets.ISparklineUpdate|null|undefined} sparklineUpdate
         * @memberof ProtobufMarkets.IndexUpdateMessage
         * @instance
         */
        IndexUpdateMessage.prototype.sparklineUpdate = null;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * IndexUpdateMessage Update.
         * @member {"tickerUpdate"|"intervalsUpdate"|"summaryUpdate"|"sparklineUpdate"|undefined} Update
         * @memberof ProtobufMarkets.IndexUpdateMessage
         * @instance
         */
        Object.defineProperty(IndexUpdateMessage.prototype, "Update", {
            get: $util.oneOfGetter($oneOfFields = ["tickerUpdate", "intervalsUpdate", "summaryUpdate", "sparklineUpdate"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new IndexUpdateMessage instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.IndexUpdateMessage
         * @static
         * @param {ProtobufMarkets.IIndexUpdateMessage=} [properties] Properties to set
         * @returns {ProtobufMarkets.IndexUpdateMessage} IndexUpdateMessage instance
         */
        IndexUpdateMessage.create = function create(properties) {
            return new IndexUpdateMessage(properties);
        };
        /**
         * Encodes the specified IndexUpdateMessage message. Does not implicitly {@link ProtobufMarkets.IndexUpdateMessage.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.IndexUpdateMessage
         * @static
         * @param {ProtobufMarkets.IIndexUpdateMessage} message IndexUpdateMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IndexUpdateMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                $root.ProtobufMarkets.Index.encode(message.index, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.tickerUpdate != null && Object.hasOwnProperty.call(message, "tickerUpdate"))
                $root.ProtobufMarkets.TickerUpdate.encode(message.tickerUpdate, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.intervalsUpdate != null && Object.hasOwnProperty.call(message, "intervalsUpdate"))
                $root.ProtobufMarkets.IntervalsUpdate.encode(message.intervalsUpdate, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.summaryUpdate != null && Object.hasOwnProperty.call(message, "summaryUpdate"))
                $root.ProtobufMarkets.SummaryUpdate.encode(message.summaryUpdate, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            if (message.sparklineUpdate != null && Object.hasOwnProperty.call(message, "sparklineUpdate"))
                $root.ProtobufMarkets.SparklineUpdate.encode(message.sparklineUpdate, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified IndexUpdateMessage message, length delimited. Does not implicitly {@link ProtobufMarkets.IndexUpdateMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.IndexUpdateMessage
         * @static
         * @param {ProtobufMarkets.IIndexUpdateMessage} message IndexUpdateMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IndexUpdateMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an IndexUpdateMessage message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.IndexUpdateMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.IndexUpdateMessage} IndexUpdateMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IndexUpdateMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.IndexUpdateMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.index = $root.ProtobufMarkets.Index.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.tickerUpdate = $root.ProtobufMarkets.TickerUpdate.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.intervalsUpdate = $root.ProtobufMarkets.IntervalsUpdate.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.summaryUpdate = $root.ProtobufMarkets.SummaryUpdate.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.sparklineUpdate = $root.ProtobufMarkets.SparklineUpdate.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an IndexUpdateMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.IndexUpdateMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.IndexUpdateMessage} IndexUpdateMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IndexUpdateMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an IndexUpdateMessage message.
         * @function verify
         * @memberof ProtobufMarkets.IndexUpdateMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IndexUpdateMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.index != null && message.hasOwnProperty("index")) {
                var error = $root.ProtobufMarkets.Index.verify(message.index);
                if (error)
                    return "index." + error;
            }
            if (message.tickerUpdate != null && message.hasOwnProperty("tickerUpdate")) {
                properties.Update = 1;
                {
                    var error = $root.ProtobufMarkets.TickerUpdate.verify(message.tickerUpdate);
                    if (error)
                        return "tickerUpdate." + error;
                }
            }
            if (message.intervalsUpdate != null && message.hasOwnProperty("intervalsUpdate")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufMarkets.IntervalsUpdate.verify(message.intervalsUpdate);
                    if (error)
                        return "intervalsUpdate." + error;
                }
            }
            if (message.summaryUpdate != null && message.hasOwnProperty("summaryUpdate")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufMarkets.SummaryUpdate.verify(message.summaryUpdate);
                    if (error)
                        return "summaryUpdate." + error;
                }
            }
            if (message.sparklineUpdate != null && message.hasOwnProperty("sparklineUpdate")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufMarkets.SparklineUpdate.verify(message.sparklineUpdate);
                    if (error)
                        return "sparklineUpdate." + error;
                }
            }
            return null;
        };
        /**
         * Creates an IndexUpdateMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.IndexUpdateMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.IndexUpdateMessage} IndexUpdateMessage
         */
        IndexUpdateMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.IndexUpdateMessage)
                return object;
            var message = new $root.ProtobufMarkets.IndexUpdateMessage();
            if (object.index != null) {
                if (typeof object.index !== "object")
                    throw TypeError(".ProtobufMarkets.IndexUpdateMessage.index: object expected");
                message.index = $root.ProtobufMarkets.Index.fromObject(object.index);
            }
            if (object.tickerUpdate != null) {
                if (typeof object.tickerUpdate !== "object")
                    throw TypeError(".ProtobufMarkets.IndexUpdateMessage.tickerUpdate: object expected");
                message.tickerUpdate = $root.ProtobufMarkets.TickerUpdate.fromObject(object.tickerUpdate);
            }
            if (object.intervalsUpdate != null) {
                if (typeof object.intervalsUpdate !== "object")
                    throw TypeError(".ProtobufMarkets.IndexUpdateMessage.intervalsUpdate: object expected");
                message.intervalsUpdate = $root.ProtobufMarkets.IntervalsUpdate.fromObject(object.intervalsUpdate);
            }
            if (object.summaryUpdate != null) {
                if (typeof object.summaryUpdate !== "object")
                    throw TypeError(".ProtobufMarkets.IndexUpdateMessage.summaryUpdate: object expected");
                message.summaryUpdate = $root.ProtobufMarkets.SummaryUpdate.fromObject(object.summaryUpdate);
            }
            if (object.sparklineUpdate != null) {
                if (typeof object.sparklineUpdate !== "object")
                    throw TypeError(".ProtobufMarkets.IndexUpdateMessage.sparklineUpdate: object expected");
                message.sparklineUpdate = $root.ProtobufMarkets.SparklineUpdate.fromObject(object.sparklineUpdate);
            }
            return message;
        };
        /**
         * Creates a plain object from an IndexUpdateMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.IndexUpdateMessage
         * @static
         * @param {ProtobufMarkets.IndexUpdateMessage} message IndexUpdateMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IndexUpdateMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.index = null;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = $root.ProtobufMarkets.Index.toObject(message.index, options);
            if (message.tickerUpdate != null && message.hasOwnProperty("tickerUpdate")) {
                object.tickerUpdate = $root.ProtobufMarkets.TickerUpdate.toObject(message.tickerUpdate, options);
                if (options.oneofs)
                    object.Update = "tickerUpdate";
            }
            if (message.intervalsUpdate != null && message.hasOwnProperty("intervalsUpdate")) {
                object.intervalsUpdate = $root.ProtobufMarkets.IntervalsUpdate.toObject(message.intervalsUpdate, options);
                if (options.oneofs)
                    object.Update = "intervalsUpdate";
            }
            if (message.summaryUpdate != null && message.hasOwnProperty("summaryUpdate")) {
                object.summaryUpdate = $root.ProtobufMarkets.SummaryUpdate.toObject(message.summaryUpdate, options);
                if (options.oneofs)
                    object.Update = "summaryUpdate";
            }
            if (message.sparklineUpdate != null && message.hasOwnProperty("sparklineUpdate")) {
                object.sparklineUpdate = $root.ProtobufMarkets.SparklineUpdate.toObject(message.sparklineUpdate, options);
                if (options.oneofs)
                    object.Update = "sparklineUpdate";
            }
            return object;
        };
        /**
         * Converts this IndexUpdateMessage to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.IndexUpdateMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IndexUpdateMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return IndexUpdateMessage;
    })();
    ProtobufMarkets.TickerUpdate = (function () {
        /**
         * Properties of a TickerUpdate.
         * @memberof ProtobufMarkets
         * @interface ITickerUpdate
         * @property {Array.<ProtobufMarkets.ITicker>|null} [tickers] TickerUpdate tickers
         */
        /**
         * Constructs a new TickerUpdate.
         * @memberof ProtobufMarkets
         * @classdesc Represents a TickerUpdate.
         * @implements ITickerUpdate
         * @constructor
         * @param {ProtobufMarkets.ITickerUpdate=} [properties] Properties to set
         */
        function TickerUpdate(properties) {
            this.tickers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * TickerUpdate tickers.
         * @member {Array.<ProtobufMarkets.ITicker>} tickers
         * @memberof ProtobufMarkets.TickerUpdate
         * @instance
         */
        TickerUpdate.prototype.tickers = $util.emptyArray;
        /**
         * Creates a new TickerUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.TickerUpdate
         * @static
         * @param {ProtobufMarkets.ITickerUpdate=} [properties] Properties to set
         * @returns {ProtobufMarkets.TickerUpdate} TickerUpdate instance
         */
        TickerUpdate.create = function create(properties) {
            return new TickerUpdate(properties);
        };
        /**
         * Encodes the specified TickerUpdate message. Does not implicitly {@link ProtobufMarkets.TickerUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.TickerUpdate
         * @static
         * @param {ProtobufMarkets.ITickerUpdate} message TickerUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TickerUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tickers != null && message.tickers.length)
                for (var i = 0; i < message.tickers.length; ++i)
                    $root.ProtobufMarkets.Ticker.encode(message.tickers[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified TickerUpdate message, length delimited. Does not implicitly {@link ProtobufMarkets.TickerUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.TickerUpdate
         * @static
         * @param {ProtobufMarkets.ITickerUpdate} message TickerUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TickerUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a TickerUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.TickerUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.TickerUpdate} TickerUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TickerUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.TickerUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.tickers && message.tickers.length))
                            message.tickers = [];
                        message.tickers.push($root.ProtobufMarkets.Ticker.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a TickerUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.TickerUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.TickerUpdate} TickerUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TickerUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a TickerUpdate message.
         * @function verify
         * @memberof ProtobufMarkets.TickerUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TickerUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tickers != null && message.hasOwnProperty("tickers")) {
                if (!Array.isArray(message.tickers))
                    return "tickers: array expected";
                for (var i = 0; i < message.tickers.length; ++i) {
                    var error = $root.ProtobufMarkets.Ticker.verify(message.tickers[i]);
                    if (error)
                        return "tickers." + error;
                }
            }
            return null;
        };
        /**
         * Creates a TickerUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.TickerUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.TickerUpdate} TickerUpdate
         */
        TickerUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.TickerUpdate)
                return object;
            var message = new $root.ProtobufMarkets.TickerUpdate();
            if (object.tickers) {
                if (!Array.isArray(object.tickers))
                    throw TypeError(".ProtobufMarkets.TickerUpdate.tickers: array expected");
                message.tickers = [];
                for (var i = 0; i < object.tickers.length; ++i) {
                    if (typeof object.tickers[i] !== "object")
                        throw TypeError(".ProtobufMarkets.TickerUpdate.tickers: object expected");
                    message.tickers[i] = $root.ProtobufMarkets.Ticker.fromObject(object.tickers[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a TickerUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.TickerUpdate
         * @static
         * @param {ProtobufMarkets.TickerUpdate} message TickerUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TickerUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tickers = [];
            if (message.tickers && message.tickers.length) {
                object.tickers = [];
                for (var j = 0; j < message.tickers.length; ++j)
                    object.tickers[j] = $root.ProtobufMarkets.Ticker.toObject(message.tickers[j], options);
            }
            return object;
        };
        /**
         * Converts this TickerUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.TickerUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TickerUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return TickerUpdate;
    })();
    ProtobufMarkets.Ticker = (function () {
        /**
         * Properties of a Ticker.
         * @memberof ProtobufMarkets
         * @interface ITicker
         * @property {string|null} [value] Ticker value
         * @property {number|Long|null} [timestamp] Ticker timestamp
         * @property {number|Long|null} [timestampNano] Ticker timestampNano
         */
        /**
         * Constructs a new Ticker.
         * @memberof ProtobufMarkets
         * @classdesc Represents a Ticker.
         * @implements ITicker
         * @constructor
         * @param {ProtobufMarkets.ITicker=} [properties] Properties to set
         */
        function Ticker(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Ticker value.
         * @member {string} value
         * @memberof ProtobufMarkets.Ticker
         * @instance
         */
        Ticker.prototype.value = "";
        /**
         * Ticker timestamp.
         * @member {number|Long} timestamp
         * @memberof ProtobufMarkets.Ticker
         * @instance
         */
        Ticker.prototype.timestamp = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * Ticker timestampNano.
         * @member {number|Long} timestampNano
         * @memberof ProtobufMarkets.Ticker
         * @instance
         */
        Ticker.prototype.timestampNano = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * Creates a new Ticker instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.Ticker
         * @static
         * @param {ProtobufMarkets.ITicker=} [properties] Properties to set
         * @returns {ProtobufMarkets.Ticker} Ticker instance
         */
        Ticker.create = function create(properties) {
            return new Ticker(properties);
        };
        /**
         * Encodes the specified Ticker message. Does not implicitly {@link ProtobufMarkets.Ticker.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.Ticker
         * @static
         * @param {ProtobufMarkets.ITicker} message Ticker message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ticker.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.value);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.timestamp);
            if (message.timestampNano != null && Object.hasOwnProperty.call(message, "timestampNano"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.timestampNano);
            return writer;
        };
        /**
         * Encodes the specified Ticker message, length delimited. Does not implicitly {@link ProtobufMarkets.Ticker.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.Ticker
         * @static
         * @param {ProtobufMarkets.ITicker} message Ticker message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ticker.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a Ticker message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.Ticker
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.Ticker} Ticker
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ticker.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.Ticker();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.value = reader.string();
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    case 3:
                        message.timestampNano = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a Ticker message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.Ticker
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.Ticker} Ticker
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ticker.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a Ticker message.
         * @function verify
         * @memberof ProtobufMarkets.Ticker
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Ticker.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.timestampNano != null && message.hasOwnProperty("timestampNano"))
                if (!$util.isInteger(message.timestampNano) && !(message.timestampNano && $util.isInteger(message.timestampNano.low) && $util.isInteger(message.timestampNano.high)))
                    return "timestampNano: integer|Long expected";
            return null;
        };
        /**
         * Creates a Ticker message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.Ticker
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.Ticker} Ticker
         */
        Ticker.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.Ticker)
                return object;
            var message = new $root.ProtobufMarkets.Ticker();
            if (object.value != null)
                message.value = String(object.value);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.timestampNano != null)
                if ($util.Long)
                    (message.timestampNano = $util.Long.fromValue(object.timestampNano)).unsigned = false;
                else if (typeof object.timestampNano === "string")
                    message.timestampNano = parseInt(object.timestampNano, 10);
                else if (typeof object.timestampNano === "number")
                    message.timestampNano = object.timestampNano;
                else if (typeof object.timestampNano === "object")
                    message.timestampNano = new $util.LongBits(object.timestampNano.low >>> 0, object.timestampNano.high >>> 0).toNumber();
            return message;
        };
        /**
         * Creates a plain object from a Ticker message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.Ticker
         * @static
         * @param {ProtobufMarkets.Ticker} message Ticker
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Ticker.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.value = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.timestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestampNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.timestampNano = options.longs === String ? "0" : 0;
            }
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.timestampNano != null && message.hasOwnProperty("timestampNano"))
                if (typeof message.timestampNano === "number")
                    object.timestampNano = options.longs === String ? String(message.timestampNano) : message.timestampNano;
                else
                    object.timestampNano = options.longs === String ? $util.Long.prototype.toString.call(message.timestampNano) : options.longs === Number ? new $util.LongBits(message.timestampNano.low >>> 0, message.timestampNano.high >>> 0).toNumber() : message.timestampNano;
            return object;
        };
        /**
         * Converts this Ticker to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.Ticker
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Ticker.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Ticker;
    })();
    ProtobufMarkets.Market = (function () {
        /**
         * Properties of a Market.
         * @memberof ProtobufMarkets
         * @interface IMarket
         * @property {number|Long|null} [exchangeId] Market exchangeId
         * @property {number|Long|null} [currencyPairId] Market currencyPairId
         * @property {number|Long|null} [marketId] Market marketId
         * @property {string|null} [exchange] Market exchange
         * @property {string|null} [currencyPair] Market currencyPair
         */
        /**
         * Constructs a new Market.
         * @memberof ProtobufMarkets
         * @classdesc Represents a Market.
         * @implements IMarket
         * @constructor
         * @param {ProtobufMarkets.IMarket=} [properties] Properties to set
         */
        function Market(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Market exchangeId.
         * @member {number|Long} exchangeId
         * @memberof ProtobufMarkets.Market
         * @instance
         */
        Market.prototype.exchangeId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * Market currencyPairId.
         * @member {number|Long} currencyPairId
         * @memberof ProtobufMarkets.Market
         * @instance
         */
        Market.prototype.currencyPairId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * Market marketId.
         * @member {number|Long} marketId
         * @memberof ProtobufMarkets.Market
         * @instance
         */
        Market.prototype.marketId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * Market exchange.
         * @member {string} exchange
         * @memberof ProtobufMarkets.Market
         * @instance
         */
        Market.prototype.exchange = "";
        /**
         * Market currencyPair.
         * @member {string} currencyPair
         * @memberof ProtobufMarkets.Market
         * @instance
         */
        Market.prototype.currencyPair = "";
        /**
         * Creates a new Market instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.Market
         * @static
         * @param {ProtobufMarkets.IMarket=} [properties] Properties to set
         * @returns {ProtobufMarkets.Market} Market instance
         */
        Market.create = function create(properties) {
            return new Market(properties);
        };
        /**
         * Encodes the specified Market message. Does not implicitly {@link ProtobufMarkets.Market.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.Market
         * @static
         * @param {ProtobufMarkets.IMarket} message Market message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Market.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.exchange != null && Object.hasOwnProperty.call(message, "exchange"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.exchange);
            if (message.currencyPair != null && Object.hasOwnProperty.call(message, "currencyPair"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.currencyPair);
            if (message.exchangeId != null && Object.hasOwnProperty.call(message, "exchangeId"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.exchangeId);
            if (message.currencyPairId != null && Object.hasOwnProperty.call(message, "currencyPairId"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.currencyPairId);
            if (message.marketId != null && Object.hasOwnProperty.call(message, "marketId"))
                writer.uint32(/* id 5, wireType 0 =*/ 40).uint64(message.marketId);
            return writer;
        };
        /**
         * Encodes the specified Market message, length delimited. Does not implicitly {@link ProtobufMarkets.Market.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.Market
         * @static
         * @param {ProtobufMarkets.IMarket} message Market message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Market.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a Market message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.Market
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.Market} Market
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Market.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.Market();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 3:
                        message.exchangeId = reader.uint64();
                        break;
                    case 4:
                        message.currencyPairId = reader.uint64();
                        break;
                    case 5:
                        message.marketId = reader.uint64();
                        break;
                    case 1:
                        message.exchange = reader.string();
                        break;
                    case 2:
                        message.currencyPair = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a Market message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.Market
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.Market} Market
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Market.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a Market message.
         * @function verify
         * @memberof ProtobufMarkets.Market
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Market.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (!$util.isInteger(message.exchangeId) && !(message.exchangeId && $util.isInteger(message.exchangeId.low) && $util.isInteger(message.exchangeId.high)))
                    return "exchangeId: integer|Long expected";
            if (message.currencyPairId != null && message.hasOwnProperty("currencyPairId"))
                if (!$util.isInteger(message.currencyPairId) && !(message.currencyPairId && $util.isInteger(message.currencyPairId.low) && $util.isInteger(message.currencyPairId.high)))
                    return "currencyPairId: integer|Long expected";
            if (message.marketId != null && message.hasOwnProperty("marketId"))
                if (!$util.isInteger(message.marketId) && !(message.marketId && $util.isInteger(message.marketId.low) && $util.isInteger(message.marketId.high)))
                    return "marketId: integer|Long expected";
            if (message.exchange != null && message.hasOwnProperty("exchange"))
                if (!$util.isString(message.exchange))
                    return "exchange: string expected";
            if (message.currencyPair != null && message.hasOwnProperty("currencyPair"))
                if (!$util.isString(message.currencyPair))
                    return "currencyPair: string expected";
            return null;
        };
        /**
         * Creates a Market message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.Market
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.Market} Market
         */
        Market.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.Market)
                return object;
            var message = new $root.ProtobufMarkets.Market();
            if (object.exchangeId != null)
                if ($util.Long)
                    (message.exchangeId = $util.Long.fromValue(object.exchangeId)).unsigned = true;
                else if (typeof object.exchangeId === "string")
                    message.exchangeId = parseInt(object.exchangeId, 10);
                else if (typeof object.exchangeId === "number")
                    message.exchangeId = object.exchangeId;
                else if (typeof object.exchangeId === "object")
                    message.exchangeId = new $util.LongBits(object.exchangeId.low >>> 0, object.exchangeId.high >>> 0).toNumber(true);
            if (object.currencyPairId != null)
                if ($util.Long)
                    (message.currencyPairId = $util.Long.fromValue(object.currencyPairId)).unsigned = true;
                else if (typeof object.currencyPairId === "string")
                    message.currencyPairId = parseInt(object.currencyPairId, 10);
                else if (typeof object.currencyPairId === "number")
                    message.currencyPairId = object.currencyPairId;
                else if (typeof object.currencyPairId === "object")
                    message.currencyPairId = new $util.LongBits(object.currencyPairId.low >>> 0, object.currencyPairId.high >>> 0).toNumber(true);
            if (object.marketId != null)
                if ($util.Long)
                    (message.marketId = $util.Long.fromValue(object.marketId)).unsigned = true;
                else if (typeof object.marketId === "string")
                    message.marketId = parseInt(object.marketId, 10);
                else if (typeof object.marketId === "number")
                    message.marketId = object.marketId;
                else if (typeof object.marketId === "object")
                    message.marketId = new $util.LongBits(object.marketId.low >>> 0, object.marketId.high >>> 0).toNumber(true);
            if (object.exchange != null)
                message.exchange = String(object.exchange);
            if (object.currencyPair != null)
                message.currencyPair = String(object.currencyPair);
            return message;
        };
        /**
         * Creates a plain object from a Market message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.Market
         * @static
         * @param {ProtobufMarkets.Market} message Market
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Market.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.exchange = "";
                object.currencyPair = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.exchangeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.exchangeId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.currencyPairId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.currencyPairId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.marketId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.marketId = options.longs === String ? "0" : 0;
            }
            if (message.exchange != null && message.hasOwnProperty("exchange"))
                object.exchange = message.exchange;
            if (message.currencyPair != null && message.hasOwnProperty("currencyPair"))
                object.currencyPair = message.currencyPair;
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (typeof message.exchangeId === "number")
                    object.exchangeId = options.longs === String ? String(message.exchangeId) : message.exchangeId;
                else
                    object.exchangeId = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeId) : options.longs === Number ? new $util.LongBits(message.exchangeId.low >>> 0, message.exchangeId.high >>> 0).toNumber(true) : message.exchangeId;
            if (message.currencyPairId != null && message.hasOwnProperty("currencyPairId"))
                if (typeof message.currencyPairId === "number")
                    object.currencyPairId = options.longs === String ? String(message.currencyPairId) : message.currencyPairId;
                else
                    object.currencyPairId = options.longs === String ? $util.Long.prototype.toString.call(message.currencyPairId) : options.longs === Number ? new $util.LongBits(message.currencyPairId.low >>> 0, message.currencyPairId.high >>> 0).toNumber(true) : message.currencyPairId;
            if (message.marketId != null && message.hasOwnProperty("marketId"))
                if (typeof message.marketId === "number")
                    object.marketId = options.longs === String ? String(message.marketId) : message.marketId;
                else
                    object.marketId = options.longs === String ? $util.Long.prototype.toString.call(message.marketId) : options.longs === Number ? new $util.LongBits(message.marketId.low >>> 0, message.marketId.high >>> 0).toNumber(true) : message.marketId;
            return object;
        };
        /**
         * Converts this Market to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.Market
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Market.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Market;
    })();
    ProtobufMarkets.Order = (function () {
        /**
         * Properties of an Order.
         * @memberof ProtobufMarkets
         * @interface IOrder
         * @property {string|null} [priceStr] Order priceStr
         * @property {string|null} [amountStr] Order amountStr
         */
        /**
         * Constructs a new Order.
         * @memberof ProtobufMarkets
         * @classdesc Represents an Order.
         * @implements IOrder
         * @constructor
         * @param {ProtobufMarkets.IOrder=} [properties] Properties to set
         */
        function Order(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Order priceStr.
         * @member {string} priceStr
         * @memberof ProtobufMarkets.Order
         * @instance
         */
        Order.prototype.priceStr = "";
        /**
         * Order amountStr.
         * @member {string} amountStr
         * @memberof ProtobufMarkets.Order
         * @instance
         */
        Order.prototype.amountStr = "";
        /**
         * Creates a new Order instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.Order
         * @static
         * @param {ProtobufMarkets.IOrder=} [properties] Properties to set
         * @returns {ProtobufMarkets.Order} Order instance
         */
        Order.create = function create(properties) {
            return new Order(properties);
        };
        /**
         * Encodes the specified Order message. Does not implicitly {@link ProtobufMarkets.Order.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.Order
         * @static
         * @param {ProtobufMarkets.IOrder} message Order message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Order.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.priceStr != null && Object.hasOwnProperty.call(message, "priceStr"))
                writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.priceStr);
            if (message.amountStr != null && Object.hasOwnProperty.call(message, "amountStr"))
                writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.amountStr);
            return writer;
        };
        /**
         * Encodes the specified Order message, length delimited. Does not implicitly {@link ProtobufMarkets.Order.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.Order
         * @static
         * @param {ProtobufMarkets.IOrder} message Order message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Order.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an Order message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.Order
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.Order} Order
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Order.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.Order();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 3:
                        message.priceStr = reader.string();
                        break;
                    case 4:
                        message.amountStr = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an Order message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.Order
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.Order} Order
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Order.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an Order message.
         * @function verify
         * @memberof ProtobufMarkets.Order
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Order.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.priceStr != null && message.hasOwnProperty("priceStr"))
                if (!$util.isString(message.priceStr))
                    return "priceStr: string expected";
            if (message.amountStr != null && message.hasOwnProperty("amountStr"))
                if (!$util.isString(message.amountStr))
                    return "amountStr: string expected";
            return null;
        };
        /**
         * Creates an Order message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.Order
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.Order} Order
         */
        Order.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.Order)
                return object;
            var message = new $root.ProtobufMarkets.Order();
            if (object.priceStr != null)
                message.priceStr = String(object.priceStr);
            if (object.amountStr != null)
                message.amountStr = String(object.amountStr);
            return message;
        };
        /**
         * Creates a plain object from an Order message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.Order
         * @static
         * @param {ProtobufMarkets.Order} message Order
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Order.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.priceStr = "";
                object.amountStr = "";
            }
            if (message.priceStr != null && message.hasOwnProperty("priceStr"))
                object.priceStr = message.priceStr;
            if (message.amountStr != null && message.hasOwnProperty("amountStr"))
                object.amountStr = message.amountStr;
            return object;
        };
        /**
         * Converts this Order to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.Order
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Order.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Order;
    })();
    ProtobufMarkets.Trade = (function () {
        /**
         * Properties of a Trade.
         * @memberof ProtobufMarkets
         * @interface ITrade
         * @property {string|null} [externalId] Trade externalId
         * @property {number|Long|null} [timestamp] Trade timestamp
         * @property {number|Long|null} [timestampNano] Trade timestampNano
         * @property {string|null} [priceStr] Trade priceStr
         * @property {string|null} [amountStr] Trade amountStr
         * @property {ProtobufMarkets.Trade.OrderSide|null} [orderSide] Trade orderSide
         */
        /**
         * Constructs a new Trade.
         * @memberof ProtobufMarkets
         * @classdesc Represents a Trade.
         * @implements ITrade
         * @constructor
         * @param {ProtobufMarkets.ITrade=} [properties] Properties to set
         */
        function Trade(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Trade externalId.
         * @member {string} externalId
         * @memberof ProtobufMarkets.Trade
         * @instance
         */
        Trade.prototype.externalId = "";
        /**
         * Trade timestamp.
         * @member {number|Long} timestamp
         * @memberof ProtobufMarkets.Trade
         * @instance
         */
        Trade.prototype.timestamp = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * Trade timestampNano.
         * @member {number|Long} timestampNano
         * @memberof ProtobufMarkets.Trade
         * @instance
         */
        Trade.prototype.timestampNano = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * Trade priceStr.
         * @member {string} priceStr
         * @memberof ProtobufMarkets.Trade
         * @instance
         */
        Trade.prototype.priceStr = "";
        /**
         * Trade amountStr.
         * @member {string} amountStr
         * @memberof ProtobufMarkets.Trade
         * @instance
         */
        Trade.prototype.amountStr = "";
        /**
         * Trade orderSide.
         * @member {ProtobufMarkets.Trade.OrderSide} orderSide
         * @memberof ProtobufMarkets.Trade
         * @instance
         */
        Trade.prototype.orderSide = 0;
        /**
         * Creates a new Trade instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.Trade
         * @static
         * @param {ProtobufMarkets.ITrade=} [properties] Properties to set
         * @returns {ProtobufMarkets.Trade} Trade instance
         */
        Trade.create = function create(properties) {
            return new Trade(properties);
        };
        /**
         * Encodes the specified Trade message. Does not implicitly {@link ProtobufMarkets.Trade.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.Trade
         * @static
         * @param {ProtobufMarkets.ITrade} message Trade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Trade.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.timestamp);
            if (message.priceStr != null && Object.hasOwnProperty.call(message, "priceStr"))
                writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.priceStr);
            if (message.amountStr != null && Object.hasOwnProperty.call(message, "amountStr"))
                writer.uint32(/* id 9, wireType 2 =*/ 74).string(message.amountStr);
            if (message.timestampNano != null && Object.hasOwnProperty.call(message, "timestampNano"))
                writer.uint32(/* id 10, wireType 0 =*/ 80).int64(message.timestampNano);
            if (message.externalId != null && Object.hasOwnProperty.call(message, "externalId"))
                writer.uint32(/* id 11, wireType 2 =*/ 90).string(message.externalId);
            if (message.orderSide != null && Object.hasOwnProperty.call(message, "orderSide"))
                writer.uint32(/* id 13, wireType 0 =*/ 104).int32(message.orderSide);
            return writer;
        };
        /**
         * Encodes the specified Trade message, length delimited. Does not implicitly {@link ProtobufMarkets.Trade.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.Trade
         * @static
         * @param {ProtobufMarkets.ITrade} message Trade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Trade.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a Trade message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.Trade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.Trade} Trade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Trade.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.Trade();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 11:
                        message.externalId = reader.string();
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    case 10:
                        message.timestampNano = reader.int64();
                        break;
                    case 8:
                        message.priceStr = reader.string();
                        break;
                    case 9:
                        message.amountStr = reader.string();
                        break;
                    case 13:
                        message.orderSide = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a Trade message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.Trade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.Trade} Trade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Trade.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a Trade message.
         * @function verify
         * @memberof ProtobufMarkets.Trade
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Trade.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.externalId != null && message.hasOwnProperty("externalId"))
                if (!$util.isString(message.externalId))
                    return "externalId: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.timestampNano != null && message.hasOwnProperty("timestampNano"))
                if (!$util.isInteger(message.timestampNano) && !(message.timestampNano && $util.isInteger(message.timestampNano.low) && $util.isInteger(message.timestampNano.high)))
                    return "timestampNano: integer|Long expected";
            if (message.priceStr != null && message.hasOwnProperty("priceStr"))
                if (!$util.isString(message.priceStr))
                    return "priceStr: string expected";
            if (message.amountStr != null && message.hasOwnProperty("amountStr"))
                if (!$util.isString(message.amountStr))
                    return "amountStr: string expected";
            if (message.orderSide != null && message.hasOwnProperty("orderSide"))
                switch (message.orderSide) {
                    default:
                        return "orderSide: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                }
            return null;
        };
        /**
         * Creates a Trade message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.Trade
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.Trade} Trade
         */
        Trade.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.Trade)
                return object;
            var message = new $root.ProtobufMarkets.Trade();
            if (object.externalId != null)
                message.externalId = String(object.externalId);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.timestampNano != null)
                if ($util.Long)
                    (message.timestampNano = $util.Long.fromValue(object.timestampNano)).unsigned = false;
                else if (typeof object.timestampNano === "string")
                    message.timestampNano = parseInt(object.timestampNano, 10);
                else if (typeof object.timestampNano === "number")
                    message.timestampNano = object.timestampNano;
                else if (typeof object.timestampNano === "object")
                    message.timestampNano = new $util.LongBits(object.timestampNano.low >>> 0, object.timestampNano.high >>> 0).toNumber();
            if (object.priceStr != null)
                message.priceStr = String(object.priceStr);
            if (object.amountStr != null)
                message.amountStr = String(object.amountStr);
            switch (object.orderSide) {
                case "UNKNOWN":
                case 0:
                    message.orderSide = 0;
                    break;
                case "BUYSIDE":
                case 1:
                    message.orderSide = 1;
                    break;
                case "SELLSIDE":
                case 2:
                    message.orderSide = 2;
                    break;
            }
            return message;
        };
        /**
         * Creates a plain object from a Trade message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.Trade
         * @static
         * @param {ProtobufMarkets.Trade} message Trade
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Trade.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.priceStr = "";
                object.amountStr = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestampNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.timestampNano = options.longs === String ? "0" : 0;
                object.externalId = "";
                object.orderSide = options.enums === String ? "UNKNOWN" : 0;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.priceStr != null && message.hasOwnProperty("priceStr"))
                object.priceStr = message.priceStr;
            if (message.amountStr != null && message.hasOwnProperty("amountStr"))
                object.amountStr = message.amountStr;
            if (message.timestampNano != null && message.hasOwnProperty("timestampNano"))
                if (typeof message.timestampNano === "number")
                    object.timestampNano = options.longs === String ? String(message.timestampNano) : message.timestampNano;
                else
                    object.timestampNano = options.longs === String ? $util.Long.prototype.toString.call(message.timestampNano) : options.longs === Number ? new $util.LongBits(message.timestampNano.low >>> 0, message.timestampNano.high >>> 0).toNumber() : message.timestampNano;
            if (message.externalId != null && message.hasOwnProperty("externalId"))
                object.externalId = message.externalId;
            if (message.orderSide != null && message.hasOwnProperty("orderSide"))
                object.orderSide = options.enums === String ? $root.ProtobufMarkets.Trade.OrderSide[message.orderSide] : message.orderSide;
            return object;
        };
        /**
         * Converts this Trade to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.Trade
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Trade.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * OrderSide enum.
         * @name ProtobufMarkets.Trade.OrderSide
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} BUYSIDE=1 BUYSIDE value
         * @property {number} SELLSIDE=2 SELLSIDE value
         */
        Trade.OrderSide = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "BUYSIDE"] = 1;
            values[valuesById[2] = "SELLSIDE"] = 2;
            return values;
        })();
        /**
         * Side enum.
         * @name ProtobufMarkets.Trade.Side
         * @enum {number}
         * @property {number} BUY=0 BUY value
         * @property {number} SELL=1 SELL value
         */
        Trade.Side = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "BUY"] = 0;
            values[valuesById[1] = "SELL"] = 1;
            return values;
        })();
        return Trade;
    })();
    ProtobufMarkets.MarketUpdateMessage = (function () {
        /**
         * Properties of a MarketUpdateMessage.
         * @memberof ProtobufMarkets
         * @interface IMarketUpdateMessage
         * @property {ProtobufMarkets.IMarket|null} [market] MarketUpdateMessage market
         * @property {ProtobufMarkets.IOrderBookUpdate|null} [orderBookUpdate] MarketUpdateMessage orderBookUpdate
         * @property {ProtobufMarkets.IOrderBookDeltaUpdate|null} [orderBookDeltaUpdate] MarketUpdateMessage orderBookDeltaUpdate
         * @property {ProtobufMarkets.IOrderBookSpreadUpdate|null} [orderBookSpreadUpdate] MarketUpdateMessage orderBookSpreadUpdate
         * @property {ProtobufMarkets.IOrderBookLiquidityUpdate|null} [orderBookLiquidityUpdate] MarketUpdateMessage orderBookLiquidityUpdate
         * @property {ProtobufMarkets.ITradesUpdate|null} [tradesUpdate] MarketUpdateMessage tradesUpdate
         * @property {ProtobufMarkets.IIntervalsUpdate|null} [intervalsUpdate] MarketUpdateMessage intervalsUpdate
         * @property {ProtobufMarkets.ISummaryUpdate|null} [summaryUpdate] MarketUpdateMessage summaryUpdate
         * @property {ProtobufMarkets.ISparklineUpdate|null} [sparklineUpdate] MarketUpdateMessage sparklineUpdate
         */
        /**
         * Constructs a new MarketUpdateMessage.
         * @memberof ProtobufMarkets
         * @classdesc Represents a MarketUpdateMessage.
         * @implements IMarketUpdateMessage
         * @constructor
         * @param {ProtobufMarkets.IMarketUpdateMessage=} [properties] Properties to set
         */
        function MarketUpdateMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * MarketUpdateMessage market.
         * @member {ProtobufMarkets.IMarket|null|undefined} market
         * @memberof ProtobufMarkets.MarketUpdateMessage
         * @instance
         */
        MarketUpdateMessage.prototype.market = null;
        /**
         * MarketUpdateMessage orderBookUpdate.
         * @member {ProtobufMarkets.IOrderBookUpdate|null|undefined} orderBookUpdate
         * @memberof ProtobufMarkets.MarketUpdateMessage
         * @instance
         */
        MarketUpdateMessage.prototype.orderBookUpdate = null;
        /**
         * MarketUpdateMessage orderBookDeltaUpdate.
         * @member {ProtobufMarkets.IOrderBookDeltaUpdate|null|undefined} orderBookDeltaUpdate
         * @memberof ProtobufMarkets.MarketUpdateMessage
         * @instance
         */
        MarketUpdateMessage.prototype.orderBookDeltaUpdate = null;
        /**
         * MarketUpdateMessage orderBookSpreadUpdate.
         * @member {ProtobufMarkets.IOrderBookSpreadUpdate|null|undefined} orderBookSpreadUpdate
         * @memberof ProtobufMarkets.MarketUpdateMessage
         * @instance
         */
        MarketUpdateMessage.prototype.orderBookSpreadUpdate = null;
        /**
         * MarketUpdateMessage orderBookLiquidityUpdate.
         * @member {ProtobufMarkets.IOrderBookLiquidityUpdate|null|undefined} orderBookLiquidityUpdate
         * @memberof ProtobufMarkets.MarketUpdateMessage
         * @instance
         */
        MarketUpdateMessage.prototype.orderBookLiquidityUpdate = null;
        /**
         * MarketUpdateMessage tradesUpdate.
         * @member {ProtobufMarkets.ITradesUpdate|null|undefined} tradesUpdate
         * @memberof ProtobufMarkets.MarketUpdateMessage
         * @instance
         */
        MarketUpdateMessage.prototype.tradesUpdate = null;
        /**
         * MarketUpdateMessage intervalsUpdate.
         * @member {ProtobufMarkets.IIntervalsUpdate|null|undefined} intervalsUpdate
         * @memberof ProtobufMarkets.MarketUpdateMessage
         * @instance
         */
        MarketUpdateMessage.prototype.intervalsUpdate = null;
        /**
         * MarketUpdateMessage summaryUpdate.
         * @member {ProtobufMarkets.ISummaryUpdate|null|undefined} summaryUpdate
         * @memberof ProtobufMarkets.MarketUpdateMessage
         * @instance
         */
        MarketUpdateMessage.prototype.summaryUpdate = null;
        /**
         * MarketUpdateMessage sparklineUpdate.
         * @member {ProtobufMarkets.ISparklineUpdate|null|undefined} sparklineUpdate
         * @memberof ProtobufMarkets.MarketUpdateMessage
         * @instance
         */
        MarketUpdateMessage.prototype.sparklineUpdate = null;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * MarketUpdateMessage Update.
         * @member {"orderBookUpdate"|"orderBookDeltaUpdate"|"orderBookSpreadUpdate"|"orderBookLiquidityUpdate"|"tradesUpdate"|"intervalsUpdate"|"summaryUpdate"|"sparklineUpdate"|undefined} Update
         * @memberof ProtobufMarkets.MarketUpdateMessage
         * @instance
         */
        Object.defineProperty(MarketUpdateMessage.prototype, "Update", {
            get: $util.oneOfGetter($oneOfFields = ["orderBookUpdate", "orderBookDeltaUpdate", "orderBookSpreadUpdate", "orderBookLiquidityUpdate", "tradesUpdate", "intervalsUpdate", "summaryUpdate", "sparklineUpdate"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new MarketUpdateMessage instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.MarketUpdateMessage
         * @static
         * @param {ProtobufMarkets.IMarketUpdateMessage=} [properties] Properties to set
         * @returns {ProtobufMarkets.MarketUpdateMessage} MarketUpdateMessage instance
         */
        MarketUpdateMessage.create = function create(properties) {
            return new MarketUpdateMessage(properties);
        };
        /**
         * Encodes the specified MarketUpdateMessage message. Does not implicitly {@link ProtobufMarkets.MarketUpdateMessage.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.MarketUpdateMessage
         * @static
         * @param {ProtobufMarkets.IMarketUpdateMessage} message MarketUpdateMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MarketUpdateMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.orderBookUpdate != null && Object.hasOwnProperty.call(message, "orderBookUpdate"))
                $root.ProtobufMarkets.OrderBookUpdate.encode(message.orderBookUpdate, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.orderBookDeltaUpdate != null && Object.hasOwnProperty.call(message, "orderBookDeltaUpdate"))
                $root.ProtobufMarkets.OrderBookDeltaUpdate.encode(message.orderBookDeltaUpdate, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.tradesUpdate != null && Object.hasOwnProperty.call(message, "tradesUpdate"))
                $root.ProtobufMarkets.TradesUpdate.encode(message.tradesUpdate, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            if (message.intervalsUpdate != null && Object.hasOwnProperty.call(message, "intervalsUpdate"))
                $root.ProtobufMarkets.IntervalsUpdate.encode(message.intervalsUpdate, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
            if (message.summaryUpdate != null && Object.hasOwnProperty.call(message, "summaryUpdate"))
                $root.ProtobufMarkets.SummaryUpdate.encode(message.summaryUpdate, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
            if (message.sparklineUpdate != null && Object.hasOwnProperty.call(message, "sparklineUpdate"))
                $root.ProtobufMarkets.SparklineUpdate.encode(message.sparklineUpdate, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
            if (message.market != null && Object.hasOwnProperty.call(message, "market"))
                $root.ProtobufMarkets.Market.encode(message.market, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
            if (message.orderBookSpreadUpdate != null && Object.hasOwnProperty.call(message, "orderBookSpreadUpdate"))
                $root.ProtobufMarkets.OrderBookSpreadUpdate.encode(message.orderBookSpreadUpdate, writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();
            if (message.orderBookLiquidityUpdate != null && Object.hasOwnProperty.call(message, "orderBookLiquidityUpdate"))
                $root.ProtobufMarkets.OrderBookLiquidityUpdate.encode(message.orderBookLiquidityUpdate, writer.uint32(/* id 12, wireType 2 =*/ 98).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified MarketUpdateMessage message, length delimited. Does not implicitly {@link ProtobufMarkets.MarketUpdateMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.MarketUpdateMessage
         * @static
         * @param {ProtobufMarkets.IMarketUpdateMessage} message MarketUpdateMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MarketUpdateMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a MarketUpdateMessage message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.MarketUpdateMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.MarketUpdateMessage} MarketUpdateMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MarketUpdateMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.MarketUpdateMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 9:
                        message.market = $root.ProtobufMarkets.Market.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.orderBookUpdate = $root.ProtobufMarkets.OrderBookUpdate.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.orderBookDeltaUpdate = $root.ProtobufMarkets.OrderBookDeltaUpdate.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.orderBookSpreadUpdate = $root.ProtobufMarkets.OrderBookSpreadUpdate.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.orderBookLiquidityUpdate = $root.ProtobufMarkets.OrderBookLiquidityUpdate.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.tradesUpdate = $root.ProtobufMarkets.TradesUpdate.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.intervalsUpdate = $root.ProtobufMarkets.IntervalsUpdate.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.summaryUpdate = $root.ProtobufMarkets.SummaryUpdate.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.sparklineUpdate = $root.ProtobufMarkets.SparklineUpdate.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a MarketUpdateMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.MarketUpdateMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.MarketUpdateMessage} MarketUpdateMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MarketUpdateMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a MarketUpdateMessage message.
         * @function verify
         * @memberof ProtobufMarkets.MarketUpdateMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MarketUpdateMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.market != null && message.hasOwnProperty("market")) {
                var error = $root.ProtobufMarkets.Market.verify(message.market);
                if (error)
                    return "market." + error;
            }
            if (message.orderBookUpdate != null && message.hasOwnProperty("orderBookUpdate")) {
                properties.Update = 1;
                {
                    var error = $root.ProtobufMarkets.OrderBookUpdate.verify(message.orderBookUpdate);
                    if (error)
                        return "orderBookUpdate." + error;
                }
            }
            if (message.orderBookDeltaUpdate != null && message.hasOwnProperty("orderBookDeltaUpdate")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufMarkets.OrderBookDeltaUpdate.verify(message.orderBookDeltaUpdate);
                    if (error)
                        return "orderBookDeltaUpdate." + error;
                }
            }
            if (message.orderBookSpreadUpdate != null && message.hasOwnProperty("orderBookSpreadUpdate")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufMarkets.OrderBookSpreadUpdate.verify(message.orderBookSpreadUpdate);
                    if (error)
                        return "orderBookSpreadUpdate." + error;
                }
            }
            if (message.orderBookLiquidityUpdate != null && message.hasOwnProperty("orderBookLiquidityUpdate")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufMarkets.OrderBookLiquidityUpdate.verify(message.orderBookLiquidityUpdate);
                    if (error)
                        return "orderBookLiquidityUpdate." + error;
                }
            }
            if (message.tradesUpdate != null && message.hasOwnProperty("tradesUpdate")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufMarkets.TradesUpdate.verify(message.tradesUpdate);
                    if (error)
                        return "tradesUpdate." + error;
                }
            }
            if (message.intervalsUpdate != null && message.hasOwnProperty("intervalsUpdate")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufMarkets.IntervalsUpdate.verify(message.intervalsUpdate);
                    if (error)
                        return "intervalsUpdate." + error;
                }
            }
            if (message.summaryUpdate != null && message.hasOwnProperty("summaryUpdate")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufMarkets.SummaryUpdate.verify(message.summaryUpdate);
                    if (error)
                        return "summaryUpdate." + error;
                }
            }
            if (message.sparklineUpdate != null && message.hasOwnProperty("sparklineUpdate")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufMarkets.SparklineUpdate.verify(message.sparklineUpdate);
                    if (error)
                        return "sparklineUpdate." + error;
                }
            }
            return null;
        };
        /**
         * Creates a MarketUpdateMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.MarketUpdateMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.MarketUpdateMessage} MarketUpdateMessage
         */
        MarketUpdateMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.MarketUpdateMessage)
                return object;
            var message = new $root.ProtobufMarkets.MarketUpdateMessage();
            if (object.market != null) {
                if (typeof object.market !== "object")
                    throw TypeError(".ProtobufMarkets.MarketUpdateMessage.market: object expected");
                message.market = $root.ProtobufMarkets.Market.fromObject(object.market);
            }
            if (object.orderBookUpdate != null) {
                if (typeof object.orderBookUpdate !== "object")
                    throw TypeError(".ProtobufMarkets.MarketUpdateMessage.orderBookUpdate: object expected");
                message.orderBookUpdate = $root.ProtobufMarkets.OrderBookUpdate.fromObject(object.orderBookUpdate);
            }
            if (object.orderBookDeltaUpdate != null) {
                if (typeof object.orderBookDeltaUpdate !== "object")
                    throw TypeError(".ProtobufMarkets.MarketUpdateMessage.orderBookDeltaUpdate: object expected");
                message.orderBookDeltaUpdate = $root.ProtobufMarkets.OrderBookDeltaUpdate.fromObject(object.orderBookDeltaUpdate);
            }
            if (object.orderBookSpreadUpdate != null) {
                if (typeof object.orderBookSpreadUpdate !== "object")
                    throw TypeError(".ProtobufMarkets.MarketUpdateMessage.orderBookSpreadUpdate: object expected");
                message.orderBookSpreadUpdate = $root.ProtobufMarkets.OrderBookSpreadUpdate.fromObject(object.orderBookSpreadUpdate);
            }
            if (object.orderBookLiquidityUpdate != null) {
                if (typeof object.orderBookLiquidityUpdate !== "object")
                    throw TypeError(".ProtobufMarkets.MarketUpdateMessage.orderBookLiquidityUpdate: object expected");
                message.orderBookLiquidityUpdate = $root.ProtobufMarkets.OrderBookLiquidityUpdate.fromObject(object.orderBookLiquidityUpdate);
            }
            if (object.tradesUpdate != null) {
                if (typeof object.tradesUpdate !== "object")
                    throw TypeError(".ProtobufMarkets.MarketUpdateMessage.tradesUpdate: object expected");
                message.tradesUpdate = $root.ProtobufMarkets.TradesUpdate.fromObject(object.tradesUpdate);
            }
            if (object.intervalsUpdate != null) {
                if (typeof object.intervalsUpdate !== "object")
                    throw TypeError(".ProtobufMarkets.MarketUpdateMessage.intervalsUpdate: object expected");
                message.intervalsUpdate = $root.ProtobufMarkets.IntervalsUpdate.fromObject(object.intervalsUpdate);
            }
            if (object.summaryUpdate != null) {
                if (typeof object.summaryUpdate !== "object")
                    throw TypeError(".ProtobufMarkets.MarketUpdateMessage.summaryUpdate: object expected");
                message.summaryUpdate = $root.ProtobufMarkets.SummaryUpdate.fromObject(object.summaryUpdate);
            }
            if (object.sparklineUpdate != null) {
                if (typeof object.sparklineUpdate !== "object")
                    throw TypeError(".ProtobufMarkets.MarketUpdateMessage.sparklineUpdate: object expected");
                message.sparklineUpdate = $root.ProtobufMarkets.SparklineUpdate.fromObject(object.sparklineUpdate);
            }
            return message;
        };
        /**
         * Creates a plain object from a MarketUpdateMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.MarketUpdateMessage
         * @static
         * @param {ProtobufMarkets.MarketUpdateMessage} message MarketUpdateMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MarketUpdateMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.market = null;
            if (message.orderBookUpdate != null && message.hasOwnProperty("orderBookUpdate")) {
                object.orderBookUpdate = $root.ProtobufMarkets.OrderBookUpdate.toObject(message.orderBookUpdate, options);
                if (options.oneofs)
                    object.Update = "orderBookUpdate";
            }
            if (message.orderBookDeltaUpdate != null && message.hasOwnProperty("orderBookDeltaUpdate")) {
                object.orderBookDeltaUpdate = $root.ProtobufMarkets.OrderBookDeltaUpdate.toObject(message.orderBookDeltaUpdate, options);
                if (options.oneofs)
                    object.Update = "orderBookDeltaUpdate";
            }
            if (message.tradesUpdate != null && message.hasOwnProperty("tradesUpdate")) {
                object.tradesUpdate = $root.ProtobufMarkets.TradesUpdate.toObject(message.tradesUpdate, options);
                if (options.oneofs)
                    object.Update = "tradesUpdate";
            }
            if (message.intervalsUpdate != null && message.hasOwnProperty("intervalsUpdate")) {
                object.intervalsUpdate = $root.ProtobufMarkets.IntervalsUpdate.toObject(message.intervalsUpdate, options);
                if (options.oneofs)
                    object.Update = "intervalsUpdate";
            }
            if (message.summaryUpdate != null && message.hasOwnProperty("summaryUpdate")) {
                object.summaryUpdate = $root.ProtobufMarkets.SummaryUpdate.toObject(message.summaryUpdate, options);
                if (options.oneofs)
                    object.Update = "summaryUpdate";
            }
            if (message.sparklineUpdate != null && message.hasOwnProperty("sparklineUpdate")) {
                object.sparklineUpdate = $root.ProtobufMarkets.SparklineUpdate.toObject(message.sparklineUpdate, options);
                if (options.oneofs)
                    object.Update = "sparklineUpdate";
            }
            if (message.market != null && message.hasOwnProperty("market"))
                object.market = $root.ProtobufMarkets.Market.toObject(message.market, options);
            if (message.orderBookSpreadUpdate != null && message.hasOwnProperty("orderBookSpreadUpdate")) {
                object.orderBookSpreadUpdate = $root.ProtobufMarkets.OrderBookSpreadUpdate.toObject(message.orderBookSpreadUpdate, options);
                if (options.oneofs)
                    object.Update = "orderBookSpreadUpdate";
            }
            if (message.orderBookLiquidityUpdate != null && message.hasOwnProperty("orderBookLiquidityUpdate")) {
                object.orderBookLiquidityUpdate = $root.ProtobufMarkets.OrderBookLiquidityUpdate.toObject(message.orderBookLiquidityUpdate, options);
                if (options.oneofs)
                    object.Update = "orderBookLiquidityUpdate";
            }
            return object;
        };
        /**
         * Converts this MarketUpdateMessage to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.MarketUpdateMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MarketUpdateMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return MarketUpdateMessage;
    })();
    ProtobufMarkets.OrderBookUpdate = (function () {
        /**
         * Properties of an OrderBookUpdate.
         * @memberof ProtobufMarkets
         * @interface IOrderBookUpdate
         * @property {string|null} [aggregationModulusStr] OrderBookUpdate aggregationModulusStr
         * @property {number|null} [seqNum] OrderBookUpdate seqNum
         * @property {Array.<ProtobufMarkets.IOrder>|null} [bids] OrderBookUpdate bids
         * @property {Array.<ProtobufMarkets.IOrder>|null} [asks] OrderBookUpdate asks
         */
        /**
         * Constructs a new OrderBookUpdate.
         * @memberof ProtobufMarkets
         * @classdesc Represents an OrderBookUpdate.
         * @implements IOrderBookUpdate
         * @constructor
         * @param {ProtobufMarkets.IOrderBookUpdate=} [properties] Properties to set
         */
        function OrderBookUpdate(properties) {
            this.bids = [];
            this.asks = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * OrderBookUpdate aggregationModulusStr.
         * @member {string} aggregationModulusStr
         * @memberof ProtobufMarkets.OrderBookUpdate
         * @instance
         */
        OrderBookUpdate.prototype.aggregationModulusStr = "";
        /**
         * OrderBookUpdate seqNum.
         * @member {number} seqNum
         * @memberof ProtobufMarkets.OrderBookUpdate
         * @instance
         */
        OrderBookUpdate.prototype.seqNum = 0;
        /**
         * OrderBookUpdate bids.
         * @member {Array.<ProtobufMarkets.IOrder>} bids
         * @memberof ProtobufMarkets.OrderBookUpdate
         * @instance
         */
        OrderBookUpdate.prototype.bids = $util.emptyArray;
        /**
         * OrderBookUpdate asks.
         * @member {Array.<ProtobufMarkets.IOrder>} asks
         * @memberof ProtobufMarkets.OrderBookUpdate
         * @instance
         */
        OrderBookUpdate.prototype.asks = $util.emptyArray;
        /**
         * Creates a new OrderBookUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.OrderBookUpdate
         * @static
         * @param {ProtobufMarkets.IOrderBookUpdate=} [properties] Properties to set
         * @returns {ProtobufMarkets.OrderBookUpdate} OrderBookUpdate instance
         */
        OrderBookUpdate.create = function create(properties) {
            return new OrderBookUpdate(properties);
        };
        /**
         * Encodes the specified OrderBookUpdate message. Does not implicitly {@link ProtobufMarkets.OrderBookUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.OrderBookUpdate
         * @static
         * @param {ProtobufMarkets.IOrderBookUpdate} message OrderBookUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderBookUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bids != null && message.bids.length)
                for (var i = 0; i < message.bids.length; ++i)
                    $root.ProtobufMarkets.Order.encode(message.bids[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.asks != null && message.asks.length)
                for (var i = 0; i < message.asks.length; ++i)
                    $root.ProtobufMarkets.Order.encode(message.asks[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.aggregationModulusStr != null && Object.hasOwnProperty.call(message, "aggregationModulusStr"))
                writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.aggregationModulusStr);
            if (message.seqNum != null && Object.hasOwnProperty.call(message, "seqNum"))
                writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.seqNum);
            return writer;
        };
        /**
         * Encodes the specified OrderBookUpdate message, length delimited. Does not implicitly {@link ProtobufMarkets.OrderBookUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.OrderBookUpdate
         * @static
         * @param {ProtobufMarkets.IOrderBookUpdate} message OrderBookUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderBookUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an OrderBookUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.OrderBookUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.OrderBookUpdate} OrderBookUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderBookUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.OrderBookUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 4:
                        message.aggregationModulusStr = reader.string();
                        break;
                    case 5:
                        message.seqNum = reader.int32();
                        break;
                    case 1:
                        if (!(message.bids && message.bids.length))
                            message.bids = [];
                        message.bids.push($root.ProtobufMarkets.Order.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.asks && message.asks.length))
                            message.asks = [];
                        message.asks.push($root.ProtobufMarkets.Order.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an OrderBookUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.OrderBookUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.OrderBookUpdate} OrderBookUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderBookUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an OrderBookUpdate message.
         * @function verify
         * @memberof ProtobufMarkets.OrderBookUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OrderBookUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.aggregationModulusStr != null && message.hasOwnProperty("aggregationModulusStr"))
                if (!$util.isString(message.aggregationModulusStr))
                    return "aggregationModulusStr: string expected";
            if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                if (!$util.isInteger(message.seqNum))
                    return "seqNum: integer expected";
            if (message.bids != null && message.hasOwnProperty("bids")) {
                if (!Array.isArray(message.bids))
                    return "bids: array expected";
                for (var i = 0; i < message.bids.length; ++i) {
                    var error = $root.ProtobufMarkets.Order.verify(message.bids[i]);
                    if (error)
                        return "bids." + error;
                }
            }
            if (message.asks != null && message.hasOwnProperty("asks")) {
                if (!Array.isArray(message.asks))
                    return "asks: array expected";
                for (var i = 0; i < message.asks.length; ++i) {
                    var error = $root.ProtobufMarkets.Order.verify(message.asks[i]);
                    if (error)
                        return "asks." + error;
                }
            }
            return null;
        };
        /**
         * Creates an OrderBookUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.OrderBookUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.OrderBookUpdate} OrderBookUpdate
         */
        OrderBookUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.OrderBookUpdate)
                return object;
            var message = new $root.ProtobufMarkets.OrderBookUpdate();
            if (object.aggregationModulusStr != null)
                message.aggregationModulusStr = String(object.aggregationModulusStr);
            if (object.seqNum != null)
                message.seqNum = object.seqNum | 0;
            if (object.bids) {
                if (!Array.isArray(object.bids))
                    throw TypeError(".ProtobufMarkets.OrderBookUpdate.bids: array expected");
                message.bids = [];
                for (var i = 0; i < object.bids.length; ++i) {
                    if (typeof object.bids[i] !== "object")
                        throw TypeError(".ProtobufMarkets.OrderBookUpdate.bids: object expected");
                    message.bids[i] = $root.ProtobufMarkets.Order.fromObject(object.bids[i]);
                }
            }
            if (object.asks) {
                if (!Array.isArray(object.asks))
                    throw TypeError(".ProtobufMarkets.OrderBookUpdate.asks: array expected");
                message.asks = [];
                for (var i = 0; i < object.asks.length; ++i) {
                    if (typeof object.asks[i] !== "object")
                        throw TypeError(".ProtobufMarkets.OrderBookUpdate.asks: object expected");
                    message.asks[i] = $root.ProtobufMarkets.Order.fromObject(object.asks[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from an OrderBookUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.OrderBookUpdate
         * @static
         * @param {ProtobufMarkets.OrderBookUpdate} message OrderBookUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OrderBookUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.bids = [];
                object.asks = [];
            }
            if (options.defaults) {
                object.aggregationModulusStr = "";
                object.seqNum = 0;
            }
            if (message.bids && message.bids.length) {
                object.bids = [];
                for (var j = 0; j < message.bids.length; ++j)
                    object.bids[j] = $root.ProtobufMarkets.Order.toObject(message.bids[j], options);
            }
            if (message.asks && message.asks.length) {
                object.asks = [];
                for (var j = 0; j < message.asks.length; ++j)
                    object.asks[j] = $root.ProtobufMarkets.Order.toObject(message.asks[j], options);
            }
            if (message.aggregationModulusStr != null && message.hasOwnProperty("aggregationModulusStr"))
                object.aggregationModulusStr = message.aggregationModulusStr;
            if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                object.seqNum = message.seqNum;
            return object;
        };
        /**
         * Converts this OrderBookUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.OrderBookUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OrderBookUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return OrderBookUpdate;
    })();
    ProtobufMarkets.OrderBookDeltaUpdate = (function () {
        /**
         * Properties of an OrderBookDeltaUpdate.
         * @memberof ProtobufMarkets
         * @interface IOrderBookDeltaUpdate
         * @property {string|null} [aggregationModulusStr] OrderBookDeltaUpdate aggregationModulusStr
         * @property {number|null} [seqNum] OrderBookDeltaUpdate seqNum
         * @property {ProtobufMarkets.OrderBookDeltaUpdate.IOrderDeltas|null} [bids] OrderBookDeltaUpdate bids
         * @property {ProtobufMarkets.OrderBookDeltaUpdate.IOrderDeltas|null} [asks] OrderBookDeltaUpdate asks
         */
        /**
         * Constructs a new OrderBookDeltaUpdate.
         * @memberof ProtobufMarkets
         * @classdesc Represents an OrderBookDeltaUpdate.
         * @implements IOrderBookDeltaUpdate
         * @constructor
         * @param {ProtobufMarkets.IOrderBookDeltaUpdate=} [properties] Properties to set
         */
        function OrderBookDeltaUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * OrderBookDeltaUpdate aggregationModulusStr.
         * @member {string} aggregationModulusStr
         * @memberof ProtobufMarkets.OrderBookDeltaUpdate
         * @instance
         */
        OrderBookDeltaUpdate.prototype.aggregationModulusStr = "";
        /**
         * OrderBookDeltaUpdate seqNum.
         * @member {number} seqNum
         * @memberof ProtobufMarkets.OrderBookDeltaUpdate
         * @instance
         */
        OrderBookDeltaUpdate.prototype.seqNum = 0;
        /**
         * OrderBookDeltaUpdate bids.
         * @member {ProtobufMarkets.OrderBookDeltaUpdate.IOrderDeltas|null|undefined} bids
         * @memberof ProtobufMarkets.OrderBookDeltaUpdate
         * @instance
         */
        OrderBookDeltaUpdate.prototype.bids = null;
        /**
         * OrderBookDeltaUpdate asks.
         * @member {ProtobufMarkets.OrderBookDeltaUpdate.IOrderDeltas|null|undefined} asks
         * @memberof ProtobufMarkets.OrderBookDeltaUpdate
         * @instance
         */
        OrderBookDeltaUpdate.prototype.asks = null;
        /**
         * Creates a new OrderBookDeltaUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.OrderBookDeltaUpdate
         * @static
         * @param {ProtobufMarkets.IOrderBookDeltaUpdate=} [properties] Properties to set
         * @returns {ProtobufMarkets.OrderBookDeltaUpdate} OrderBookDeltaUpdate instance
         */
        OrderBookDeltaUpdate.create = function create(properties) {
            return new OrderBookDeltaUpdate(properties);
        };
        /**
         * Encodes the specified OrderBookDeltaUpdate message. Does not implicitly {@link ProtobufMarkets.OrderBookDeltaUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.OrderBookDeltaUpdate
         * @static
         * @param {ProtobufMarkets.IOrderBookDeltaUpdate} message OrderBookDeltaUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderBookDeltaUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bids != null && Object.hasOwnProperty.call(message, "bids"))
                $root.ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas.encode(message.bids, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.asks != null && Object.hasOwnProperty.call(message, "asks"))
                $root.ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas.encode(message.asks, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.aggregationModulusStr != null && Object.hasOwnProperty.call(message, "aggregationModulusStr"))
                writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.aggregationModulusStr);
            if (message.seqNum != null && Object.hasOwnProperty.call(message, "seqNum"))
                writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.seqNum);
            return writer;
        };
        /**
         * Encodes the specified OrderBookDeltaUpdate message, length delimited. Does not implicitly {@link ProtobufMarkets.OrderBookDeltaUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.OrderBookDeltaUpdate
         * @static
         * @param {ProtobufMarkets.IOrderBookDeltaUpdate} message OrderBookDeltaUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderBookDeltaUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an OrderBookDeltaUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.OrderBookDeltaUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.OrderBookDeltaUpdate} OrderBookDeltaUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderBookDeltaUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.OrderBookDeltaUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 4:
                        message.aggregationModulusStr = reader.string();
                        break;
                    case 5:
                        message.seqNum = reader.int32();
                        break;
                    case 1:
                        message.bids = $root.ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.asks = $root.ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an OrderBookDeltaUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.OrderBookDeltaUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.OrderBookDeltaUpdate} OrderBookDeltaUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderBookDeltaUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an OrderBookDeltaUpdate message.
         * @function verify
         * @memberof ProtobufMarkets.OrderBookDeltaUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OrderBookDeltaUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.aggregationModulusStr != null && message.hasOwnProperty("aggregationModulusStr"))
                if (!$util.isString(message.aggregationModulusStr))
                    return "aggregationModulusStr: string expected";
            if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                if (!$util.isInteger(message.seqNum))
                    return "seqNum: integer expected";
            if (message.bids != null && message.hasOwnProperty("bids")) {
                var error = $root.ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas.verify(message.bids);
                if (error)
                    return "bids." + error;
            }
            if (message.asks != null && message.hasOwnProperty("asks")) {
                var error = $root.ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas.verify(message.asks);
                if (error)
                    return "asks." + error;
            }
            return null;
        };
        /**
         * Creates an OrderBookDeltaUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.OrderBookDeltaUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.OrderBookDeltaUpdate} OrderBookDeltaUpdate
         */
        OrderBookDeltaUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.OrderBookDeltaUpdate)
                return object;
            var message = new $root.ProtobufMarkets.OrderBookDeltaUpdate();
            if (object.aggregationModulusStr != null)
                message.aggregationModulusStr = String(object.aggregationModulusStr);
            if (object.seqNum != null)
                message.seqNum = object.seqNum | 0;
            if (object.bids != null) {
                if (typeof object.bids !== "object")
                    throw TypeError(".ProtobufMarkets.OrderBookDeltaUpdate.bids: object expected");
                message.bids = $root.ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas.fromObject(object.bids);
            }
            if (object.asks != null) {
                if (typeof object.asks !== "object")
                    throw TypeError(".ProtobufMarkets.OrderBookDeltaUpdate.asks: object expected");
                message.asks = $root.ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas.fromObject(object.asks);
            }
            return message;
        };
        /**
         * Creates a plain object from an OrderBookDeltaUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.OrderBookDeltaUpdate
         * @static
         * @param {ProtobufMarkets.OrderBookDeltaUpdate} message OrderBookDeltaUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OrderBookDeltaUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.bids = null;
                object.asks = null;
                object.aggregationModulusStr = "";
                object.seqNum = 0;
            }
            if (message.bids != null && message.hasOwnProperty("bids"))
                object.bids = $root.ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas.toObject(message.bids, options);
            if (message.asks != null && message.hasOwnProperty("asks"))
                object.asks = $root.ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas.toObject(message.asks, options);
            if (message.aggregationModulusStr != null && message.hasOwnProperty("aggregationModulusStr"))
                object.aggregationModulusStr = message.aggregationModulusStr;
            if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                object.seqNum = message.seqNum;
            return object;
        };
        /**
         * Converts this OrderBookDeltaUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.OrderBookDeltaUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OrderBookDeltaUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        OrderBookDeltaUpdate.OrderDeltas = (function () {
            /**
             * Properties of an OrderDeltas.
             * @memberof ProtobufMarkets.OrderBookDeltaUpdate
             * @interface IOrderDeltas
             * @property {Array.<ProtobufMarkets.IOrder>|null} [set] OrderDeltas set
             * @property {Array.<ProtobufMarkets.IOrder>|null} [delta] OrderDeltas delta
             * @property {Array.<string>|null} [removeStr] OrderDeltas removeStr
             */
            /**
             * Constructs a new OrderDeltas.
             * @memberof ProtobufMarkets.OrderBookDeltaUpdate
             * @classdesc Represents an OrderDeltas.
             * @implements IOrderDeltas
             * @constructor
             * @param {ProtobufMarkets.OrderBookDeltaUpdate.IOrderDeltas=} [properties] Properties to set
             */
            function OrderDeltas(properties) {
                this.set = [];
                this.delta = [];
                this.removeStr = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * OrderDeltas set.
             * @member {Array.<ProtobufMarkets.IOrder>} set
             * @memberof ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas
             * @instance
             */
            OrderDeltas.prototype.set = $util.emptyArray;
            /**
             * OrderDeltas delta.
             * @member {Array.<ProtobufMarkets.IOrder>} delta
             * @memberof ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas
             * @instance
             */
            OrderDeltas.prototype.delta = $util.emptyArray;
            /**
             * OrderDeltas removeStr.
             * @member {Array.<string>} removeStr
             * @memberof ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas
             * @instance
             */
            OrderDeltas.prototype.removeStr = $util.emptyArray;
            /**
             * Creates a new OrderDeltas instance using the specified properties.
             * @function create
             * @memberof ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas
             * @static
             * @param {ProtobufMarkets.OrderBookDeltaUpdate.IOrderDeltas=} [properties] Properties to set
             * @returns {ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas} OrderDeltas instance
             */
            OrderDeltas.create = function create(properties) {
                return new OrderDeltas(properties);
            };
            /**
             * Encodes the specified OrderDeltas message. Does not implicitly {@link ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas.verify|verify} messages.
             * @function encode
             * @memberof ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas
             * @static
             * @param {ProtobufMarkets.OrderBookDeltaUpdate.IOrderDeltas} message OrderDeltas message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrderDeltas.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.set != null && message.set.length)
                    for (var i = 0; i < message.set.length; ++i)
                        $root.ProtobufMarkets.Order.encode(message.set[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                if (message.delta != null && message.delta.length)
                    for (var i = 0; i < message.delta.length; ++i)
                        $root.ProtobufMarkets.Order.encode(message.delta[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
                if (message.removeStr != null && message.removeStr.length)
                    for (var i = 0; i < message.removeStr.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.removeStr[i]);
                return writer;
            };
            /**
             * Encodes the specified OrderDeltas message, length delimited. Does not implicitly {@link ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas
             * @static
             * @param {ProtobufMarkets.OrderBookDeltaUpdate.IOrderDeltas} message OrderDeltas message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrderDeltas.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an OrderDeltas message from the specified reader or buffer.
             * @function decode
             * @memberof ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas} OrderDeltas
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrderDeltas.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.set && message.set.length))
                                message.set = [];
                            message.set.push($root.ProtobufMarkets.Order.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.delta && message.delta.length))
                                message.delta = [];
                            message.delta.push($root.ProtobufMarkets.Order.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            if (!(message.removeStr && message.removeStr.length))
                                message.removeStr = [];
                            message.removeStr.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes an OrderDeltas message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas} OrderDeltas
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrderDeltas.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an OrderDeltas message.
             * @function verify
             * @memberof ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OrderDeltas.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.set != null && message.hasOwnProperty("set")) {
                    if (!Array.isArray(message.set))
                        return "set: array expected";
                    for (var i = 0; i < message.set.length; ++i) {
                        var error = $root.ProtobufMarkets.Order.verify(message.set[i]);
                        if (error)
                            return "set." + error;
                    }
                }
                if (message.delta != null && message.hasOwnProperty("delta")) {
                    if (!Array.isArray(message.delta))
                        return "delta: array expected";
                    for (var i = 0; i < message.delta.length; ++i) {
                        var error = $root.ProtobufMarkets.Order.verify(message.delta[i]);
                        if (error)
                            return "delta." + error;
                    }
                }
                if (message.removeStr != null && message.hasOwnProperty("removeStr")) {
                    if (!Array.isArray(message.removeStr))
                        return "removeStr: array expected";
                    for (var i = 0; i < message.removeStr.length; ++i)
                        if (!$util.isString(message.removeStr[i]))
                            return "removeStr: string[] expected";
                }
                return null;
            };
            /**
             * Creates an OrderDeltas message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas} OrderDeltas
             */
            OrderDeltas.fromObject = function fromObject(object) {
                if (object instanceof $root.ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas)
                    return object;
                var message = new $root.ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas();
                if (object.set) {
                    if (!Array.isArray(object.set))
                        throw TypeError(".ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas.set: array expected");
                    message.set = [];
                    for (var i = 0; i < object.set.length; ++i) {
                        if (typeof object.set[i] !== "object")
                            throw TypeError(".ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas.set: object expected");
                        message.set[i] = $root.ProtobufMarkets.Order.fromObject(object.set[i]);
                    }
                }
                if (object.delta) {
                    if (!Array.isArray(object.delta))
                        throw TypeError(".ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas.delta: array expected");
                    message.delta = [];
                    for (var i = 0; i < object.delta.length; ++i) {
                        if (typeof object.delta[i] !== "object")
                            throw TypeError(".ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas.delta: object expected");
                        message.delta[i] = $root.ProtobufMarkets.Order.fromObject(object.delta[i]);
                    }
                }
                if (object.removeStr) {
                    if (!Array.isArray(object.removeStr))
                        throw TypeError(".ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas.removeStr: array expected");
                    message.removeStr = [];
                    for (var i = 0; i < object.removeStr.length; ++i)
                        message.removeStr[i] = String(object.removeStr[i]);
                }
                return message;
            };
            /**
             * Creates a plain object from an OrderDeltas message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas
             * @static
             * @param {ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas} message OrderDeltas
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OrderDeltas.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.set = [];
                    object.delta = [];
                    object.removeStr = [];
                }
                if (message.set && message.set.length) {
                    object.set = [];
                    for (var j = 0; j < message.set.length; ++j)
                        object.set[j] = $root.ProtobufMarkets.Order.toObject(message.set[j], options);
                }
                if (message.delta && message.delta.length) {
                    object.delta = [];
                    for (var j = 0; j < message.delta.length; ++j)
                        object.delta[j] = $root.ProtobufMarkets.Order.toObject(message.delta[j], options);
                }
                if (message.removeStr && message.removeStr.length) {
                    object.removeStr = [];
                    for (var j = 0; j < message.removeStr.length; ++j)
                        object.removeStr[j] = message.removeStr[j];
                }
                return object;
            };
            /**
             * Converts this OrderDeltas to JSON.
             * @function toJSON
             * @memberof ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OrderDeltas.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return OrderDeltas;
        })();
        return OrderBookDeltaUpdate;
    })();
    ProtobufMarkets.OrderBookSpreadUpdate = (function () {
        /**
         * Properties of an OrderBookSpreadUpdate.
         * @memberof ProtobufMarkets
         * @interface IOrderBookSpreadUpdate
         * @property {number|Long|null} [timestamp] OrderBookSpreadUpdate timestamp
         * @property {ProtobufMarkets.IOrder|null} [bid] OrderBookSpreadUpdate bid
         * @property {ProtobufMarkets.IOrder|null} [ask] OrderBookSpreadUpdate ask
         */
        /**
         * Constructs a new OrderBookSpreadUpdate.
         * @memberof ProtobufMarkets
         * @classdesc Represents an OrderBookSpreadUpdate.
         * @implements IOrderBookSpreadUpdate
         * @constructor
         * @param {ProtobufMarkets.IOrderBookSpreadUpdate=} [properties] Properties to set
         */
        function OrderBookSpreadUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * OrderBookSpreadUpdate timestamp.
         * @member {number|Long} timestamp
         * @memberof ProtobufMarkets.OrderBookSpreadUpdate
         * @instance
         */
        OrderBookSpreadUpdate.prototype.timestamp = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * OrderBookSpreadUpdate bid.
         * @member {ProtobufMarkets.IOrder|null|undefined} bid
         * @memberof ProtobufMarkets.OrderBookSpreadUpdate
         * @instance
         */
        OrderBookSpreadUpdate.prototype.bid = null;
        /**
         * OrderBookSpreadUpdate ask.
         * @member {ProtobufMarkets.IOrder|null|undefined} ask
         * @memberof ProtobufMarkets.OrderBookSpreadUpdate
         * @instance
         */
        OrderBookSpreadUpdate.prototype.ask = null;
        /**
         * Creates a new OrderBookSpreadUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.OrderBookSpreadUpdate
         * @static
         * @param {ProtobufMarkets.IOrderBookSpreadUpdate=} [properties] Properties to set
         * @returns {ProtobufMarkets.OrderBookSpreadUpdate} OrderBookSpreadUpdate instance
         */
        OrderBookSpreadUpdate.create = function create(properties) {
            return new OrderBookSpreadUpdate(properties);
        };
        /**
         * Encodes the specified OrderBookSpreadUpdate message. Does not implicitly {@link ProtobufMarkets.OrderBookSpreadUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.OrderBookSpreadUpdate
         * @static
         * @param {ProtobufMarkets.IOrderBookSpreadUpdate} message OrderBookSpreadUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderBookSpreadUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.timestamp);
            if (message.bid != null && Object.hasOwnProperty.call(message, "bid"))
                $root.ProtobufMarkets.Order.encode(message.bid, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.ask != null && Object.hasOwnProperty.call(message, "ask"))
                $root.ProtobufMarkets.Order.encode(message.ask, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified OrderBookSpreadUpdate message, length delimited. Does not implicitly {@link ProtobufMarkets.OrderBookSpreadUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.OrderBookSpreadUpdate
         * @static
         * @param {ProtobufMarkets.IOrderBookSpreadUpdate} message OrderBookSpreadUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderBookSpreadUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an OrderBookSpreadUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.OrderBookSpreadUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.OrderBookSpreadUpdate} OrderBookSpreadUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderBookSpreadUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.OrderBookSpreadUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.timestamp = reader.int64();
                        break;
                    case 2:
                        message.bid = $root.ProtobufMarkets.Order.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.ask = $root.ProtobufMarkets.Order.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an OrderBookSpreadUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.OrderBookSpreadUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.OrderBookSpreadUpdate} OrderBookSpreadUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderBookSpreadUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an OrderBookSpreadUpdate message.
         * @function verify
         * @memberof ProtobufMarkets.OrderBookSpreadUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OrderBookSpreadUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.bid != null && message.hasOwnProperty("bid")) {
                var error = $root.ProtobufMarkets.Order.verify(message.bid);
                if (error)
                    return "bid." + error;
            }
            if (message.ask != null && message.hasOwnProperty("ask")) {
                var error = $root.ProtobufMarkets.Order.verify(message.ask);
                if (error)
                    return "ask." + error;
            }
            return null;
        };
        /**
         * Creates an OrderBookSpreadUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.OrderBookSpreadUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.OrderBookSpreadUpdate} OrderBookSpreadUpdate
         */
        OrderBookSpreadUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.OrderBookSpreadUpdate)
                return object;
            var message = new $root.ProtobufMarkets.OrderBookSpreadUpdate();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.bid != null) {
                if (typeof object.bid !== "object")
                    throw TypeError(".ProtobufMarkets.OrderBookSpreadUpdate.bid: object expected");
                message.bid = $root.ProtobufMarkets.Order.fromObject(object.bid);
            }
            if (object.ask != null) {
                if (typeof object.ask !== "object")
                    throw TypeError(".ProtobufMarkets.OrderBookSpreadUpdate.ask: object expected");
                message.ask = $root.ProtobufMarkets.Order.fromObject(object.ask);
            }
            return message;
        };
        /**
         * Creates a plain object from an OrderBookSpreadUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.OrderBookSpreadUpdate
         * @static
         * @param {ProtobufMarkets.OrderBookSpreadUpdate} message OrderBookSpreadUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OrderBookSpreadUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.bid = null;
                object.ask = null;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.bid != null && message.hasOwnProperty("bid"))
                object.bid = $root.ProtobufMarkets.Order.toObject(message.bid, options);
            if (message.ask != null && message.hasOwnProperty("ask"))
                object.ask = $root.ProtobufMarkets.Order.toObject(message.ask, options);
            return object;
        };
        /**
         * Converts this OrderBookSpreadUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.OrderBookSpreadUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OrderBookSpreadUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return OrderBookSpreadUpdate;
    })();
    ProtobufMarkets.OrderBookLiquidityUpdate = (function () {
        /**
         * Properties of an OrderBookLiquidityUpdate.
         * @memberof ProtobufMarkets
         * @interface IOrderBookLiquidityUpdate
         * @property {number|Long|null} [timestamp] OrderBookLiquidityUpdate timestamp
         * @property {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquidityUpdateSide|null} [bid] OrderBookLiquidityUpdate bid
         * @property {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquidityUpdateSide|null} [ask] OrderBookLiquidityUpdate ask
         */
        /**
         * Constructs a new OrderBookLiquidityUpdate.
         * @memberof ProtobufMarkets
         * @classdesc Represents an OrderBookLiquidityUpdate.
         * @implements IOrderBookLiquidityUpdate
         * @constructor
         * @param {ProtobufMarkets.IOrderBookLiquidityUpdate=} [properties] Properties to set
         */
        function OrderBookLiquidityUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * OrderBookLiquidityUpdate timestamp.
         * @member {number|Long} timestamp
         * @memberof ProtobufMarkets.OrderBookLiquidityUpdate
         * @instance
         */
        OrderBookLiquidityUpdate.prototype.timestamp = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * OrderBookLiquidityUpdate bid.
         * @member {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquidityUpdateSide|null|undefined} bid
         * @memberof ProtobufMarkets.OrderBookLiquidityUpdate
         * @instance
         */
        OrderBookLiquidityUpdate.prototype.bid = null;
        /**
         * OrderBookLiquidityUpdate ask.
         * @member {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquidityUpdateSide|null|undefined} ask
         * @memberof ProtobufMarkets.OrderBookLiquidityUpdate
         * @instance
         */
        OrderBookLiquidityUpdate.prototype.ask = null;
        /**
         * Creates a new OrderBookLiquidityUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.OrderBookLiquidityUpdate
         * @static
         * @param {ProtobufMarkets.IOrderBookLiquidityUpdate=} [properties] Properties to set
         * @returns {ProtobufMarkets.OrderBookLiquidityUpdate} OrderBookLiquidityUpdate instance
         */
        OrderBookLiquidityUpdate.create = function create(properties) {
            return new OrderBookLiquidityUpdate(properties);
        };
        /**
         * Encodes the specified OrderBookLiquidityUpdate message. Does not implicitly {@link ProtobufMarkets.OrderBookLiquidityUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.OrderBookLiquidityUpdate
         * @static
         * @param {ProtobufMarkets.IOrderBookLiquidityUpdate} message OrderBookLiquidityUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderBookLiquidityUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.timestamp);
            if (message.bid != null && Object.hasOwnProperty.call(message, "bid"))
                $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide.encode(message.bid, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.ask != null && Object.hasOwnProperty.call(message, "ask"))
                $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide.encode(message.ask, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified OrderBookLiquidityUpdate message, length delimited. Does not implicitly {@link ProtobufMarkets.OrderBookLiquidityUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.OrderBookLiquidityUpdate
         * @static
         * @param {ProtobufMarkets.IOrderBookLiquidityUpdate} message OrderBookLiquidityUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderBookLiquidityUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an OrderBookLiquidityUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.OrderBookLiquidityUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.OrderBookLiquidityUpdate} OrderBookLiquidityUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderBookLiquidityUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.OrderBookLiquidityUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.timestamp = reader.int64();
                        break;
                    case 2:
                        message.bid = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.ask = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an OrderBookLiquidityUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.OrderBookLiquidityUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.OrderBookLiquidityUpdate} OrderBookLiquidityUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderBookLiquidityUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an OrderBookLiquidityUpdate message.
         * @function verify
         * @memberof ProtobufMarkets.OrderBookLiquidityUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OrderBookLiquidityUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.bid != null && message.hasOwnProperty("bid")) {
                var error = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide.verify(message.bid);
                if (error)
                    return "bid." + error;
            }
            if (message.ask != null && message.hasOwnProperty("ask")) {
                var error = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide.verify(message.ask);
                if (error)
                    return "ask." + error;
            }
            return null;
        };
        /**
         * Creates an OrderBookLiquidityUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.OrderBookLiquidityUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.OrderBookLiquidityUpdate} OrderBookLiquidityUpdate
         */
        OrderBookLiquidityUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.OrderBookLiquidityUpdate)
                return object;
            var message = new $root.ProtobufMarkets.OrderBookLiquidityUpdate();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.bid != null) {
                if (typeof object.bid !== "object")
                    throw TypeError(".ProtobufMarkets.OrderBookLiquidityUpdate.bid: object expected");
                message.bid = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide.fromObject(object.bid);
            }
            if (object.ask != null) {
                if (typeof object.ask !== "object")
                    throw TypeError(".ProtobufMarkets.OrderBookLiquidityUpdate.ask: object expected");
                message.ask = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide.fromObject(object.ask);
            }
            return message;
        };
        /**
         * Creates a plain object from an OrderBookLiquidityUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.OrderBookLiquidityUpdate
         * @static
         * @param {ProtobufMarkets.OrderBookLiquidityUpdate} message OrderBookLiquidityUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OrderBookLiquidityUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.bid = null;
                object.ask = null;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.bid != null && message.hasOwnProperty("bid"))
                object.bid = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide.toObject(message.bid, options);
            if (message.ask != null && message.hasOwnProperty("ask"))
                object.ask = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide.toObject(message.ask, options);
            return object;
        };
        /**
         * Converts this OrderBookLiquidityUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.OrderBookLiquidityUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OrderBookLiquidityUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        OrderBookLiquidityUpdate.OrderBookLiquiditySums = (function () {
            /**
             * Properties of an OrderBookLiquiditySums.
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate
             * @interface IOrderBookLiquiditySums
             * @property {string|null} [totalBase] OrderBookLiquiditySums totalBase
             * @property {string|null} [totalQuote] OrderBookLiquiditySums totalQuote
             */
            /**
             * Constructs a new OrderBookLiquiditySums.
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate
             * @classdesc Represents an OrderBookLiquiditySums.
             * @implements IOrderBookLiquiditySums
             * @constructor
             * @param {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums=} [properties] Properties to set
             */
            function OrderBookLiquiditySums(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * OrderBookLiquiditySums totalBase.
             * @member {string} totalBase
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums
             * @instance
             */
            OrderBookLiquiditySums.prototype.totalBase = "";
            /**
             * OrderBookLiquiditySums totalQuote.
             * @member {string} totalQuote
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums
             * @instance
             */
            OrderBookLiquiditySums.prototype.totalQuote = "";
            /**
             * Creates a new OrderBookLiquiditySums instance using the specified properties.
             * @function create
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums
             * @static
             * @param {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums=} [properties] Properties to set
             * @returns {ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums} OrderBookLiquiditySums instance
             */
            OrderBookLiquiditySums.create = function create(properties) {
                return new OrderBookLiquiditySums(properties);
            };
            /**
             * Encodes the specified OrderBookLiquiditySums message. Does not implicitly {@link ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.verify|verify} messages.
             * @function encode
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums
             * @static
             * @param {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums} message OrderBookLiquiditySums message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrderBookLiquiditySums.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.totalBase != null && Object.hasOwnProperty.call(message, "totalBase"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.totalBase);
                if (message.totalQuote != null && Object.hasOwnProperty.call(message, "totalQuote"))
                    writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.totalQuote);
                return writer;
            };
            /**
             * Encodes the specified OrderBookLiquiditySums message, length delimited. Does not implicitly {@link ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums
             * @static
             * @param {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums} message OrderBookLiquiditySums message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrderBookLiquiditySums.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an OrderBookLiquiditySums message from the specified reader or buffer.
             * @function decode
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums} OrderBookLiquiditySums
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrderBookLiquiditySums.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.totalBase = reader.string();
                            break;
                        case 2:
                            message.totalQuote = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes an OrderBookLiquiditySums message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums} OrderBookLiquiditySums
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrderBookLiquiditySums.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an OrderBookLiquiditySums message.
             * @function verify
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OrderBookLiquiditySums.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.totalBase != null && message.hasOwnProperty("totalBase"))
                    if (!$util.isString(message.totalBase))
                        return "totalBase: string expected";
                if (message.totalQuote != null && message.hasOwnProperty("totalQuote"))
                    if (!$util.isString(message.totalQuote))
                        return "totalQuote: string expected";
                return null;
            };
            /**
             * Creates an OrderBookLiquiditySums message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums} OrderBookLiquiditySums
             */
            OrderBookLiquiditySums.fromObject = function fromObject(object) {
                if (object instanceof $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums)
                    return object;
                var message = new $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums();
                if (object.totalBase != null)
                    message.totalBase = String(object.totalBase);
                if (object.totalQuote != null)
                    message.totalQuote = String(object.totalQuote);
                return message;
            };
            /**
             * Creates a plain object from an OrderBookLiquiditySums message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums
             * @static
             * @param {ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums} message OrderBookLiquiditySums
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OrderBookLiquiditySums.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.totalBase = "";
                    object.totalQuote = "";
                }
                if (message.totalBase != null && message.hasOwnProperty("totalBase"))
                    object.totalBase = message.totalBase;
                if (message.totalQuote != null && message.hasOwnProperty("totalQuote"))
                    object.totalQuote = message.totalQuote;
                return object;
            };
            /**
             * Converts this OrderBookLiquiditySums to JSON.
             * @function toJSON
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OrderBookLiquiditySums.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return OrderBookLiquiditySums;
        })();
        OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide = (function () {
            /**
             * Properties of an OrderBookLiquidityUpdateSide.
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate
             * @interface IOrderBookLiquidityUpdateSide
             * @property {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums|null} [bip25] OrderBookLiquidityUpdateSide bip25
             * @property {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums|null} [bip50] OrderBookLiquidityUpdateSide bip50
             * @property {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums|null} [bip75] OrderBookLiquidityUpdateSide bip75
             * @property {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums|null} [bip100] OrderBookLiquidityUpdateSide bip100
             * @property {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums|null} [bip150] OrderBookLiquidityUpdateSide bip150
             * @property {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums|null} [bip200] OrderBookLiquidityUpdateSide bip200
             * @property {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums|null} [bip250] OrderBookLiquidityUpdateSide bip250
             * @property {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums|null} [bip300] OrderBookLiquidityUpdateSide bip300
             * @property {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums|null} [bip400] OrderBookLiquidityUpdateSide bip400
             * @property {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums|null} [bip500] OrderBookLiquidityUpdateSide bip500
             */
            /**
             * Constructs a new OrderBookLiquidityUpdateSide.
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate
             * @classdesc Represents an OrderBookLiquidityUpdateSide.
             * @implements IOrderBookLiquidityUpdateSide
             * @constructor
             * @param {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquidityUpdateSide=} [properties] Properties to set
             */
            function OrderBookLiquidityUpdateSide(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * OrderBookLiquidityUpdateSide bip25.
             * @member {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums|null|undefined} bip25
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide
             * @instance
             */
            OrderBookLiquidityUpdateSide.prototype.bip25 = null;
            /**
             * OrderBookLiquidityUpdateSide bip50.
             * @member {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums|null|undefined} bip50
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide
             * @instance
             */
            OrderBookLiquidityUpdateSide.prototype.bip50 = null;
            /**
             * OrderBookLiquidityUpdateSide bip75.
             * @member {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums|null|undefined} bip75
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide
             * @instance
             */
            OrderBookLiquidityUpdateSide.prototype.bip75 = null;
            /**
             * OrderBookLiquidityUpdateSide bip100.
             * @member {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums|null|undefined} bip100
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide
             * @instance
             */
            OrderBookLiquidityUpdateSide.prototype.bip100 = null;
            /**
             * OrderBookLiquidityUpdateSide bip150.
             * @member {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums|null|undefined} bip150
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide
             * @instance
             */
            OrderBookLiquidityUpdateSide.prototype.bip150 = null;
            /**
             * OrderBookLiquidityUpdateSide bip200.
             * @member {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums|null|undefined} bip200
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide
             * @instance
             */
            OrderBookLiquidityUpdateSide.prototype.bip200 = null;
            /**
             * OrderBookLiquidityUpdateSide bip250.
             * @member {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums|null|undefined} bip250
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide
             * @instance
             */
            OrderBookLiquidityUpdateSide.prototype.bip250 = null;
            /**
             * OrderBookLiquidityUpdateSide bip300.
             * @member {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums|null|undefined} bip300
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide
             * @instance
             */
            OrderBookLiquidityUpdateSide.prototype.bip300 = null;
            /**
             * OrderBookLiquidityUpdateSide bip400.
             * @member {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums|null|undefined} bip400
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide
             * @instance
             */
            OrderBookLiquidityUpdateSide.prototype.bip400 = null;
            /**
             * OrderBookLiquidityUpdateSide bip500.
             * @member {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquiditySums|null|undefined} bip500
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide
             * @instance
             */
            OrderBookLiquidityUpdateSide.prototype.bip500 = null;
            /**
             * Creates a new OrderBookLiquidityUpdateSide instance using the specified properties.
             * @function create
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide
             * @static
             * @param {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquidityUpdateSide=} [properties] Properties to set
             * @returns {ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide} OrderBookLiquidityUpdateSide instance
             */
            OrderBookLiquidityUpdateSide.create = function create(properties) {
                return new OrderBookLiquidityUpdateSide(properties);
            };
            /**
             * Encodes the specified OrderBookLiquidityUpdateSide message. Does not implicitly {@link ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide.verify|verify} messages.
             * @function encode
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide
             * @static
             * @param {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquidityUpdateSide} message OrderBookLiquidityUpdateSide message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrderBookLiquidityUpdateSide.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.bip25 != null && Object.hasOwnProperty.call(message, "bip25"))
                    $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.encode(message.bip25, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                if (message.bip50 != null && Object.hasOwnProperty.call(message, "bip50"))
                    $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.encode(message.bip50, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
                if (message.bip75 != null && Object.hasOwnProperty.call(message, "bip75"))
                    $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.encode(message.bip75, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
                if (message.bip100 != null && Object.hasOwnProperty.call(message, "bip100"))
                    $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.encode(message.bip100, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
                if (message.bip150 != null && Object.hasOwnProperty.call(message, "bip150"))
                    $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.encode(message.bip150, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
                if (message.bip200 != null && Object.hasOwnProperty.call(message, "bip200"))
                    $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.encode(message.bip200, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
                if (message.bip250 != null && Object.hasOwnProperty.call(message, "bip250"))
                    $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.encode(message.bip250, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
                if (message.bip300 != null && Object.hasOwnProperty.call(message, "bip300"))
                    $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.encode(message.bip300, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
                if (message.bip400 != null && Object.hasOwnProperty.call(message, "bip400"))
                    $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.encode(message.bip400, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
                if (message.bip500 != null && Object.hasOwnProperty.call(message, "bip500"))
                    $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.encode(message.bip500, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified OrderBookLiquidityUpdateSide message, length delimited. Does not implicitly {@link ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide
             * @static
             * @param {ProtobufMarkets.OrderBookLiquidityUpdate.IOrderBookLiquidityUpdateSide} message OrderBookLiquidityUpdateSide message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrderBookLiquidityUpdateSide.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an OrderBookLiquidityUpdateSide message from the specified reader or buffer.
             * @function decode
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide} OrderBookLiquidityUpdateSide
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrderBookLiquidityUpdateSide.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.bip25 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.bip50 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.bip75 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.bip100 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.bip150 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.bip200 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.bip250 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.bip300 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.bip400 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.bip500 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes an OrderBookLiquidityUpdateSide message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide} OrderBookLiquidityUpdateSide
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrderBookLiquidityUpdateSide.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an OrderBookLiquidityUpdateSide message.
             * @function verify
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OrderBookLiquidityUpdateSide.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.bip25 != null && message.hasOwnProperty("bip25")) {
                    var error = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.verify(message.bip25);
                    if (error)
                        return "bip25." + error;
                }
                if (message.bip50 != null && message.hasOwnProperty("bip50")) {
                    var error = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.verify(message.bip50);
                    if (error)
                        return "bip50." + error;
                }
                if (message.bip75 != null && message.hasOwnProperty("bip75")) {
                    var error = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.verify(message.bip75);
                    if (error)
                        return "bip75." + error;
                }
                if (message.bip100 != null && message.hasOwnProperty("bip100")) {
                    var error = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.verify(message.bip100);
                    if (error)
                        return "bip100." + error;
                }
                if (message.bip150 != null && message.hasOwnProperty("bip150")) {
                    var error = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.verify(message.bip150);
                    if (error)
                        return "bip150." + error;
                }
                if (message.bip200 != null && message.hasOwnProperty("bip200")) {
                    var error = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.verify(message.bip200);
                    if (error)
                        return "bip200." + error;
                }
                if (message.bip250 != null && message.hasOwnProperty("bip250")) {
                    var error = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.verify(message.bip250);
                    if (error)
                        return "bip250." + error;
                }
                if (message.bip300 != null && message.hasOwnProperty("bip300")) {
                    var error = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.verify(message.bip300);
                    if (error)
                        return "bip300." + error;
                }
                if (message.bip400 != null && message.hasOwnProperty("bip400")) {
                    var error = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.verify(message.bip400);
                    if (error)
                        return "bip400." + error;
                }
                if (message.bip500 != null && message.hasOwnProperty("bip500")) {
                    var error = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.verify(message.bip500);
                    if (error)
                        return "bip500." + error;
                }
                return null;
            };
            /**
             * Creates an OrderBookLiquidityUpdateSide message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide} OrderBookLiquidityUpdateSide
             */
            OrderBookLiquidityUpdateSide.fromObject = function fromObject(object) {
                if (object instanceof $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide)
                    return object;
                var message = new $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide();
                if (object.bip25 != null) {
                    if (typeof object.bip25 !== "object")
                        throw TypeError(".ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide.bip25: object expected");
                    message.bip25 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.fromObject(object.bip25);
                }
                if (object.bip50 != null) {
                    if (typeof object.bip50 !== "object")
                        throw TypeError(".ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide.bip50: object expected");
                    message.bip50 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.fromObject(object.bip50);
                }
                if (object.bip75 != null) {
                    if (typeof object.bip75 !== "object")
                        throw TypeError(".ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide.bip75: object expected");
                    message.bip75 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.fromObject(object.bip75);
                }
                if (object.bip100 != null) {
                    if (typeof object.bip100 !== "object")
                        throw TypeError(".ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide.bip100: object expected");
                    message.bip100 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.fromObject(object.bip100);
                }
                if (object.bip150 != null) {
                    if (typeof object.bip150 !== "object")
                        throw TypeError(".ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide.bip150: object expected");
                    message.bip150 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.fromObject(object.bip150);
                }
                if (object.bip200 != null) {
                    if (typeof object.bip200 !== "object")
                        throw TypeError(".ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide.bip200: object expected");
                    message.bip200 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.fromObject(object.bip200);
                }
                if (object.bip250 != null) {
                    if (typeof object.bip250 !== "object")
                        throw TypeError(".ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide.bip250: object expected");
                    message.bip250 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.fromObject(object.bip250);
                }
                if (object.bip300 != null) {
                    if (typeof object.bip300 !== "object")
                        throw TypeError(".ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide.bip300: object expected");
                    message.bip300 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.fromObject(object.bip300);
                }
                if (object.bip400 != null) {
                    if (typeof object.bip400 !== "object")
                        throw TypeError(".ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide.bip400: object expected");
                    message.bip400 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.fromObject(object.bip400);
                }
                if (object.bip500 != null) {
                    if (typeof object.bip500 !== "object")
                        throw TypeError(".ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide.bip500: object expected");
                    message.bip500 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.fromObject(object.bip500);
                }
                return message;
            };
            /**
             * Creates a plain object from an OrderBookLiquidityUpdateSide message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide
             * @static
             * @param {ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide} message OrderBookLiquidityUpdateSide
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OrderBookLiquidityUpdateSide.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.bip25 = null;
                    object.bip50 = null;
                    object.bip75 = null;
                    object.bip100 = null;
                    object.bip150 = null;
                    object.bip200 = null;
                    object.bip250 = null;
                    object.bip300 = null;
                    object.bip400 = null;
                    object.bip500 = null;
                }
                if (message.bip25 != null && message.hasOwnProperty("bip25"))
                    object.bip25 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.toObject(message.bip25, options);
                if (message.bip50 != null && message.hasOwnProperty("bip50"))
                    object.bip50 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.toObject(message.bip50, options);
                if (message.bip75 != null && message.hasOwnProperty("bip75"))
                    object.bip75 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.toObject(message.bip75, options);
                if (message.bip100 != null && message.hasOwnProperty("bip100"))
                    object.bip100 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.toObject(message.bip100, options);
                if (message.bip150 != null && message.hasOwnProperty("bip150"))
                    object.bip150 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.toObject(message.bip150, options);
                if (message.bip200 != null && message.hasOwnProperty("bip200"))
                    object.bip200 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.toObject(message.bip200, options);
                if (message.bip250 != null && message.hasOwnProperty("bip250"))
                    object.bip250 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.toObject(message.bip250, options);
                if (message.bip300 != null && message.hasOwnProperty("bip300"))
                    object.bip300 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.toObject(message.bip300, options);
                if (message.bip400 != null && message.hasOwnProperty("bip400"))
                    object.bip400 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.toObject(message.bip400, options);
                if (message.bip500 != null && message.hasOwnProperty("bip500"))
                    object.bip500 = $root.ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums.toObject(message.bip500, options);
                return object;
            };
            /**
             * Converts this OrderBookLiquidityUpdateSide to JSON.
             * @function toJSON
             * @memberof ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OrderBookLiquidityUpdateSide.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return OrderBookLiquidityUpdateSide;
        })();
        return OrderBookLiquidityUpdate;
    })();
    ProtobufMarkets.TradesUpdate = (function () {
        /**
         * Properties of a TradesUpdate.
         * @memberof ProtobufMarkets
         * @interface ITradesUpdate
         * @property {Array.<ProtobufMarkets.ITrade>|null} [trades] TradesUpdate trades
         */
        /**
         * Constructs a new TradesUpdate.
         * @memberof ProtobufMarkets
         * @classdesc Represents a TradesUpdate.
         * @implements ITradesUpdate
         * @constructor
         * @param {ProtobufMarkets.ITradesUpdate=} [properties] Properties to set
         */
        function TradesUpdate(properties) {
            this.trades = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * TradesUpdate trades.
         * @member {Array.<ProtobufMarkets.ITrade>} trades
         * @memberof ProtobufMarkets.TradesUpdate
         * @instance
         */
        TradesUpdate.prototype.trades = $util.emptyArray;
        /**
         * Creates a new TradesUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.TradesUpdate
         * @static
         * @param {ProtobufMarkets.ITradesUpdate=} [properties] Properties to set
         * @returns {ProtobufMarkets.TradesUpdate} TradesUpdate instance
         */
        TradesUpdate.create = function create(properties) {
            return new TradesUpdate(properties);
        };
        /**
         * Encodes the specified TradesUpdate message. Does not implicitly {@link ProtobufMarkets.TradesUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.TradesUpdate
         * @static
         * @param {ProtobufMarkets.ITradesUpdate} message TradesUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradesUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trades != null && message.trades.length)
                for (var i = 0; i < message.trades.length; ++i)
                    $root.ProtobufMarkets.Trade.encode(message.trades[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified TradesUpdate message, length delimited. Does not implicitly {@link ProtobufMarkets.TradesUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.TradesUpdate
         * @static
         * @param {ProtobufMarkets.ITradesUpdate} message TradesUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradesUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a TradesUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.TradesUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.TradesUpdate} TradesUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradesUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.TradesUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.trades && message.trades.length))
                            message.trades = [];
                        message.trades.push($root.ProtobufMarkets.Trade.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a TradesUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.TradesUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.TradesUpdate} TradesUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradesUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a TradesUpdate message.
         * @function verify
         * @memberof ProtobufMarkets.TradesUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TradesUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trades != null && message.hasOwnProperty("trades")) {
                if (!Array.isArray(message.trades))
                    return "trades: array expected";
                for (var i = 0; i < message.trades.length; ++i) {
                    var error = $root.ProtobufMarkets.Trade.verify(message.trades[i]);
                    if (error)
                        return "trades." + error;
                }
            }
            return null;
        };
        /**
         * Creates a TradesUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.TradesUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.TradesUpdate} TradesUpdate
         */
        TradesUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.TradesUpdate)
                return object;
            var message = new $root.ProtobufMarkets.TradesUpdate();
            if (object.trades) {
                if (!Array.isArray(object.trades))
                    throw TypeError(".ProtobufMarkets.TradesUpdate.trades: array expected");
                message.trades = [];
                for (var i = 0; i < object.trades.length; ++i) {
                    if (typeof object.trades[i] !== "object")
                        throw TypeError(".ProtobufMarkets.TradesUpdate.trades: object expected");
                    message.trades[i] = $root.ProtobufMarkets.Trade.fromObject(object.trades[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a TradesUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.TradesUpdate
         * @static
         * @param {ProtobufMarkets.TradesUpdate} message TradesUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TradesUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.trades = [];
            if (message.trades && message.trades.length) {
                object.trades = [];
                for (var j = 0; j < message.trades.length; ++j)
                    object.trades[j] = $root.ProtobufMarkets.Trade.toObject(message.trades[j], options);
            }
            return object;
        };
        /**
         * Converts this TradesUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.TradesUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TradesUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return TradesUpdate;
    })();
    ProtobufMarkets.Interval = (function () {
        /**
         * Properties of an Interval.
         * @memberof ProtobufMarkets
         * @interface IInterval
         * @property {number|Long|null} [closetime] Interval closetime
         * @property {ProtobufMarkets.Interval.IOHLC|null} [ohlc] Interval ohlc
         * @property {string|null} [volumeBaseStr] Interval volumeBaseStr
         * @property {string|null} [volumeQuoteStr] Interval volumeQuoteStr
         * @property {string|null} [periodName] Interval periodName
         * @property {number|null} [period] Interval period
         */
        /**
         * Constructs a new Interval.
         * @memberof ProtobufMarkets
         * @classdesc Represents an Interval.
         * @implements IInterval
         * @constructor
         * @param {ProtobufMarkets.IInterval=} [properties] Properties to set
         */
        function Interval(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Interval closetime.
         * @member {number|Long} closetime
         * @memberof ProtobufMarkets.Interval
         * @instance
         */
        Interval.prototype.closetime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * Interval ohlc.
         * @member {ProtobufMarkets.Interval.IOHLC|null|undefined} ohlc
         * @memberof ProtobufMarkets.Interval
         * @instance
         */
        Interval.prototype.ohlc = null;
        /**
         * Interval volumeBaseStr.
         * @member {string} volumeBaseStr
         * @memberof ProtobufMarkets.Interval
         * @instance
         */
        Interval.prototype.volumeBaseStr = "";
        /**
         * Interval volumeQuoteStr.
         * @member {string} volumeQuoteStr
         * @memberof ProtobufMarkets.Interval
         * @instance
         */
        Interval.prototype.volumeQuoteStr = "";
        /**
         * Interval periodName.
         * @member {string} periodName
         * @memberof ProtobufMarkets.Interval
         * @instance
         */
        Interval.prototype.periodName = "";
        /**
         * Interval period.
         * @member {number} period
         * @memberof ProtobufMarkets.Interval
         * @instance
         */
        Interval.prototype.period = 0;
        /**
         * Creates a new Interval instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.Interval
         * @static
         * @param {ProtobufMarkets.IInterval=} [properties] Properties to set
         * @returns {ProtobufMarkets.Interval} Interval instance
         */
        Interval.create = function create(properties) {
            return new Interval(properties);
        };
        /**
         * Encodes the specified Interval message. Does not implicitly {@link ProtobufMarkets.Interval.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.Interval
         * @static
         * @param {ProtobufMarkets.IInterval} message Interval message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Interval.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.closetime != null && Object.hasOwnProperty.call(message, "closetime"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.closetime);
            if (message.ohlc != null && Object.hasOwnProperty.call(message, "ohlc"))
                $root.ProtobufMarkets.Interval.OHLC.encode(message.ohlc, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.period != null && Object.hasOwnProperty.call(message, "period"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.period);
            if (message.volumeBaseStr != null && Object.hasOwnProperty.call(message, "volumeBaseStr"))
                writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.volumeBaseStr);
            if (message.volumeQuoteStr != null && Object.hasOwnProperty.call(message, "volumeQuoteStr"))
                writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.volumeQuoteStr);
            if (message.periodName != null && Object.hasOwnProperty.call(message, "periodName"))
                writer.uint32(/* id 9, wireType 2 =*/ 74).string(message.periodName);
            return writer;
        };
        /**
         * Encodes the specified Interval message, length delimited. Does not implicitly {@link ProtobufMarkets.Interval.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.Interval
         * @static
         * @param {ProtobufMarkets.IInterval} message Interval message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Interval.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an Interval message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.Interval
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.Interval} Interval
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Interval.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.Interval();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.closetime = reader.int64();
                        break;
                    case 2:
                        message.ohlc = $root.ProtobufMarkets.Interval.OHLC.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.volumeBaseStr = reader.string();
                        break;
                    case 7:
                        message.volumeQuoteStr = reader.string();
                        break;
                    case 9:
                        message.periodName = reader.string();
                        break;
                    case 4:
                        message.period = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an Interval message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.Interval
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.Interval} Interval
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Interval.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an Interval message.
         * @function verify
         * @memberof ProtobufMarkets.Interval
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Interval.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.closetime != null && message.hasOwnProperty("closetime"))
                if (!$util.isInteger(message.closetime) && !(message.closetime && $util.isInteger(message.closetime.low) && $util.isInteger(message.closetime.high)))
                    return "closetime: integer|Long expected";
            if (message.ohlc != null && message.hasOwnProperty("ohlc")) {
                var error = $root.ProtobufMarkets.Interval.OHLC.verify(message.ohlc);
                if (error)
                    return "ohlc." + error;
            }
            if (message.volumeBaseStr != null && message.hasOwnProperty("volumeBaseStr"))
                if (!$util.isString(message.volumeBaseStr))
                    return "volumeBaseStr: string expected";
            if (message.volumeQuoteStr != null && message.hasOwnProperty("volumeQuoteStr"))
                if (!$util.isString(message.volumeQuoteStr))
                    return "volumeQuoteStr: string expected";
            if (message.periodName != null && message.hasOwnProperty("periodName"))
                if (!$util.isString(message.periodName))
                    return "periodName: string expected";
            if (message.period != null && message.hasOwnProperty("period"))
                if (!$util.isInteger(message.period))
                    return "period: integer expected";
            return null;
        };
        /**
         * Creates an Interval message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.Interval
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.Interval} Interval
         */
        Interval.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.Interval)
                return object;
            var message = new $root.ProtobufMarkets.Interval();
            if (object.closetime != null)
                if ($util.Long)
                    (message.closetime = $util.Long.fromValue(object.closetime)).unsigned = false;
                else if (typeof object.closetime === "string")
                    message.closetime = parseInt(object.closetime, 10);
                else if (typeof object.closetime === "number")
                    message.closetime = object.closetime;
                else if (typeof object.closetime === "object")
                    message.closetime = new $util.LongBits(object.closetime.low >>> 0, object.closetime.high >>> 0).toNumber();
            if (object.ohlc != null) {
                if (typeof object.ohlc !== "object")
                    throw TypeError(".ProtobufMarkets.Interval.ohlc: object expected");
                message.ohlc = $root.ProtobufMarkets.Interval.OHLC.fromObject(object.ohlc);
            }
            if (object.volumeBaseStr != null)
                message.volumeBaseStr = String(object.volumeBaseStr);
            if (object.volumeQuoteStr != null)
                message.volumeQuoteStr = String(object.volumeQuoteStr);
            if (object.periodName != null)
                message.periodName = String(object.periodName);
            if (object.period != null)
                message.period = object.period | 0;
            return message;
        };
        /**
         * Creates a plain object from an Interval message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.Interval
         * @static
         * @param {ProtobufMarkets.Interval} message Interval
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Interval.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.closetime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.closetime = options.longs === String ? "0" : 0;
                object.ohlc = null;
                object.period = 0;
                object.volumeBaseStr = "";
                object.volumeQuoteStr = "";
                object.periodName = "";
            }
            if (message.closetime != null && message.hasOwnProperty("closetime"))
                if (typeof message.closetime === "number")
                    object.closetime = options.longs === String ? String(message.closetime) : message.closetime;
                else
                    object.closetime = options.longs === String ? $util.Long.prototype.toString.call(message.closetime) : options.longs === Number ? new $util.LongBits(message.closetime.low >>> 0, message.closetime.high >>> 0).toNumber() : message.closetime;
            if (message.ohlc != null && message.hasOwnProperty("ohlc"))
                object.ohlc = $root.ProtobufMarkets.Interval.OHLC.toObject(message.ohlc, options);
            if (message.period != null && message.hasOwnProperty("period"))
                object.period = message.period;
            if (message.volumeBaseStr != null && message.hasOwnProperty("volumeBaseStr"))
                object.volumeBaseStr = message.volumeBaseStr;
            if (message.volumeQuoteStr != null && message.hasOwnProperty("volumeQuoteStr"))
                object.volumeQuoteStr = message.volumeQuoteStr;
            if (message.periodName != null && message.hasOwnProperty("periodName"))
                object.periodName = message.periodName;
            return object;
        };
        /**
         * Converts this Interval to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.Interval
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Interval.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        Interval.OHLC = (function () {
            /**
             * Properties of a OHLC.
             * @memberof ProtobufMarkets.Interval
             * @interface IOHLC
             * @property {string|null} [openStr] OHLC openStr
             * @property {string|null} [highStr] OHLC highStr
             * @property {string|null} [lowStr] OHLC lowStr
             * @property {string|null} [closeStr] OHLC closeStr
             */
            /**
             * Constructs a new OHLC.
             * @memberof ProtobufMarkets.Interval
             * @classdesc Represents a OHLC.
             * @implements IOHLC
             * @constructor
             * @param {ProtobufMarkets.Interval.IOHLC=} [properties] Properties to set
             */
            function OHLC(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * OHLC openStr.
             * @member {string} openStr
             * @memberof ProtobufMarkets.Interval.OHLC
             * @instance
             */
            OHLC.prototype.openStr = "";
            /**
             * OHLC highStr.
             * @member {string} highStr
             * @memberof ProtobufMarkets.Interval.OHLC
             * @instance
             */
            OHLC.prototype.highStr = "";
            /**
             * OHLC lowStr.
             * @member {string} lowStr
             * @memberof ProtobufMarkets.Interval.OHLC
             * @instance
             */
            OHLC.prototype.lowStr = "";
            /**
             * OHLC closeStr.
             * @member {string} closeStr
             * @memberof ProtobufMarkets.Interval.OHLC
             * @instance
             */
            OHLC.prototype.closeStr = "";
            /**
             * Creates a new OHLC instance using the specified properties.
             * @function create
             * @memberof ProtobufMarkets.Interval.OHLC
             * @static
             * @param {ProtobufMarkets.Interval.IOHLC=} [properties] Properties to set
             * @returns {ProtobufMarkets.Interval.OHLC} OHLC instance
             */
            OHLC.create = function create(properties) {
                return new OHLC(properties);
            };
            /**
             * Encodes the specified OHLC message. Does not implicitly {@link ProtobufMarkets.Interval.OHLC.verify|verify} messages.
             * @function encode
             * @memberof ProtobufMarkets.Interval.OHLC
             * @static
             * @param {ProtobufMarkets.Interval.IOHLC} message OHLC message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OHLC.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.openStr != null && Object.hasOwnProperty.call(message, "openStr"))
                    writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.openStr);
                if (message.highStr != null && Object.hasOwnProperty.call(message, "highStr"))
                    writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.highStr);
                if (message.lowStr != null && Object.hasOwnProperty.call(message, "lowStr"))
                    writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.lowStr);
                if (message.closeStr != null && Object.hasOwnProperty.call(message, "closeStr"))
                    writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.closeStr);
                return writer;
            };
            /**
             * Encodes the specified OHLC message, length delimited. Does not implicitly {@link ProtobufMarkets.Interval.OHLC.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ProtobufMarkets.Interval.OHLC
             * @static
             * @param {ProtobufMarkets.Interval.IOHLC} message OHLC message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OHLC.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a OHLC message from the specified reader or buffer.
             * @function decode
             * @memberof ProtobufMarkets.Interval.OHLC
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ProtobufMarkets.Interval.OHLC} OHLC
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OHLC.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.Interval.OHLC();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 5:
                            message.openStr = reader.string();
                            break;
                        case 6:
                            message.highStr = reader.string();
                            break;
                        case 7:
                            message.lowStr = reader.string();
                            break;
                        case 8:
                            message.closeStr = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a OHLC message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ProtobufMarkets.Interval.OHLC
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ProtobufMarkets.Interval.OHLC} OHLC
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OHLC.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a OHLC message.
             * @function verify
             * @memberof ProtobufMarkets.Interval.OHLC
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OHLC.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.openStr != null && message.hasOwnProperty("openStr"))
                    if (!$util.isString(message.openStr))
                        return "openStr: string expected";
                if (message.highStr != null && message.hasOwnProperty("highStr"))
                    if (!$util.isString(message.highStr))
                        return "highStr: string expected";
                if (message.lowStr != null && message.hasOwnProperty("lowStr"))
                    if (!$util.isString(message.lowStr))
                        return "lowStr: string expected";
                if (message.closeStr != null && message.hasOwnProperty("closeStr"))
                    if (!$util.isString(message.closeStr))
                        return "closeStr: string expected";
                return null;
            };
            /**
             * Creates a OHLC message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ProtobufMarkets.Interval.OHLC
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ProtobufMarkets.Interval.OHLC} OHLC
             */
            OHLC.fromObject = function fromObject(object) {
                if (object instanceof $root.ProtobufMarkets.Interval.OHLC)
                    return object;
                var message = new $root.ProtobufMarkets.Interval.OHLC();
                if (object.openStr != null)
                    message.openStr = String(object.openStr);
                if (object.highStr != null)
                    message.highStr = String(object.highStr);
                if (object.lowStr != null)
                    message.lowStr = String(object.lowStr);
                if (object.closeStr != null)
                    message.closeStr = String(object.closeStr);
                return message;
            };
            /**
             * Creates a plain object from a OHLC message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ProtobufMarkets.Interval.OHLC
             * @static
             * @param {ProtobufMarkets.Interval.OHLC} message OHLC
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OHLC.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.openStr = "";
                    object.highStr = "";
                    object.lowStr = "";
                    object.closeStr = "";
                }
                if (message.openStr != null && message.hasOwnProperty("openStr"))
                    object.openStr = message.openStr;
                if (message.highStr != null && message.hasOwnProperty("highStr"))
                    object.highStr = message.highStr;
                if (message.lowStr != null && message.hasOwnProperty("lowStr"))
                    object.lowStr = message.lowStr;
                if (message.closeStr != null && message.hasOwnProperty("closeStr"))
                    object.closeStr = message.closeStr;
                return object;
            };
            /**
             * Converts this OHLC to JSON.
             * @function toJSON
             * @memberof ProtobufMarkets.Interval.OHLC
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OHLC.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return OHLC;
        })();
        return Interval;
    })();
    ProtobufMarkets.IntervalsUpdate = (function () {
        /**
         * Properties of an IntervalsUpdate.
         * @memberof ProtobufMarkets
         * @interface IIntervalsUpdate
         * @property {Array.<ProtobufMarkets.IInterval>|null} [intervals] IntervalsUpdate intervals
         */
        /**
         * Constructs a new IntervalsUpdate.
         * @memberof ProtobufMarkets
         * @classdesc Represents an IntervalsUpdate.
         * @implements IIntervalsUpdate
         * @constructor
         * @param {ProtobufMarkets.IIntervalsUpdate=} [properties] Properties to set
         */
        function IntervalsUpdate(properties) {
            this.intervals = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * IntervalsUpdate intervals.
         * @member {Array.<ProtobufMarkets.IInterval>} intervals
         * @memberof ProtobufMarkets.IntervalsUpdate
         * @instance
         */
        IntervalsUpdate.prototype.intervals = $util.emptyArray;
        /**
         * Creates a new IntervalsUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.IntervalsUpdate
         * @static
         * @param {ProtobufMarkets.IIntervalsUpdate=} [properties] Properties to set
         * @returns {ProtobufMarkets.IntervalsUpdate} IntervalsUpdate instance
         */
        IntervalsUpdate.create = function create(properties) {
            return new IntervalsUpdate(properties);
        };
        /**
         * Encodes the specified IntervalsUpdate message. Does not implicitly {@link ProtobufMarkets.IntervalsUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.IntervalsUpdate
         * @static
         * @param {ProtobufMarkets.IIntervalsUpdate} message IntervalsUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IntervalsUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.intervals != null && message.intervals.length)
                for (var i = 0; i < message.intervals.length; ++i)
                    $root.ProtobufMarkets.Interval.encode(message.intervals[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified IntervalsUpdate message, length delimited. Does not implicitly {@link ProtobufMarkets.IntervalsUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.IntervalsUpdate
         * @static
         * @param {ProtobufMarkets.IIntervalsUpdate} message IntervalsUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IntervalsUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an IntervalsUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.IntervalsUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.IntervalsUpdate} IntervalsUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IntervalsUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.IntervalsUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.intervals && message.intervals.length))
                            message.intervals = [];
                        message.intervals.push($root.ProtobufMarkets.Interval.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an IntervalsUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.IntervalsUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.IntervalsUpdate} IntervalsUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IntervalsUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an IntervalsUpdate message.
         * @function verify
         * @memberof ProtobufMarkets.IntervalsUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IntervalsUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.intervals != null && message.hasOwnProperty("intervals")) {
                if (!Array.isArray(message.intervals))
                    return "intervals: array expected";
                for (var i = 0; i < message.intervals.length; ++i) {
                    var error = $root.ProtobufMarkets.Interval.verify(message.intervals[i]);
                    if (error)
                        return "intervals." + error;
                }
            }
            return null;
        };
        /**
         * Creates an IntervalsUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.IntervalsUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.IntervalsUpdate} IntervalsUpdate
         */
        IntervalsUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.IntervalsUpdate)
                return object;
            var message = new $root.ProtobufMarkets.IntervalsUpdate();
            if (object.intervals) {
                if (!Array.isArray(object.intervals))
                    throw TypeError(".ProtobufMarkets.IntervalsUpdate.intervals: array expected");
                message.intervals = [];
                for (var i = 0; i < object.intervals.length; ++i) {
                    if (typeof object.intervals[i] !== "object")
                        throw TypeError(".ProtobufMarkets.IntervalsUpdate.intervals: object expected");
                    message.intervals[i] = $root.ProtobufMarkets.Interval.fromObject(object.intervals[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from an IntervalsUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.IntervalsUpdate
         * @static
         * @param {ProtobufMarkets.IntervalsUpdate} message IntervalsUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IntervalsUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.intervals = [];
            if (message.intervals && message.intervals.length) {
                object.intervals = [];
                for (var j = 0; j < message.intervals.length; ++j)
                    object.intervals[j] = $root.ProtobufMarkets.Interval.toObject(message.intervals[j], options);
            }
            return object;
        };
        /**
         * Converts this IntervalsUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.IntervalsUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IntervalsUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return IntervalsUpdate;
    })();
    ProtobufMarkets.SummaryUpdate = (function () {
        /**
         * Properties of a SummaryUpdate.
         * @memberof ProtobufMarkets
         * @interface ISummaryUpdate
         * @property {string|null} [lastStr] SummaryUpdate lastStr
         * @property {string|null} [highStr] SummaryUpdate highStr
         * @property {string|null} [lowStr] SummaryUpdate lowStr
         * @property {string|null} [volumeBaseStr] SummaryUpdate volumeBaseStr
         * @property {string|null} [volumeQuoteStr] SummaryUpdate volumeQuoteStr
         * @property {string|null} [changeAbsoluteStr] SummaryUpdate changeAbsoluteStr
         * @property {string|null} [changePercentStr] SummaryUpdate changePercentStr
         * @property {number|null} [numTrades] SummaryUpdate numTrades
         */
        /**
         * Constructs a new SummaryUpdate.
         * @memberof ProtobufMarkets
         * @classdesc Represents a SummaryUpdate.
         * @implements ISummaryUpdate
         * @constructor
         * @param {ProtobufMarkets.ISummaryUpdate=} [properties] Properties to set
         */
        function SummaryUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * SummaryUpdate lastStr.
         * @member {string} lastStr
         * @memberof ProtobufMarkets.SummaryUpdate
         * @instance
         */
        SummaryUpdate.prototype.lastStr = "";
        /**
         * SummaryUpdate highStr.
         * @member {string} highStr
         * @memberof ProtobufMarkets.SummaryUpdate
         * @instance
         */
        SummaryUpdate.prototype.highStr = "";
        /**
         * SummaryUpdate lowStr.
         * @member {string} lowStr
         * @memberof ProtobufMarkets.SummaryUpdate
         * @instance
         */
        SummaryUpdate.prototype.lowStr = "";
        /**
         * SummaryUpdate volumeBaseStr.
         * @member {string} volumeBaseStr
         * @memberof ProtobufMarkets.SummaryUpdate
         * @instance
         */
        SummaryUpdate.prototype.volumeBaseStr = "";
        /**
         * SummaryUpdate volumeQuoteStr.
         * @member {string} volumeQuoteStr
         * @memberof ProtobufMarkets.SummaryUpdate
         * @instance
         */
        SummaryUpdate.prototype.volumeQuoteStr = "";
        /**
         * SummaryUpdate changeAbsoluteStr.
         * @member {string} changeAbsoluteStr
         * @memberof ProtobufMarkets.SummaryUpdate
         * @instance
         */
        SummaryUpdate.prototype.changeAbsoluteStr = "";
        /**
         * SummaryUpdate changePercentStr.
         * @member {string} changePercentStr
         * @memberof ProtobufMarkets.SummaryUpdate
         * @instance
         */
        SummaryUpdate.prototype.changePercentStr = "";
        /**
         * SummaryUpdate numTrades.
         * @member {number} numTrades
         * @memberof ProtobufMarkets.SummaryUpdate
         * @instance
         */
        SummaryUpdate.prototype.numTrades = 0;
        /**
         * Creates a new SummaryUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.SummaryUpdate
         * @static
         * @param {ProtobufMarkets.ISummaryUpdate=} [properties] Properties to set
         * @returns {ProtobufMarkets.SummaryUpdate} SummaryUpdate instance
         */
        SummaryUpdate.create = function create(properties) {
            return new SummaryUpdate(properties);
        };
        /**
         * Encodes the specified SummaryUpdate message. Does not implicitly {@link ProtobufMarkets.SummaryUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.SummaryUpdate
         * @static
         * @param {ProtobufMarkets.ISummaryUpdate} message SummaryUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SummaryUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.numTrades != null && Object.hasOwnProperty.call(message, "numTrades"))
                writer.uint32(/* id 8, wireType 0 =*/ 64).int32(message.numTrades);
            if (message.lastStr != null && Object.hasOwnProperty.call(message, "lastStr"))
                writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.lastStr);
            if (message.highStr != null && Object.hasOwnProperty.call(message, "highStr"))
                writer.uint32(/* id 11, wireType 2 =*/ 90).string(message.highStr);
            if (message.lowStr != null && Object.hasOwnProperty.call(message, "lowStr"))
                writer.uint32(/* id 12, wireType 2 =*/ 98).string(message.lowStr);
            if (message.volumeBaseStr != null && Object.hasOwnProperty.call(message, "volumeBaseStr"))
                writer.uint32(/* id 13, wireType 2 =*/ 106).string(message.volumeBaseStr);
            if (message.volumeQuoteStr != null && Object.hasOwnProperty.call(message, "volumeQuoteStr"))
                writer.uint32(/* id 14, wireType 2 =*/ 114).string(message.volumeQuoteStr);
            if (message.changeAbsoluteStr != null && Object.hasOwnProperty.call(message, "changeAbsoluteStr"))
                writer.uint32(/* id 15, wireType 2 =*/ 122).string(message.changeAbsoluteStr);
            if (message.changePercentStr != null && Object.hasOwnProperty.call(message, "changePercentStr"))
                writer.uint32(/* id 16, wireType 2 =*/ 130).string(message.changePercentStr);
            return writer;
        };
        /**
         * Encodes the specified SummaryUpdate message, length delimited. Does not implicitly {@link ProtobufMarkets.SummaryUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.SummaryUpdate
         * @static
         * @param {ProtobufMarkets.ISummaryUpdate} message SummaryUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SummaryUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a SummaryUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.SummaryUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.SummaryUpdate} SummaryUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SummaryUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.SummaryUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 10:
                        message.lastStr = reader.string();
                        break;
                    case 11:
                        message.highStr = reader.string();
                        break;
                    case 12:
                        message.lowStr = reader.string();
                        break;
                    case 13:
                        message.volumeBaseStr = reader.string();
                        break;
                    case 14:
                        message.volumeQuoteStr = reader.string();
                        break;
                    case 15:
                        message.changeAbsoluteStr = reader.string();
                        break;
                    case 16:
                        message.changePercentStr = reader.string();
                        break;
                    case 8:
                        message.numTrades = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a SummaryUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.SummaryUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.SummaryUpdate} SummaryUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SummaryUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a SummaryUpdate message.
         * @function verify
         * @memberof ProtobufMarkets.SummaryUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SummaryUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lastStr != null && message.hasOwnProperty("lastStr"))
                if (!$util.isString(message.lastStr))
                    return "lastStr: string expected";
            if (message.highStr != null && message.hasOwnProperty("highStr"))
                if (!$util.isString(message.highStr))
                    return "highStr: string expected";
            if (message.lowStr != null && message.hasOwnProperty("lowStr"))
                if (!$util.isString(message.lowStr))
                    return "lowStr: string expected";
            if (message.volumeBaseStr != null && message.hasOwnProperty("volumeBaseStr"))
                if (!$util.isString(message.volumeBaseStr))
                    return "volumeBaseStr: string expected";
            if (message.volumeQuoteStr != null && message.hasOwnProperty("volumeQuoteStr"))
                if (!$util.isString(message.volumeQuoteStr))
                    return "volumeQuoteStr: string expected";
            if (message.changeAbsoluteStr != null && message.hasOwnProperty("changeAbsoluteStr"))
                if (!$util.isString(message.changeAbsoluteStr))
                    return "changeAbsoluteStr: string expected";
            if (message.changePercentStr != null && message.hasOwnProperty("changePercentStr"))
                if (!$util.isString(message.changePercentStr))
                    return "changePercentStr: string expected";
            if (message.numTrades != null && message.hasOwnProperty("numTrades"))
                if (!$util.isInteger(message.numTrades))
                    return "numTrades: integer expected";
            return null;
        };
        /**
         * Creates a SummaryUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.SummaryUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.SummaryUpdate} SummaryUpdate
         */
        SummaryUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.SummaryUpdate)
                return object;
            var message = new $root.ProtobufMarkets.SummaryUpdate();
            if (object.lastStr != null)
                message.lastStr = String(object.lastStr);
            if (object.highStr != null)
                message.highStr = String(object.highStr);
            if (object.lowStr != null)
                message.lowStr = String(object.lowStr);
            if (object.volumeBaseStr != null)
                message.volumeBaseStr = String(object.volumeBaseStr);
            if (object.volumeQuoteStr != null)
                message.volumeQuoteStr = String(object.volumeQuoteStr);
            if (object.changeAbsoluteStr != null)
                message.changeAbsoluteStr = String(object.changeAbsoluteStr);
            if (object.changePercentStr != null)
                message.changePercentStr = String(object.changePercentStr);
            if (object.numTrades != null)
                message.numTrades = object.numTrades | 0;
            return message;
        };
        /**
         * Creates a plain object from a SummaryUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.SummaryUpdate
         * @static
         * @param {ProtobufMarkets.SummaryUpdate} message SummaryUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SummaryUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.numTrades = 0;
                object.lastStr = "";
                object.highStr = "";
                object.lowStr = "";
                object.volumeBaseStr = "";
                object.volumeQuoteStr = "";
                object.changeAbsoluteStr = "";
                object.changePercentStr = "";
            }
            if (message.numTrades != null && message.hasOwnProperty("numTrades"))
                object.numTrades = message.numTrades;
            if (message.lastStr != null && message.hasOwnProperty("lastStr"))
                object.lastStr = message.lastStr;
            if (message.highStr != null && message.hasOwnProperty("highStr"))
                object.highStr = message.highStr;
            if (message.lowStr != null && message.hasOwnProperty("lowStr"))
                object.lowStr = message.lowStr;
            if (message.volumeBaseStr != null && message.hasOwnProperty("volumeBaseStr"))
                object.volumeBaseStr = message.volumeBaseStr;
            if (message.volumeQuoteStr != null && message.hasOwnProperty("volumeQuoteStr"))
                object.volumeQuoteStr = message.volumeQuoteStr;
            if (message.changeAbsoluteStr != null && message.hasOwnProperty("changeAbsoluteStr"))
                object.changeAbsoluteStr = message.changeAbsoluteStr;
            if (message.changePercentStr != null && message.hasOwnProperty("changePercentStr"))
                object.changePercentStr = message.changePercentStr;
            return object;
        };
        /**
         * Converts this SummaryUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.SummaryUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SummaryUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return SummaryUpdate;
    })();
    ProtobufMarkets.SparklineUpdate = (function () {
        /**
         * Properties of a SparklineUpdate.
         * @memberof ProtobufMarkets
         * @interface ISparklineUpdate
         * @property {number|Long|null} [time] SparklineUpdate time
         * @property {string|null} [priceStr] SparklineUpdate priceStr
         */
        /**
         * Constructs a new SparklineUpdate.
         * @memberof ProtobufMarkets
         * @classdesc Represents a SparklineUpdate.
         * @implements ISparklineUpdate
         * @constructor
         * @param {ProtobufMarkets.ISparklineUpdate=} [properties] Properties to set
         */
        function SparklineUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * SparklineUpdate time.
         * @member {number|Long} time
         * @memberof ProtobufMarkets.SparklineUpdate
         * @instance
         */
        SparklineUpdate.prototype.time = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * SparklineUpdate priceStr.
         * @member {string} priceStr
         * @memberof ProtobufMarkets.SparklineUpdate
         * @instance
         */
        SparklineUpdate.prototype.priceStr = "";
        /**
         * Creates a new SparklineUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.SparklineUpdate
         * @static
         * @param {ProtobufMarkets.ISparklineUpdate=} [properties] Properties to set
         * @returns {ProtobufMarkets.SparklineUpdate} SparklineUpdate instance
         */
        SparklineUpdate.create = function create(properties) {
            return new SparklineUpdate(properties);
        };
        /**
         * Encodes the specified SparklineUpdate message. Does not implicitly {@link ProtobufMarkets.SparklineUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.SparklineUpdate
         * @static
         * @param {ProtobufMarkets.ISparklineUpdate} message SparklineUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SparklineUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.time);
            if (message.priceStr != null && Object.hasOwnProperty.call(message, "priceStr"))
                writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.priceStr);
            return writer;
        };
        /**
         * Encodes the specified SparklineUpdate message, length delimited. Does not implicitly {@link ProtobufMarkets.SparklineUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.SparklineUpdate
         * @static
         * @param {ProtobufMarkets.ISparklineUpdate} message SparklineUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SparklineUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a SparklineUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.SparklineUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.SparklineUpdate} SparklineUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SparklineUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.SparklineUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 2:
                        message.time = reader.int64();
                        break;
                    case 4:
                        message.priceStr = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a SparklineUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.SparklineUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.SparklineUpdate} SparklineUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SparklineUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a SparklineUpdate message.
         * @function verify
         * @memberof ProtobufMarkets.SparklineUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SparklineUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            if (message.priceStr != null && message.hasOwnProperty("priceStr"))
                if (!$util.isString(message.priceStr))
                    return "priceStr: string expected";
            return null;
        };
        /**
         * Creates a SparklineUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.SparklineUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.SparklineUpdate} SparklineUpdate
         */
        SparklineUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.SparklineUpdate)
                return object;
            var message = new $root.ProtobufMarkets.SparklineUpdate();
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            if (object.priceStr != null)
                message.priceStr = String(object.priceStr);
            return message;
        };
        /**
         * Creates a plain object from a SparklineUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.SparklineUpdate
         * @static
         * @param {ProtobufMarkets.SparklineUpdate} message SparklineUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SparklineUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.time = options.longs === String ? "0" : 0;
                object.priceStr = "";
            }
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            if (message.priceStr != null && message.hasOwnProperty("priceStr"))
                object.priceStr = message.priceStr;
            return object;
        };
        /**
         * Converts this SparklineUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.SparklineUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SparklineUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return SparklineUpdate;
    })();
    ProtobufMarkets.PairUpdateMessage = (function () {
        /**
         * Properties of a PairUpdateMessage.
         * @memberof ProtobufMarkets
         * @interface IPairUpdateMessage
         * @property {number|Long|null} [pair] PairUpdateMessage pair
         * @property {ProtobufMarkets.IPairVwapUpdate|null} [vwapUpdate] PairUpdateMessage vwapUpdate
         * @property {ProtobufMarkets.IPairPerformanceUpdate|null} [performanceUpdate] PairUpdateMessage performanceUpdate
         * @property {ProtobufMarkets.IPairTrendlineUpdate|null} [trendlineUpdate] PairUpdateMessage trendlineUpdate
         */
        /**
         * Constructs a new PairUpdateMessage.
         * @memberof ProtobufMarkets
         * @classdesc Represents a PairUpdateMessage.
         * @implements IPairUpdateMessage
         * @constructor
         * @param {ProtobufMarkets.IPairUpdateMessage=} [properties] Properties to set
         */
        function PairUpdateMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PairUpdateMessage pair.
         * @member {number|Long} pair
         * @memberof ProtobufMarkets.PairUpdateMessage
         * @instance
         */
        PairUpdateMessage.prototype.pair = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * PairUpdateMessage vwapUpdate.
         * @member {ProtobufMarkets.IPairVwapUpdate|null|undefined} vwapUpdate
         * @memberof ProtobufMarkets.PairUpdateMessage
         * @instance
         */
        PairUpdateMessage.prototype.vwapUpdate = null;
        /**
         * PairUpdateMessage performanceUpdate.
         * @member {ProtobufMarkets.IPairPerformanceUpdate|null|undefined} performanceUpdate
         * @memberof ProtobufMarkets.PairUpdateMessage
         * @instance
         */
        PairUpdateMessage.prototype.performanceUpdate = null;
        /**
         * PairUpdateMessage trendlineUpdate.
         * @member {ProtobufMarkets.IPairTrendlineUpdate|null|undefined} trendlineUpdate
         * @memberof ProtobufMarkets.PairUpdateMessage
         * @instance
         */
        PairUpdateMessage.prototype.trendlineUpdate = null;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * PairUpdateMessage Update.
         * @member {"vwapUpdate"|"performanceUpdate"|"trendlineUpdate"|undefined} Update
         * @memberof ProtobufMarkets.PairUpdateMessage
         * @instance
         */
        Object.defineProperty(PairUpdateMessage.prototype, "Update", {
            get: $util.oneOfGetter($oneOfFields = ["vwapUpdate", "performanceUpdate", "trendlineUpdate"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new PairUpdateMessage instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.PairUpdateMessage
         * @static
         * @param {ProtobufMarkets.IPairUpdateMessage=} [properties] Properties to set
         * @returns {ProtobufMarkets.PairUpdateMessage} PairUpdateMessage instance
         */
        PairUpdateMessage.create = function create(properties) {
            return new PairUpdateMessage(properties);
        };
        /**
         * Encodes the specified PairUpdateMessage message. Does not implicitly {@link ProtobufMarkets.PairUpdateMessage.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.PairUpdateMessage
         * @static
         * @param {ProtobufMarkets.IPairUpdateMessage} message PairUpdateMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PairUpdateMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pair != null && Object.hasOwnProperty.call(message, "pair"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.pair);
            if (message.vwapUpdate != null && Object.hasOwnProperty.call(message, "vwapUpdate"))
                $root.ProtobufMarkets.PairVwapUpdate.encode(message.vwapUpdate, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.performanceUpdate != null && Object.hasOwnProperty.call(message, "performanceUpdate"))
                $root.ProtobufMarkets.PairPerformanceUpdate.encode(message.performanceUpdate, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.trendlineUpdate != null && Object.hasOwnProperty.call(message, "trendlineUpdate"))
                $root.ProtobufMarkets.PairTrendlineUpdate.encode(message.trendlineUpdate, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified PairUpdateMessage message, length delimited. Does not implicitly {@link ProtobufMarkets.PairUpdateMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.PairUpdateMessage
         * @static
         * @param {ProtobufMarkets.IPairUpdateMessage} message PairUpdateMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PairUpdateMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PairUpdateMessage message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.PairUpdateMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.PairUpdateMessage} PairUpdateMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PairUpdateMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.PairUpdateMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.pair = reader.uint64();
                        break;
                    case 2:
                        message.vwapUpdate = $root.ProtobufMarkets.PairVwapUpdate.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.performanceUpdate = $root.ProtobufMarkets.PairPerformanceUpdate.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.trendlineUpdate = $root.ProtobufMarkets.PairTrendlineUpdate.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PairUpdateMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.PairUpdateMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.PairUpdateMessage} PairUpdateMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PairUpdateMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PairUpdateMessage message.
         * @function verify
         * @memberof ProtobufMarkets.PairUpdateMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PairUpdateMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.pair != null && message.hasOwnProperty("pair"))
                if (!$util.isInteger(message.pair) && !(message.pair && $util.isInteger(message.pair.low) && $util.isInteger(message.pair.high)))
                    return "pair: integer|Long expected";
            if (message.vwapUpdate != null && message.hasOwnProperty("vwapUpdate")) {
                properties.Update = 1;
                {
                    var error = $root.ProtobufMarkets.PairVwapUpdate.verify(message.vwapUpdate);
                    if (error)
                        return "vwapUpdate." + error;
                }
            }
            if (message.performanceUpdate != null && message.hasOwnProperty("performanceUpdate")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufMarkets.PairPerformanceUpdate.verify(message.performanceUpdate);
                    if (error)
                        return "performanceUpdate." + error;
                }
            }
            if (message.trendlineUpdate != null && message.hasOwnProperty("trendlineUpdate")) {
                if (properties.Update === 1)
                    return "Update: multiple values";
                properties.Update = 1;
                {
                    var error = $root.ProtobufMarkets.PairTrendlineUpdate.verify(message.trendlineUpdate);
                    if (error)
                        return "trendlineUpdate." + error;
                }
            }
            return null;
        };
        /**
         * Creates a PairUpdateMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.PairUpdateMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.PairUpdateMessage} PairUpdateMessage
         */
        PairUpdateMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.PairUpdateMessage)
                return object;
            var message = new $root.ProtobufMarkets.PairUpdateMessage();
            if (object.pair != null)
                if ($util.Long)
                    (message.pair = $util.Long.fromValue(object.pair)).unsigned = true;
                else if (typeof object.pair === "string")
                    message.pair = parseInt(object.pair, 10);
                else if (typeof object.pair === "number")
                    message.pair = object.pair;
                else if (typeof object.pair === "object")
                    message.pair = new $util.LongBits(object.pair.low >>> 0, object.pair.high >>> 0).toNumber(true);
            if (object.vwapUpdate != null) {
                if (typeof object.vwapUpdate !== "object")
                    throw TypeError(".ProtobufMarkets.PairUpdateMessage.vwapUpdate: object expected");
                message.vwapUpdate = $root.ProtobufMarkets.PairVwapUpdate.fromObject(object.vwapUpdate);
            }
            if (object.performanceUpdate != null) {
                if (typeof object.performanceUpdate !== "object")
                    throw TypeError(".ProtobufMarkets.PairUpdateMessage.performanceUpdate: object expected");
                message.performanceUpdate = $root.ProtobufMarkets.PairPerformanceUpdate.fromObject(object.performanceUpdate);
            }
            if (object.trendlineUpdate != null) {
                if (typeof object.trendlineUpdate !== "object")
                    throw TypeError(".ProtobufMarkets.PairUpdateMessage.trendlineUpdate: object expected");
                message.trendlineUpdate = $root.ProtobufMarkets.PairTrendlineUpdate.fromObject(object.trendlineUpdate);
            }
            return message;
        };
        /**
         * Creates a plain object from a PairUpdateMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.PairUpdateMessage
         * @static
         * @param {ProtobufMarkets.PairUpdateMessage} message PairUpdateMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PairUpdateMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.pair = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.pair = options.longs === String ? "0" : 0;
            if (message.pair != null && message.hasOwnProperty("pair"))
                if (typeof message.pair === "number")
                    object.pair = options.longs === String ? String(message.pair) : message.pair;
                else
                    object.pair = options.longs === String ? $util.Long.prototype.toString.call(message.pair) : options.longs === Number ? new $util.LongBits(message.pair.low >>> 0, message.pair.high >>> 0).toNumber(true) : message.pair;
            if (message.vwapUpdate != null && message.hasOwnProperty("vwapUpdate")) {
                object.vwapUpdate = $root.ProtobufMarkets.PairVwapUpdate.toObject(message.vwapUpdate, options);
                if (options.oneofs)
                    object.Update = "vwapUpdate";
            }
            if (message.performanceUpdate != null && message.hasOwnProperty("performanceUpdate")) {
                object.performanceUpdate = $root.ProtobufMarkets.PairPerformanceUpdate.toObject(message.performanceUpdate, options);
                if (options.oneofs)
                    object.Update = "performanceUpdate";
            }
            if (message.trendlineUpdate != null && message.hasOwnProperty("trendlineUpdate")) {
                object.trendlineUpdate = $root.ProtobufMarkets.PairTrendlineUpdate.toObject(message.trendlineUpdate, options);
                if (options.oneofs)
                    object.Update = "trendlineUpdate";
            }
            return object;
        };
        /**
         * Converts this PairUpdateMessage to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.PairUpdateMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PairUpdateMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PairUpdateMessage;
    })();
    ProtobufMarkets.PairVwapUpdate = (function () {
        /**
         * Properties of a PairVwapUpdate.
         * @memberof ProtobufMarkets
         * @interface IPairVwapUpdate
         * @property {number|null} [vwap] PairVwapUpdate vwap
         * @property {number|Long|null} [timestamp] PairVwapUpdate timestamp
         * @property {number|Long|null} [timestampNano] PairVwapUpdate timestampNano
         */
        /**
         * Constructs a new PairVwapUpdate.
         * @memberof ProtobufMarkets
         * @classdesc Represents a PairVwapUpdate.
         * @implements IPairVwapUpdate
         * @constructor
         * @param {ProtobufMarkets.IPairVwapUpdate=} [properties] Properties to set
         */
        function PairVwapUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PairVwapUpdate vwap.
         * @member {number} vwap
         * @memberof ProtobufMarkets.PairVwapUpdate
         * @instance
         */
        PairVwapUpdate.prototype.vwap = 0;
        /**
         * PairVwapUpdate timestamp.
         * @member {number|Long} timestamp
         * @memberof ProtobufMarkets.PairVwapUpdate
         * @instance
         */
        PairVwapUpdate.prototype.timestamp = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * PairVwapUpdate timestampNano.
         * @member {number|Long} timestampNano
         * @memberof ProtobufMarkets.PairVwapUpdate
         * @instance
         */
        PairVwapUpdate.prototype.timestampNano = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * Creates a new PairVwapUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.PairVwapUpdate
         * @static
         * @param {ProtobufMarkets.IPairVwapUpdate=} [properties] Properties to set
         * @returns {ProtobufMarkets.PairVwapUpdate} PairVwapUpdate instance
         */
        PairVwapUpdate.create = function create(properties) {
            return new PairVwapUpdate(properties);
        };
        /**
         * Encodes the specified PairVwapUpdate message. Does not implicitly {@link ProtobufMarkets.PairVwapUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.PairVwapUpdate
         * @static
         * @param {ProtobufMarkets.IPairVwapUpdate} message PairVwapUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PairVwapUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.vwap != null && Object.hasOwnProperty.call(message, "vwap"))
                writer.uint32(/* id 1, wireType 1 =*/ 9).double(message.vwap);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.timestamp);
            if (message.timestampNano != null && Object.hasOwnProperty.call(message, "timestampNano"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.timestampNano);
            return writer;
        };
        /**
         * Encodes the specified PairVwapUpdate message, length delimited. Does not implicitly {@link ProtobufMarkets.PairVwapUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.PairVwapUpdate
         * @static
         * @param {ProtobufMarkets.IPairVwapUpdate} message PairVwapUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PairVwapUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PairVwapUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.PairVwapUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.PairVwapUpdate} PairVwapUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PairVwapUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.PairVwapUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.vwap = reader.double();
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    case 3:
                        message.timestampNano = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PairVwapUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.PairVwapUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.PairVwapUpdate} PairVwapUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PairVwapUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PairVwapUpdate message.
         * @function verify
         * @memberof ProtobufMarkets.PairVwapUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PairVwapUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.vwap != null && message.hasOwnProperty("vwap"))
                if (typeof message.vwap !== "number")
                    return "vwap: number expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.timestampNano != null && message.hasOwnProperty("timestampNano"))
                if (!$util.isInteger(message.timestampNano) && !(message.timestampNano && $util.isInteger(message.timestampNano.low) && $util.isInteger(message.timestampNano.high)))
                    return "timestampNano: integer|Long expected";
            return null;
        };
        /**
         * Creates a PairVwapUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.PairVwapUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.PairVwapUpdate} PairVwapUpdate
         */
        PairVwapUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.PairVwapUpdate)
                return object;
            var message = new $root.ProtobufMarkets.PairVwapUpdate();
            if (object.vwap != null)
                message.vwap = Number(object.vwap);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.timestampNano != null)
                if ($util.Long)
                    (message.timestampNano = $util.Long.fromValue(object.timestampNano)).unsigned = false;
                else if (typeof object.timestampNano === "string")
                    message.timestampNano = parseInt(object.timestampNano, 10);
                else if (typeof object.timestampNano === "number")
                    message.timestampNano = object.timestampNano;
                else if (typeof object.timestampNano === "object")
                    message.timestampNano = new $util.LongBits(object.timestampNano.low >>> 0, object.timestampNano.high >>> 0).toNumber();
            return message;
        };
        /**
         * Creates a plain object from a PairVwapUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.PairVwapUpdate
         * @static
         * @param {ProtobufMarkets.PairVwapUpdate} message PairVwapUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PairVwapUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.vwap = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.timestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestampNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.timestampNano = options.longs === String ? "0" : 0;
            }
            if (message.vwap != null && message.hasOwnProperty("vwap"))
                object.vwap = options.json && !isFinite(message.vwap) ? String(message.vwap) : message.vwap;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.timestampNano != null && message.hasOwnProperty("timestampNano"))
                if (typeof message.timestampNano === "number")
                    object.timestampNano = options.longs === String ? String(message.timestampNano) : message.timestampNano;
                else
                    object.timestampNano = options.longs === String ? $util.Long.prototype.toString.call(message.timestampNano) : options.longs === Number ? new $util.LongBits(message.timestampNano.low >>> 0, message.timestampNano.high >>> 0).toNumber() : message.timestampNano;
            return object;
        };
        /**
         * Converts this PairVwapUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.PairVwapUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PairVwapUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PairVwapUpdate;
    })();
    ProtobufMarkets.PairPerformanceUpdate = (function () {
        /**
         * Properties of a PairPerformanceUpdate.
         * @memberof ProtobufMarkets
         * @interface IPairPerformanceUpdate
         * @property {string|null} [window] PairPerformanceUpdate window
         * @property {number|null} [performance] PairPerformanceUpdate performance
         */
        /**
         * Constructs a new PairPerformanceUpdate.
         * @memberof ProtobufMarkets
         * @classdesc Represents a PairPerformanceUpdate.
         * @implements IPairPerformanceUpdate
         * @constructor
         * @param {ProtobufMarkets.IPairPerformanceUpdate=} [properties] Properties to set
         */
        function PairPerformanceUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PairPerformanceUpdate window.
         * @member {string} window
         * @memberof ProtobufMarkets.PairPerformanceUpdate
         * @instance
         */
        PairPerformanceUpdate.prototype.window = "";
        /**
         * PairPerformanceUpdate performance.
         * @member {number} performance
         * @memberof ProtobufMarkets.PairPerformanceUpdate
         * @instance
         */
        PairPerformanceUpdate.prototype.performance = 0;
        /**
         * Creates a new PairPerformanceUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.PairPerformanceUpdate
         * @static
         * @param {ProtobufMarkets.IPairPerformanceUpdate=} [properties] Properties to set
         * @returns {ProtobufMarkets.PairPerformanceUpdate} PairPerformanceUpdate instance
         */
        PairPerformanceUpdate.create = function create(properties) {
            return new PairPerformanceUpdate(properties);
        };
        /**
         * Encodes the specified PairPerformanceUpdate message. Does not implicitly {@link ProtobufMarkets.PairPerformanceUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.PairPerformanceUpdate
         * @static
         * @param {ProtobufMarkets.IPairPerformanceUpdate} message PairPerformanceUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PairPerformanceUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.window != null && Object.hasOwnProperty.call(message, "window"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.window);
            if (message.performance != null && Object.hasOwnProperty.call(message, "performance"))
                writer.uint32(/* id 2, wireType 1 =*/ 17).double(message.performance);
            return writer;
        };
        /**
         * Encodes the specified PairPerformanceUpdate message, length delimited. Does not implicitly {@link ProtobufMarkets.PairPerformanceUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.PairPerformanceUpdate
         * @static
         * @param {ProtobufMarkets.IPairPerformanceUpdate} message PairPerformanceUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PairPerformanceUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PairPerformanceUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.PairPerformanceUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.PairPerformanceUpdate} PairPerformanceUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PairPerformanceUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.PairPerformanceUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.window = reader.string();
                        break;
                    case 2:
                        message.performance = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PairPerformanceUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.PairPerformanceUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.PairPerformanceUpdate} PairPerformanceUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PairPerformanceUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PairPerformanceUpdate message.
         * @function verify
         * @memberof ProtobufMarkets.PairPerformanceUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PairPerformanceUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.window != null && message.hasOwnProperty("window"))
                if (!$util.isString(message.window))
                    return "window: string expected";
            if (message.performance != null && message.hasOwnProperty("performance"))
                if (typeof message.performance !== "number")
                    return "performance: number expected";
            return null;
        };
        /**
         * Creates a PairPerformanceUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.PairPerformanceUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.PairPerformanceUpdate} PairPerformanceUpdate
         */
        PairPerformanceUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.PairPerformanceUpdate)
                return object;
            var message = new $root.ProtobufMarkets.PairPerformanceUpdate();
            if (object.window != null)
                message.window = String(object.window);
            if (object.performance != null)
                message.performance = Number(object.performance);
            return message;
        };
        /**
         * Creates a plain object from a PairPerformanceUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.PairPerformanceUpdate
         * @static
         * @param {ProtobufMarkets.PairPerformanceUpdate} message PairPerformanceUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PairPerformanceUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.window = "";
                object.performance = 0;
            }
            if (message.window != null && message.hasOwnProperty("window"))
                object.window = message.window;
            if (message.performance != null && message.hasOwnProperty("performance"))
                object.performance = options.json && !isFinite(message.performance) ? String(message.performance) : message.performance;
            return object;
        };
        /**
         * Converts this PairPerformanceUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.PairPerformanceUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PairPerformanceUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PairPerformanceUpdate;
    })();
    ProtobufMarkets.PairTrendlineUpdate = (function () {
        /**
         * Properties of a PairTrendlineUpdate.
         * @memberof ProtobufMarkets
         * @interface IPairTrendlineUpdate
         * @property {string|null} [window] PairTrendlineUpdate window
         * @property {number|Long|null} [time] PairTrendlineUpdate time
         * @property {string|null} [price] PairTrendlineUpdate price
         * @property {string|null} [volume] PairTrendlineUpdate volume
         */
        /**
         * Constructs a new PairTrendlineUpdate.
         * @memberof ProtobufMarkets
         * @classdesc Represents a PairTrendlineUpdate.
         * @implements IPairTrendlineUpdate
         * @constructor
         * @param {ProtobufMarkets.IPairTrendlineUpdate=} [properties] Properties to set
         */
        function PairTrendlineUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PairTrendlineUpdate window.
         * @member {string} window
         * @memberof ProtobufMarkets.PairTrendlineUpdate
         * @instance
         */
        PairTrendlineUpdate.prototype.window = "";
        /**
         * PairTrendlineUpdate time.
         * @member {number|Long} time
         * @memberof ProtobufMarkets.PairTrendlineUpdate
         * @instance
         */
        PairTrendlineUpdate.prototype.time = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * PairTrendlineUpdate price.
         * @member {string} price
         * @memberof ProtobufMarkets.PairTrendlineUpdate
         * @instance
         */
        PairTrendlineUpdate.prototype.price = "";
        /**
         * PairTrendlineUpdate volume.
         * @member {string} volume
         * @memberof ProtobufMarkets.PairTrendlineUpdate
         * @instance
         */
        PairTrendlineUpdate.prototype.volume = "";
        /**
         * Creates a new PairTrendlineUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufMarkets.PairTrendlineUpdate
         * @static
         * @param {ProtobufMarkets.IPairTrendlineUpdate=} [properties] Properties to set
         * @returns {ProtobufMarkets.PairTrendlineUpdate} PairTrendlineUpdate instance
         */
        PairTrendlineUpdate.create = function create(properties) {
            return new PairTrendlineUpdate(properties);
        };
        /**
         * Encodes the specified PairTrendlineUpdate message. Does not implicitly {@link ProtobufMarkets.PairTrendlineUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufMarkets.PairTrendlineUpdate
         * @static
         * @param {ProtobufMarkets.IPairTrendlineUpdate} message PairTrendlineUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PairTrendlineUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.window != null && Object.hasOwnProperty.call(message, "window"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.window);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.time);
            if (message.price != null && Object.hasOwnProperty.call(message, "price"))
                writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.price);
            if (message.volume != null && Object.hasOwnProperty.call(message, "volume"))
                writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.volume);
            return writer;
        };
        /**
         * Encodes the specified PairTrendlineUpdate message, length delimited. Does not implicitly {@link ProtobufMarkets.PairTrendlineUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufMarkets.PairTrendlineUpdate
         * @static
         * @param {ProtobufMarkets.IPairTrendlineUpdate} message PairTrendlineUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PairTrendlineUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PairTrendlineUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufMarkets.PairTrendlineUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufMarkets.PairTrendlineUpdate} PairTrendlineUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PairTrendlineUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufMarkets.PairTrendlineUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.window = reader.string();
                        break;
                    case 2:
                        message.time = reader.int64();
                        break;
                    case 3:
                        message.price = reader.string();
                        break;
                    case 4:
                        message.volume = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PairTrendlineUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufMarkets.PairTrendlineUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufMarkets.PairTrendlineUpdate} PairTrendlineUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PairTrendlineUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PairTrendlineUpdate message.
         * @function verify
         * @memberof ProtobufMarkets.PairTrendlineUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PairTrendlineUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.window != null && message.hasOwnProperty("window"))
                if (!$util.isString(message.window))
                    return "window: string expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            if (message.price != null && message.hasOwnProperty("price"))
                if (!$util.isString(message.price))
                    return "price: string expected";
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (!$util.isString(message.volume))
                    return "volume: string expected";
            return null;
        };
        /**
         * Creates a PairTrendlineUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufMarkets.PairTrendlineUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufMarkets.PairTrendlineUpdate} PairTrendlineUpdate
         */
        PairTrendlineUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufMarkets.PairTrendlineUpdate)
                return object;
            var message = new $root.ProtobufMarkets.PairTrendlineUpdate();
            if (object.window != null)
                message.window = String(object.window);
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            if (object.price != null)
                message.price = String(object.price);
            if (object.volume != null)
                message.volume = String(object.volume);
            return message;
        };
        /**
         * Creates a plain object from a PairTrendlineUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufMarkets.PairTrendlineUpdate
         * @static
         * @param {ProtobufMarkets.PairTrendlineUpdate} message PairTrendlineUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PairTrendlineUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.window = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.time = options.longs === String ? "0" : 0;
                object.price = "";
                object.volume = "";
            }
            if (message.window != null && message.hasOwnProperty("window"))
                object.window = message.window;
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = message.price;
            if (message.volume != null && message.hasOwnProperty("volume"))
                object.volume = message.volume;
            return object;
        };
        /**
         * Converts this PairTrendlineUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufMarkets.PairTrendlineUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PairTrendlineUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PairTrendlineUpdate;
    })();
    return ProtobufMarkets;
})();
$root.ProtobufStream = (function () {
    /**
     * Namespace ProtobufStream.
     * @exports ProtobufStream
     * @namespace
     */
    var ProtobufStream = {};
    ProtobufStream.StreamMessage = (function () {
        /**
         * Properties of a StreamMessage.
         * @memberof ProtobufStream
         * @interface IStreamMessage
         * @property {ProtobufStream.IAuthenticationResult|null} [authenticationResult] StreamMessage authenticationResult
         * @property {ProtobufStream.ISubscriptionResult|null} [subscriptionResult] StreamMessage subscriptionResult
         * @property {ProtobufStream.IUnsubscriptionResult|null} [unsubscriptionResult] StreamMessage unsubscriptionResult
         * @property {ProtobufStream.IMissedMessages|null} [missedMessages] StreamMessage missedMessages
         * @property {ProtobufMarkets.IMarketUpdateMessage|null} [marketUpdate] StreamMessage marketUpdate
         * @property {ProtobufMarkets.IPairUpdateMessage|null} [pairUpdate] StreamMessage pairUpdate
         * @property {ProtobufMarkets.IAssetUpdateMessage|null} [assetUpdate] StreamMessage assetUpdate
         * @property {ProtobufMarkets.IIndexUpdateMessage|null} [indexUpdate] StreamMessage indexUpdate
         * @property {ProtobufStream.IBandwidthUpdate|null} [bandwidthUpdate] StreamMessage bandwidthUpdate
         * @property {ProtobufStream.IHeartbeat|null} [heartbeat] StreamMessage heartbeat
         */
        /**
         * Constructs a new StreamMessage.
         * @memberof ProtobufStream
         * @classdesc Represents a StreamMessage.
         * @implements IStreamMessage
         * @constructor
         * @param {ProtobufStream.IStreamMessage=} [properties] Properties to set
         */
        function StreamMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * StreamMessage authenticationResult.
         * @member {ProtobufStream.IAuthenticationResult|null|undefined} authenticationResult
         * @memberof ProtobufStream.StreamMessage
         * @instance
         */
        StreamMessage.prototype.authenticationResult = null;
        /**
         * StreamMessage subscriptionResult.
         * @member {ProtobufStream.ISubscriptionResult|null|undefined} subscriptionResult
         * @memberof ProtobufStream.StreamMessage
         * @instance
         */
        StreamMessage.prototype.subscriptionResult = null;
        /**
         * StreamMessage unsubscriptionResult.
         * @member {ProtobufStream.IUnsubscriptionResult|null|undefined} unsubscriptionResult
         * @memberof ProtobufStream.StreamMessage
         * @instance
         */
        StreamMessage.prototype.unsubscriptionResult = null;
        /**
         * StreamMessage missedMessages.
         * @member {ProtobufStream.IMissedMessages|null|undefined} missedMessages
         * @memberof ProtobufStream.StreamMessage
         * @instance
         */
        StreamMessage.prototype.missedMessages = null;
        /**
         * StreamMessage marketUpdate.
         * @member {ProtobufMarkets.IMarketUpdateMessage|null|undefined} marketUpdate
         * @memberof ProtobufStream.StreamMessage
         * @instance
         */
        StreamMessage.prototype.marketUpdate = null;
        /**
         * StreamMessage pairUpdate.
         * @member {ProtobufMarkets.IPairUpdateMessage|null|undefined} pairUpdate
         * @memberof ProtobufStream.StreamMessage
         * @instance
         */
        StreamMessage.prototype.pairUpdate = null;
        /**
         * StreamMessage assetUpdate.
         * @member {ProtobufMarkets.IAssetUpdateMessage|null|undefined} assetUpdate
         * @memberof ProtobufStream.StreamMessage
         * @instance
         */
        StreamMessage.prototype.assetUpdate = null;
        /**
         * StreamMessage indexUpdate.
         * @member {ProtobufMarkets.IIndexUpdateMessage|null|undefined} indexUpdate
         * @memberof ProtobufStream.StreamMessage
         * @instance
         */
        StreamMessage.prototype.indexUpdate = null;
        /**
         * StreamMessage bandwidthUpdate.
         * @member {ProtobufStream.IBandwidthUpdate|null|undefined} bandwidthUpdate
         * @memberof ProtobufStream.StreamMessage
         * @instance
         */
        StreamMessage.prototype.bandwidthUpdate = null;
        /**
         * StreamMessage heartbeat.
         * @member {ProtobufStream.IHeartbeat|null|undefined} heartbeat
         * @memberof ProtobufStream.StreamMessage
         * @instance
         */
        StreamMessage.prototype.heartbeat = null;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * StreamMessage body.
         * @member {"authenticationResult"|"subscriptionResult"|"unsubscriptionResult"|"missedMessages"|"marketUpdate"|"pairUpdate"|"assetUpdate"|"indexUpdate"|"bandwidthUpdate"|"heartbeat"|undefined} body
         * @memberof ProtobufStream.StreamMessage
         * @instance
         */
        Object.defineProperty(StreamMessage.prototype, "body", {
            get: $util.oneOfGetter($oneOfFields = ["authenticationResult", "subscriptionResult", "unsubscriptionResult", "missedMessages", "marketUpdate", "pairUpdate", "assetUpdate", "indexUpdate", "bandwidthUpdate", "heartbeat"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new StreamMessage instance using the specified properties.
         * @function create
         * @memberof ProtobufStream.StreamMessage
         * @static
         * @param {ProtobufStream.IStreamMessage=} [properties] Properties to set
         * @returns {ProtobufStream.StreamMessage} StreamMessage instance
         */
        StreamMessage.create = function create(properties) {
            return new StreamMessage(properties);
        };
        /**
         * Encodes the specified StreamMessage message. Does not implicitly {@link ProtobufStream.StreamMessage.verify|verify} messages.
         * @function encode
         * @memberof ProtobufStream.StreamMessage
         * @static
         * @param {ProtobufStream.IStreamMessage} message StreamMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.authenticationResult != null && Object.hasOwnProperty.call(message, "authenticationResult"))
                $root.ProtobufStream.AuthenticationResult.encode(message.authenticationResult, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.marketUpdate != null && Object.hasOwnProperty.call(message, "marketUpdate"))
                $root.ProtobufMarkets.MarketUpdateMessage.encode(message.marketUpdate, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.pairUpdate != null && Object.hasOwnProperty.call(message, "pairUpdate"))
                $root.ProtobufMarkets.PairUpdateMessage.encode(message.pairUpdate, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.assetUpdate != null && Object.hasOwnProperty.call(message, "assetUpdate"))
                $root.ProtobufMarkets.AssetUpdateMessage.encode(message.assetUpdate, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            if (message.subscriptionResult != null && Object.hasOwnProperty.call(message, "subscriptionResult"))
                $root.ProtobufStream.SubscriptionResult.encode(message.subscriptionResult, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
            if (message.unsubscriptionResult != null && Object.hasOwnProperty.call(message, "unsubscriptionResult"))
                $root.ProtobufStream.UnsubscriptionResult.encode(message.unsubscriptionResult, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
            if (message.missedMessages != null && Object.hasOwnProperty.call(message, "missedMessages"))
                $root.ProtobufStream.MissedMessages.encode(message.missedMessages, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
            if (message.indexUpdate != null && Object.hasOwnProperty.call(message, "indexUpdate"))
                $root.ProtobufMarkets.IndexUpdateMessage.encode(message.indexUpdate, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
            if (message.bandwidthUpdate != null && Object.hasOwnProperty.call(message, "bandwidthUpdate"))
                $root.ProtobufStream.BandwidthUpdate.encode(message.bandwidthUpdate, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
            if (message.heartbeat != null && Object.hasOwnProperty.call(message, "heartbeat"))
                $root.ProtobufStream.Heartbeat.encode(message.heartbeat, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified StreamMessage message, length delimited. Does not implicitly {@link ProtobufStream.StreamMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufStream.StreamMessage
         * @static
         * @param {ProtobufStream.IStreamMessage} message StreamMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a StreamMessage message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufStream.StreamMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufStream.StreamMessage} StreamMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufStream.StreamMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.authenticationResult = $root.ProtobufStream.AuthenticationResult.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.subscriptionResult = $root.ProtobufStream.SubscriptionResult.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.unsubscriptionResult = $root.ProtobufStream.UnsubscriptionResult.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.missedMessages = $root.ProtobufStream.MissedMessages.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.marketUpdate = $root.ProtobufMarkets.MarketUpdateMessage.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.pairUpdate = $root.ProtobufMarkets.PairUpdateMessage.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.assetUpdate = $root.ProtobufMarkets.AssetUpdateMessage.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.indexUpdate = $root.ProtobufMarkets.IndexUpdateMessage.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.bandwidthUpdate = $root.ProtobufStream.BandwidthUpdate.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.heartbeat = $root.ProtobufStream.Heartbeat.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a StreamMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufStream.StreamMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufStream.StreamMessage} StreamMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a StreamMessage message.
         * @function verify
         * @memberof ProtobufStream.StreamMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StreamMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.authenticationResult != null && message.hasOwnProperty("authenticationResult")) {
                properties.body = 1;
                {
                    var error = $root.ProtobufStream.AuthenticationResult.verify(message.authenticationResult);
                    if (error)
                        return "authenticationResult." + error;
                }
            }
            if (message.subscriptionResult != null && message.hasOwnProperty("subscriptionResult")) {
                if (properties.body === 1)
                    return "body: multiple values";
                properties.body = 1;
                {
                    var error = $root.ProtobufStream.SubscriptionResult.verify(message.subscriptionResult);
                    if (error)
                        return "subscriptionResult." + error;
                }
            }
            if (message.unsubscriptionResult != null && message.hasOwnProperty("unsubscriptionResult")) {
                if (properties.body === 1)
                    return "body: multiple values";
                properties.body = 1;
                {
                    var error = $root.ProtobufStream.UnsubscriptionResult.verify(message.unsubscriptionResult);
                    if (error)
                        return "unsubscriptionResult." + error;
                }
            }
            if (message.missedMessages != null && message.hasOwnProperty("missedMessages")) {
                if (properties.body === 1)
                    return "body: multiple values";
                properties.body = 1;
                {
                    var error = $root.ProtobufStream.MissedMessages.verify(message.missedMessages);
                    if (error)
                        return "missedMessages." + error;
                }
            }
            if (message.marketUpdate != null && message.hasOwnProperty("marketUpdate")) {
                if (properties.body === 1)
                    return "body: multiple values";
                properties.body = 1;
                {
                    var error = $root.ProtobufMarkets.MarketUpdateMessage.verify(message.marketUpdate);
                    if (error)
                        return "marketUpdate." + error;
                }
            }
            if (message.pairUpdate != null && message.hasOwnProperty("pairUpdate")) {
                if (properties.body === 1)
                    return "body: multiple values";
                properties.body = 1;
                {
                    var error = $root.ProtobufMarkets.PairUpdateMessage.verify(message.pairUpdate);
                    if (error)
                        return "pairUpdate." + error;
                }
            }
            if (message.assetUpdate != null && message.hasOwnProperty("assetUpdate")) {
                if (properties.body === 1)
                    return "body: multiple values";
                properties.body = 1;
                {
                    var error = $root.ProtobufMarkets.AssetUpdateMessage.verify(message.assetUpdate);
                    if (error)
                        return "assetUpdate." + error;
                }
            }
            if (message.indexUpdate != null && message.hasOwnProperty("indexUpdate")) {
                if (properties.body === 1)
                    return "body: multiple values";
                properties.body = 1;
                {
                    var error = $root.ProtobufMarkets.IndexUpdateMessage.verify(message.indexUpdate);
                    if (error)
                        return "indexUpdate." + error;
                }
            }
            if (message.bandwidthUpdate != null && message.hasOwnProperty("bandwidthUpdate")) {
                if (properties.body === 1)
                    return "body: multiple values";
                properties.body = 1;
                {
                    var error = $root.ProtobufStream.BandwidthUpdate.verify(message.bandwidthUpdate);
                    if (error)
                        return "bandwidthUpdate." + error;
                }
            }
            if (message.heartbeat != null && message.hasOwnProperty("heartbeat")) {
                if (properties.body === 1)
                    return "body: multiple values";
                properties.body = 1;
                {
                    var error = $root.ProtobufStream.Heartbeat.verify(message.heartbeat);
                    if (error)
                        return "heartbeat." + error;
                }
            }
            return null;
        };
        /**
         * Creates a StreamMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufStream.StreamMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufStream.StreamMessage} StreamMessage
         */
        StreamMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufStream.StreamMessage)
                return object;
            var message = new $root.ProtobufStream.StreamMessage();
            if (object.authenticationResult != null) {
                if (typeof object.authenticationResult !== "object")
                    throw TypeError(".ProtobufStream.StreamMessage.authenticationResult: object expected");
                message.authenticationResult = $root.ProtobufStream.AuthenticationResult.fromObject(object.authenticationResult);
            }
            if (object.subscriptionResult != null) {
                if (typeof object.subscriptionResult !== "object")
                    throw TypeError(".ProtobufStream.StreamMessage.subscriptionResult: object expected");
                message.subscriptionResult = $root.ProtobufStream.SubscriptionResult.fromObject(object.subscriptionResult);
            }
            if (object.unsubscriptionResult != null) {
                if (typeof object.unsubscriptionResult !== "object")
                    throw TypeError(".ProtobufStream.StreamMessage.unsubscriptionResult: object expected");
                message.unsubscriptionResult = $root.ProtobufStream.UnsubscriptionResult.fromObject(object.unsubscriptionResult);
            }
            if (object.missedMessages != null) {
                if (typeof object.missedMessages !== "object")
                    throw TypeError(".ProtobufStream.StreamMessage.missedMessages: object expected");
                message.missedMessages = $root.ProtobufStream.MissedMessages.fromObject(object.missedMessages);
            }
            if (object.marketUpdate != null) {
                if (typeof object.marketUpdate !== "object")
                    throw TypeError(".ProtobufStream.StreamMessage.marketUpdate: object expected");
                message.marketUpdate = $root.ProtobufMarkets.MarketUpdateMessage.fromObject(object.marketUpdate);
            }
            if (object.pairUpdate != null) {
                if (typeof object.pairUpdate !== "object")
                    throw TypeError(".ProtobufStream.StreamMessage.pairUpdate: object expected");
                message.pairUpdate = $root.ProtobufMarkets.PairUpdateMessage.fromObject(object.pairUpdate);
            }
            if (object.assetUpdate != null) {
                if (typeof object.assetUpdate !== "object")
                    throw TypeError(".ProtobufStream.StreamMessage.assetUpdate: object expected");
                message.assetUpdate = $root.ProtobufMarkets.AssetUpdateMessage.fromObject(object.assetUpdate);
            }
            if (object.indexUpdate != null) {
                if (typeof object.indexUpdate !== "object")
                    throw TypeError(".ProtobufStream.StreamMessage.indexUpdate: object expected");
                message.indexUpdate = $root.ProtobufMarkets.IndexUpdateMessage.fromObject(object.indexUpdate);
            }
            if (object.bandwidthUpdate != null) {
                if (typeof object.bandwidthUpdate !== "object")
                    throw TypeError(".ProtobufStream.StreamMessage.bandwidthUpdate: object expected");
                message.bandwidthUpdate = $root.ProtobufStream.BandwidthUpdate.fromObject(object.bandwidthUpdate);
            }
            if (object.heartbeat != null) {
                if (typeof object.heartbeat !== "object")
                    throw TypeError(".ProtobufStream.StreamMessage.heartbeat: object expected");
                message.heartbeat = $root.ProtobufStream.Heartbeat.fromObject(object.heartbeat);
            }
            return message;
        };
        /**
         * Creates a plain object from a StreamMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufStream.StreamMessage
         * @static
         * @param {ProtobufStream.StreamMessage} message StreamMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StreamMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.authenticationResult != null && message.hasOwnProperty("authenticationResult")) {
                object.authenticationResult = $root.ProtobufStream.AuthenticationResult.toObject(message.authenticationResult, options);
                if (options.oneofs)
                    object.body = "authenticationResult";
            }
            if (message.marketUpdate != null && message.hasOwnProperty("marketUpdate")) {
                object.marketUpdate = $root.ProtobufMarkets.MarketUpdateMessage.toObject(message.marketUpdate, options);
                if (options.oneofs)
                    object.body = "marketUpdate";
            }
            if (message.pairUpdate != null && message.hasOwnProperty("pairUpdate")) {
                object.pairUpdate = $root.ProtobufMarkets.PairUpdateMessage.toObject(message.pairUpdate, options);
                if (options.oneofs)
                    object.body = "pairUpdate";
            }
            if (message.assetUpdate != null && message.hasOwnProperty("assetUpdate")) {
                object.assetUpdate = $root.ProtobufMarkets.AssetUpdateMessage.toObject(message.assetUpdate, options);
                if (options.oneofs)
                    object.body = "assetUpdate";
            }
            if (message.subscriptionResult != null && message.hasOwnProperty("subscriptionResult")) {
                object.subscriptionResult = $root.ProtobufStream.SubscriptionResult.toObject(message.subscriptionResult, options);
                if (options.oneofs)
                    object.body = "subscriptionResult";
            }
            if (message.unsubscriptionResult != null && message.hasOwnProperty("unsubscriptionResult")) {
                object.unsubscriptionResult = $root.ProtobufStream.UnsubscriptionResult.toObject(message.unsubscriptionResult, options);
                if (options.oneofs)
                    object.body = "unsubscriptionResult";
            }
            if (message.missedMessages != null && message.hasOwnProperty("missedMessages")) {
                object.missedMessages = $root.ProtobufStream.MissedMessages.toObject(message.missedMessages, options);
                if (options.oneofs)
                    object.body = "missedMessages";
            }
            if (message.indexUpdate != null && message.hasOwnProperty("indexUpdate")) {
                object.indexUpdate = $root.ProtobufMarkets.IndexUpdateMessage.toObject(message.indexUpdate, options);
                if (options.oneofs)
                    object.body = "indexUpdate";
            }
            if (message.bandwidthUpdate != null && message.hasOwnProperty("bandwidthUpdate")) {
                object.bandwidthUpdate = $root.ProtobufStream.BandwidthUpdate.toObject(message.bandwidthUpdate, options);
                if (options.oneofs)
                    object.body = "bandwidthUpdate";
            }
            if (message.heartbeat != null && message.hasOwnProperty("heartbeat")) {
                object.heartbeat = $root.ProtobufStream.Heartbeat.toObject(message.heartbeat, options);
                if (options.oneofs)
                    object.body = "heartbeat";
            }
            return object;
        };
        /**
         * Converts this StreamMessage to JSON.
         * @function toJSON
         * @memberof ProtobufStream.StreamMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StreamMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return StreamMessage;
    })();
    ProtobufStream.AuthenticationResult = (function () {
        /**
         * Properties of an AuthenticationResult.
         * @memberof ProtobufStream
         * @interface IAuthenticationResult
         * @property {ProtobufStream.AuthenticationResult.Status|null} [status] AuthenticationResult status
         */
        /**
         * Constructs a new AuthenticationResult.
         * @memberof ProtobufStream
         * @classdesc Represents an AuthenticationResult.
         * @implements IAuthenticationResult
         * @constructor
         * @param {ProtobufStream.IAuthenticationResult=} [properties] Properties to set
         */
        function AuthenticationResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * AuthenticationResult status.
         * @member {ProtobufStream.AuthenticationResult.Status} status
         * @memberof ProtobufStream.AuthenticationResult
         * @instance
         */
        AuthenticationResult.prototype.status = 0;
        /**
         * Creates a new AuthenticationResult instance using the specified properties.
         * @function create
         * @memberof ProtobufStream.AuthenticationResult
         * @static
         * @param {ProtobufStream.IAuthenticationResult=} [properties] Properties to set
         * @returns {ProtobufStream.AuthenticationResult} AuthenticationResult instance
         */
        AuthenticationResult.create = function create(properties) {
            return new AuthenticationResult(properties);
        };
        /**
         * Encodes the specified AuthenticationResult message. Does not implicitly {@link ProtobufStream.AuthenticationResult.verify|verify} messages.
         * @function encode
         * @memberof ProtobufStream.AuthenticationResult
         * @static
         * @param {ProtobufStream.IAuthenticationResult} message AuthenticationResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthenticationResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.status);
            return writer;
        };
        /**
         * Encodes the specified AuthenticationResult message, length delimited. Does not implicitly {@link ProtobufStream.AuthenticationResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufStream.AuthenticationResult
         * @static
         * @param {ProtobufStream.IAuthenticationResult} message AuthenticationResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthenticationResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an AuthenticationResult message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufStream.AuthenticationResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufStream.AuthenticationResult} AuthenticationResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthenticationResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufStream.AuthenticationResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an AuthenticationResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufStream.AuthenticationResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufStream.AuthenticationResult} AuthenticationResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthenticationResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an AuthenticationResult message.
         * @function verify
         * @memberof ProtobufStream.AuthenticationResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AuthenticationResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        break;
                }
            return null;
        };
        /**
         * Creates an AuthenticationResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufStream.AuthenticationResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufStream.AuthenticationResult} AuthenticationResult
         */
        AuthenticationResult.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufStream.AuthenticationResult)
                return object;
            var message = new $root.ProtobufStream.AuthenticationResult();
            switch (object.status) {
                case "UNKNOWN":
                case 0:
                    message.status = 0;
                    break;
                case "AUTHENTICATED":
                case 1:
                    message.status = 1;
                    break;
                case "BAD_NONCE":
                case 2:
                    message.status = 2;
                    break;
                case "BAD_TOKEN":
                case 3:
                    message.status = 3;
                    break;
                case "TOKEN_EXPIRED":
                case 4:
                    message.status = 4;
                    break;
                case "READONLY_KEY":
                case 5:
                    message.status = 5;
                    break;
                case "ACCESS_DENIED":
                case 6:
                    message.status = 6;
                    break;
                case "INVALID_PUBLIC_KEY":
                case 7:
                    message.status = 7;
                    break;
            }
            return message;
        };
        /**
         * Creates a plain object from an AuthenticationResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufStream.AuthenticationResult
         * @static
         * @param {ProtobufStream.AuthenticationResult} message AuthenticationResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AuthenticationResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = options.enums === String ? "UNKNOWN" : 0;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.ProtobufStream.AuthenticationResult.Status[message.status] : message.status;
            return object;
        };
        /**
         * Converts this AuthenticationResult to JSON.
         * @function toJSON
         * @memberof ProtobufStream.AuthenticationResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AuthenticationResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Status enum.
         * @name ProtobufStream.AuthenticationResult.Status
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} AUTHENTICATED=1 AUTHENTICATED value
         * @property {number} BAD_NONCE=2 BAD_NONCE value
         * @property {number} BAD_TOKEN=3 BAD_TOKEN value
         * @property {number} TOKEN_EXPIRED=4 TOKEN_EXPIRED value
         * @property {number} READONLY_KEY=5 READONLY_KEY value
         * @property {number} ACCESS_DENIED=6 ACCESS_DENIED value
         * @property {number} INVALID_PUBLIC_KEY=7 INVALID_PUBLIC_KEY value
         */
        AuthenticationResult.Status = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "AUTHENTICATED"] = 1;
            values[valuesById[2] = "BAD_NONCE"] = 2;
            values[valuesById[3] = "BAD_TOKEN"] = 3;
            values[valuesById[4] = "TOKEN_EXPIRED"] = 4;
            values[valuesById[5] = "READONLY_KEY"] = 5;
            values[valuesById[6] = "ACCESS_DENIED"] = 6;
            values[valuesById[7] = "INVALID_PUBLIC_KEY"] = 7;
            return values;
        })();
        return AuthenticationResult;
    })();
    ProtobufStream.SubscriptionResult = (function () {
        /**
         * Properties of a SubscriptionResult.
         * @memberof ProtobufStream
         * @interface ISubscriptionResult
         * @property {Array.<string>|null} [subscribed] SubscriptionResult subscribed
         * @property {Array.<ProtobufStream.ISubscribeError>|null} [failed] SubscriptionResult failed
         * @property {ProtobufStream.ISubscriptionStatus|null} [status] SubscriptionResult status
         * @property {Array.<ProtobufClient.IClientSubscription>|null} [subscriptions] SubscriptionResult subscriptions
         */
        /**
         * Constructs a new SubscriptionResult.
         * @memberof ProtobufStream
         * @classdesc Represents a SubscriptionResult.
         * @implements ISubscriptionResult
         * @constructor
         * @param {ProtobufStream.ISubscriptionResult=} [properties] Properties to set
         */
        function SubscriptionResult(properties) {
            this.subscribed = [];
            this.failed = [];
            this.subscriptions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * SubscriptionResult subscribed.
         * @member {Array.<string>} subscribed
         * @memberof ProtobufStream.SubscriptionResult
         * @instance
         */
        SubscriptionResult.prototype.subscribed = $util.emptyArray;
        /**
         * SubscriptionResult failed.
         * @member {Array.<ProtobufStream.ISubscribeError>} failed
         * @memberof ProtobufStream.SubscriptionResult
         * @instance
         */
        SubscriptionResult.prototype.failed = $util.emptyArray;
        /**
         * SubscriptionResult status.
         * @member {ProtobufStream.ISubscriptionStatus|null|undefined} status
         * @memberof ProtobufStream.SubscriptionResult
         * @instance
         */
        SubscriptionResult.prototype.status = null;
        /**
         * SubscriptionResult subscriptions.
         * @member {Array.<ProtobufClient.IClientSubscription>} subscriptions
         * @memberof ProtobufStream.SubscriptionResult
         * @instance
         */
        SubscriptionResult.prototype.subscriptions = $util.emptyArray;
        /**
         * Creates a new SubscriptionResult instance using the specified properties.
         * @function create
         * @memberof ProtobufStream.SubscriptionResult
         * @static
         * @param {ProtobufStream.ISubscriptionResult=} [properties] Properties to set
         * @returns {ProtobufStream.SubscriptionResult} SubscriptionResult instance
         */
        SubscriptionResult.create = function create(properties) {
            return new SubscriptionResult(properties);
        };
        /**
         * Encodes the specified SubscriptionResult message. Does not implicitly {@link ProtobufStream.SubscriptionResult.verify|verify} messages.
         * @function encode
         * @memberof ProtobufStream.SubscriptionResult
         * @static
         * @param {ProtobufStream.ISubscriptionResult} message SubscriptionResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscriptionResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.subscribed != null && message.subscribed.length)
                for (var i = 0; i < message.subscribed.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.subscribed[i]);
            if (message.failed != null && message.failed.length)
                for (var i = 0; i < message.failed.length; ++i)
                    $root.ProtobufStream.SubscribeError.encode(message.failed[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.ProtobufStream.SubscriptionStatus.encode(message.status, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.subscriptions != null && message.subscriptions.length)
                for (var i = 0; i < message.subscriptions.length; ++i)
                    $root.ProtobufClient.ClientSubscription.encode(message.subscriptions[i], writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified SubscriptionResult message, length delimited. Does not implicitly {@link ProtobufStream.SubscriptionResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufStream.SubscriptionResult
         * @static
         * @param {ProtobufStream.ISubscriptionResult} message SubscriptionResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscriptionResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a SubscriptionResult message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufStream.SubscriptionResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufStream.SubscriptionResult} SubscriptionResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscriptionResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufStream.SubscriptionResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.subscribed && message.subscribed.length))
                            message.subscribed = [];
                        message.subscribed.push(reader.string());
                        break;
                    case 2:
                        if (!(message.failed && message.failed.length))
                            message.failed = [];
                        message.failed.push($root.ProtobufStream.SubscribeError.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.status = $root.ProtobufStream.SubscriptionStatus.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.subscriptions && message.subscriptions.length))
                            message.subscriptions = [];
                        message.subscriptions.push($root.ProtobufClient.ClientSubscription.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a SubscriptionResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufStream.SubscriptionResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufStream.SubscriptionResult} SubscriptionResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscriptionResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a SubscriptionResult message.
         * @function verify
         * @memberof ProtobufStream.SubscriptionResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscriptionResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.subscribed != null && message.hasOwnProperty("subscribed")) {
                if (!Array.isArray(message.subscribed))
                    return "subscribed: array expected";
                for (var i = 0; i < message.subscribed.length; ++i)
                    if (!$util.isString(message.subscribed[i]))
                        return "subscribed: string[] expected";
            }
            if (message.failed != null && message.hasOwnProperty("failed")) {
                if (!Array.isArray(message.failed))
                    return "failed: array expected";
                for (var i = 0; i < message.failed.length; ++i) {
                    var error = $root.ProtobufStream.SubscribeError.verify(message.failed[i]);
                    if (error)
                        return "failed." + error;
                }
            }
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.ProtobufStream.SubscriptionStatus.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.subscriptions != null && message.hasOwnProperty("subscriptions")) {
                if (!Array.isArray(message.subscriptions))
                    return "subscriptions: array expected";
                for (var i = 0; i < message.subscriptions.length; ++i) {
                    var error = $root.ProtobufClient.ClientSubscription.verify(message.subscriptions[i]);
                    if (error)
                        return "subscriptions." + error;
                }
            }
            return null;
        };
        /**
         * Creates a SubscriptionResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufStream.SubscriptionResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufStream.SubscriptionResult} SubscriptionResult
         */
        SubscriptionResult.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufStream.SubscriptionResult)
                return object;
            var message = new $root.ProtobufStream.SubscriptionResult();
            if (object.subscribed) {
                if (!Array.isArray(object.subscribed))
                    throw TypeError(".ProtobufStream.SubscriptionResult.subscribed: array expected");
                message.subscribed = [];
                for (var i = 0; i < object.subscribed.length; ++i)
                    message.subscribed[i] = String(object.subscribed[i]);
            }
            if (object.failed) {
                if (!Array.isArray(object.failed))
                    throw TypeError(".ProtobufStream.SubscriptionResult.failed: array expected");
                message.failed = [];
                for (var i = 0; i < object.failed.length; ++i) {
                    if (typeof object.failed[i] !== "object")
                        throw TypeError(".ProtobufStream.SubscriptionResult.failed: object expected");
                    message.failed[i] = $root.ProtobufStream.SubscribeError.fromObject(object.failed[i]);
                }
            }
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".ProtobufStream.SubscriptionResult.status: object expected");
                message.status = $root.ProtobufStream.SubscriptionStatus.fromObject(object.status);
            }
            if (object.subscriptions) {
                if (!Array.isArray(object.subscriptions))
                    throw TypeError(".ProtobufStream.SubscriptionResult.subscriptions: array expected");
                message.subscriptions = [];
                for (var i = 0; i < object.subscriptions.length; ++i) {
                    if (typeof object.subscriptions[i] !== "object")
                        throw TypeError(".ProtobufStream.SubscriptionResult.subscriptions: object expected");
                    message.subscriptions[i] = $root.ProtobufClient.ClientSubscription.fromObject(object.subscriptions[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a SubscriptionResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufStream.SubscriptionResult
         * @static
         * @param {ProtobufStream.SubscriptionResult} message SubscriptionResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscriptionResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.subscribed = [];
                object.failed = [];
                object.subscriptions = [];
            }
            if (options.defaults)
                object.status = null;
            if (message.subscribed && message.subscribed.length) {
                object.subscribed = [];
                for (var j = 0; j < message.subscribed.length; ++j)
                    object.subscribed[j] = message.subscribed[j];
            }
            if (message.failed && message.failed.length) {
                object.failed = [];
                for (var j = 0; j < message.failed.length; ++j)
                    object.failed[j] = $root.ProtobufStream.SubscribeError.toObject(message.failed[j], options);
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.ProtobufStream.SubscriptionStatus.toObject(message.status, options);
            if (message.subscriptions && message.subscriptions.length) {
                object.subscriptions = [];
                for (var j = 0; j < message.subscriptions.length; ++j)
                    object.subscriptions[j] = $root.ProtobufClient.ClientSubscription.toObject(message.subscriptions[j], options);
            }
            return object;
        };
        /**
         * Converts this SubscriptionResult to JSON.
         * @function toJSON
         * @memberof ProtobufStream.SubscriptionResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscriptionResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return SubscriptionResult;
    })();
    ProtobufStream.UnsubscriptionResult = (function () {
        /**
         * Properties of an UnsubscriptionResult.
         * @memberof ProtobufStream
         * @interface IUnsubscriptionResult
         * @property {Array.<string>|null} [unsubscribed] UnsubscriptionResult unsubscribed
         * @property {Array.<ProtobufStream.IUnsubscribeError>|null} [failed] UnsubscriptionResult failed
         * @property {ProtobufStream.ISubscriptionStatus|null} [status] UnsubscriptionResult status
         * @property {Array.<ProtobufClient.IClientSubscription>|null} [subscriptions] UnsubscriptionResult subscriptions
         */
        /**
         * Constructs a new UnsubscriptionResult.
         * @memberof ProtobufStream
         * @classdesc Represents an UnsubscriptionResult.
         * @implements IUnsubscriptionResult
         * @constructor
         * @param {ProtobufStream.IUnsubscriptionResult=} [properties] Properties to set
         */
        function UnsubscriptionResult(properties) {
            this.unsubscribed = [];
            this.failed = [];
            this.subscriptions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * UnsubscriptionResult unsubscribed.
         * @member {Array.<string>} unsubscribed
         * @memberof ProtobufStream.UnsubscriptionResult
         * @instance
         */
        UnsubscriptionResult.prototype.unsubscribed = $util.emptyArray;
        /**
         * UnsubscriptionResult failed.
         * @member {Array.<ProtobufStream.IUnsubscribeError>} failed
         * @memberof ProtobufStream.UnsubscriptionResult
         * @instance
         */
        UnsubscriptionResult.prototype.failed = $util.emptyArray;
        /**
         * UnsubscriptionResult status.
         * @member {ProtobufStream.ISubscriptionStatus|null|undefined} status
         * @memberof ProtobufStream.UnsubscriptionResult
         * @instance
         */
        UnsubscriptionResult.prototype.status = null;
        /**
         * UnsubscriptionResult subscriptions.
         * @member {Array.<ProtobufClient.IClientSubscription>} subscriptions
         * @memberof ProtobufStream.UnsubscriptionResult
         * @instance
         */
        UnsubscriptionResult.prototype.subscriptions = $util.emptyArray;
        /**
         * Creates a new UnsubscriptionResult instance using the specified properties.
         * @function create
         * @memberof ProtobufStream.UnsubscriptionResult
         * @static
         * @param {ProtobufStream.IUnsubscriptionResult=} [properties] Properties to set
         * @returns {ProtobufStream.UnsubscriptionResult} UnsubscriptionResult instance
         */
        UnsubscriptionResult.create = function create(properties) {
            return new UnsubscriptionResult(properties);
        };
        /**
         * Encodes the specified UnsubscriptionResult message. Does not implicitly {@link ProtobufStream.UnsubscriptionResult.verify|verify} messages.
         * @function encode
         * @memberof ProtobufStream.UnsubscriptionResult
         * @static
         * @param {ProtobufStream.IUnsubscriptionResult} message UnsubscriptionResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnsubscriptionResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.unsubscribed != null && message.unsubscribed.length)
                for (var i = 0; i < message.unsubscribed.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.unsubscribed[i]);
            if (message.failed != null && message.failed.length)
                for (var i = 0; i < message.failed.length; ++i)
                    $root.ProtobufStream.UnsubscribeError.encode(message.failed[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.ProtobufStream.SubscriptionStatus.encode(message.status, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.subscriptions != null && message.subscriptions.length)
                for (var i = 0; i < message.subscriptions.length; ++i)
                    $root.ProtobufClient.ClientSubscription.encode(message.subscriptions[i], writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified UnsubscriptionResult message, length delimited. Does not implicitly {@link ProtobufStream.UnsubscriptionResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufStream.UnsubscriptionResult
         * @static
         * @param {ProtobufStream.IUnsubscriptionResult} message UnsubscriptionResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnsubscriptionResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an UnsubscriptionResult message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufStream.UnsubscriptionResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufStream.UnsubscriptionResult} UnsubscriptionResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnsubscriptionResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufStream.UnsubscriptionResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.unsubscribed && message.unsubscribed.length))
                            message.unsubscribed = [];
                        message.unsubscribed.push(reader.string());
                        break;
                    case 2:
                        if (!(message.failed && message.failed.length))
                            message.failed = [];
                        message.failed.push($root.ProtobufStream.UnsubscribeError.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.status = $root.ProtobufStream.SubscriptionStatus.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.subscriptions && message.subscriptions.length))
                            message.subscriptions = [];
                        message.subscriptions.push($root.ProtobufClient.ClientSubscription.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an UnsubscriptionResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufStream.UnsubscriptionResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufStream.UnsubscriptionResult} UnsubscriptionResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnsubscriptionResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an UnsubscriptionResult message.
         * @function verify
         * @memberof ProtobufStream.UnsubscriptionResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnsubscriptionResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.unsubscribed != null && message.hasOwnProperty("unsubscribed")) {
                if (!Array.isArray(message.unsubscribed))
                    return "unsubscribed: array expected";
                for (var i = 0; i < message.unsubscribed.length; ++i)
                    if (!$util.isString(message.unsubscribed[i]))
                        return "unsubscribed: string[] expected";
            }
            if (message.failed != null && message.hasOwnProperty("failed")) {
                if (!Array.isArray(message.failed))
                    return "failed: array expected";
                for (var i = 0; i < message.failed.length; ++i) {
                    var error = $root.ProtobufStream.UnsubscribeError.verify(message.failed[i]);
                    if (error)
                        return "failed." + error;
                }
            }
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.ProtobufStream.SubscriptionStatus.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.subscriptions != null && message.hasOwnProperty("subscriptions")) {
                if (!Array.isArray(message.subscriptions))
                    return "subscriptions: array expected";
                for (var i = 0; i < message.subscriptions.length; ++i) {
                    var error = $root.ProtobufClient.ClientSubscription.verify(message.subscriptions[i]);
                    if (error)
                        return "subscriptions." + error;
                }
            }
            return null;
        };
        /**
         * Creates an UnsubscriptionResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufStream.UnsubscriptionResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufStream.UnsubscriptionResult} UnsubscriptionResult
         */
        UnsubscriptionResult.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufStream.UnsubscriptionResult)
                return object;
            var message = new $root.ProtobufStream.UnsubscriptionResult();
            if (object.unsubscribed) {
                if (!Array.isArray(object.unsubscribed))
                    throw TypeError(".ProtobufStream.UnsubscriptionResult.unsubscribed: array expected");
                message.unsubscribed = [];
                for (var i = 0; i < object.unsubscribed.length; ++i)
                    message.unsubscribed[i] = String(object.unsubscribed[i]);
            }
            if (object.failed) {
                if (!Array.isArray(object.failed))
                    throw TypeError(".ProtobufStream.UnsubscriptionResult.failed: array expected");
                message.failed = [];
                for (var i = 0; i < object.failed.length; ++i) {
                    if (typeof object.failed[i] !== "object")
                        throw TypeError(".ProtobufStream.UnsubscriptionResult.failed: object expected");
                    message.failed[i] = $root.ProtobufStream.UnsubscribeError.fromObject(object.failed[i]);
                }
            }
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".ProtobufStream.UnsubscriptionResult.status: object expected");
                message.status = $root.ProtobufStream.SubscriptionStatus.fromObject(object.status);
            }
            if (object.subscriptions) {
                if (!Array.isArray(object.subscriptions))
                    throw TypeError(".ProtobufStream.UnsubscriptionResult.subscriptions: array expected");
                message.subscriptions = [];
                for (var i = 0; i < object.subscriptions.length; ++i) {
                    if (typeof object.subscriptions[i] !== "object")
                        throw TypeError(".ProtobufStream.UnsubscriptionResult.subscriptions: object expected");
                    message.subscriptions[i] = $root.ProtobufClient.ClientSubscription.fromObject(object.subscriptions[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from an UnsubscriptionResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufStream.UnsubscriptionResult
         * @static
         * @param {ProtobufStream.UnsubscriptionResult} message UnsubscriptionResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnsubscriptionResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.unsubscribed = [];
                object.failed = [];
                object.subscriptions = [];
            }
            if (options.defaults)
                object.status = null;
            if (message.unsubscribed && message.unsubscribed.length) {
                object.unsubscribed = [];
                for (var j = 0; j < message.unsubscribed.length; ++j)
                    object.unsubscribed[j] = message.unsubscribed[j];
            }
            if (message.failed && message.failed.length) {
                object.failed = [];
                for (var j = 0; j < message.failed.length; ++j)
                    object.failed[j] = $root.ProtobufStream.UnsubscribeError.toObject(message.failed[j], options);
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.ProtobufStream.SubscriptionStatus.toObject(message.status, options);
            if (message.subscriptions && message.subscriptions.length) {
                object.subscriptions = [];
                for (var j = 0; j < message.subscriptions.length; ++j)
                    object.subscriptions[j] = $root.ProtobufClient.ClientSubscription.toObject(message.subscriptions[j], options);
            }
            return object;
        };
        /**
         * Converts this UnsubscriptionResult to JSON.
         * @function toJSON
         * @memberof ProtobufStream.UnsubscriptionResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnsubscriptionResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return UnsubscriptionResult;
    })();
    ProtobufStream.SubscribeError = (function () {
        /**
         * Properties of a SubscribeError.
         * @memberof ProtobufStream
         * @interface ISubscribeError
         * @property {string|null} [key] SubscribeError key
         * @property {string|null} [error] SubscribeError error
         * @property {ProtobufClient.IClientSubscription|null} [subscription] SubscribeError subscription
         */
        /**
         * Constructs a new SubscribeError.
         * @memberof ProtobufStream
         * @classdesc Represents a SubscribeError.
         * @implements ISubscribeError
         * @constructor
         * @param {ProtobufStream.ISubscribeError=} [properties] Properties to set
         */
        function SubscribeError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * SubscribeError key.
         * @member {string} key
         * @memberof ProtobufStream.SubscribeError
         * @instance
         */
        SubscribeError.prototype.key = "";
        /**
         * SubscribeError error.
         * @member {string} error
         * @memberof ProtobufStream.SubscribeError
         * @instance
         */
        SubscribeError.prototype.error = "";
        /**
         * SubscribeError subscription.
         * @member {ProtobufClient.IClientSubscription|null|undefined} subscription
         * @memberof ProtobufStream.SubscribeError
         * @instance
         */
        SubscribeError.prototype.subscription = null;
        /**
         * Creates a new SubscribeError instance using the specified properties.
         * @function create
         * @memberof ProtobufStream.SubscribeError
         * @static
         * @param {ProtobufStream.ISubscribeError=} [properties] Properties to set
         * @returns {ProtobufStream.SubscribeError} SubscribeError instance
         */
        SubscribeError.create = function create(properties) {
            return new SubscribeError(properties);
        };
        /**
         * Encodes the specified SubscribeError message. Does not implicitly {@link ProtobufStream.SubscribeError.verify|verify} messages.
         * @function encode
         * @memberof ProtobufStream.SubscribeError
         * @static
         * @param {ProtobufStream.ISubscribeError} message SubscribeError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.key);
            if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.error);
            if (message.subscription != null && Object.hasOwnProperty.call(message, "subscription"))
                $root.ProtobufClient.ClientSubscription.encode(message.subscription, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified SubscribeError message, length delimited. Does not implicitly {@link ProtobufStream.SubscribeError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufStream.SubscribeError
         * @static
         * @param {ProtobufStream.ISubscribeError} message SubscribeError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a SubscribeError message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufStream.SubscribeError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufStream.SubscribeError} SubscribeError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufStream.SubscribeError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.error = reader.string();
                        break;
                    case 3:
                        message.subscription = $root.ProtobufClient.ClientSubscription.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a SubscribeError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufStream.SubscribeError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufStream.SubscribeError} SubscribeError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a SubscribeError message.
         * @function verify
         * @memberof ProtobufStream.SubscribeError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key))
                    return "key: string expected";
            if (message.error != null && message.hasOwnProperty("error"))
                if (!$util.isString(message.error))
                    return "error: string expected";
            if (message.subscription != null && message.hasOwnProperty("subscription")) {
                var error = $root.ProtobufClient.ClientSubscription.verify(message.subscription);
                if (error)
                    return "subscription." + error;
            }
            return null;
        };
        /**
         * Creates a SubscribeError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufStream.SubscribeError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufStream.SubscribeError} SubscribeError
         */
        SubscribeError.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufStream.SubscribeError)
                return object;
            var message = new $root.ProtobufStream.SubscribeError();
            if (object.key != null)
                message.key = String(object.key);
            if (object.error != null)
                message.error = String(object.error);
            if (object.subscription != null) {
                if (typeof object.subscription !== "object")
                    throw TypeError(".ProtobufStream.SubscribeError.subscription: object expected");
                message.subscription = $root.ProtobufClient.ClientSubscription.fromObject(object.subscription);
            }
            return message;
        };
        /**
         * Creates a plain object from a SubscribeError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufStream.SubscribeError
         * @static
         * @param {ProtobufStream.SubscribeError} message SubscribeError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.key = "";
                object.error = "";
                object.subscription = null;
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = message.error;
            if (message.subscription != null && message.hasOwnProperty("subscription"))
                object.subscription = $root.ProtobufClient.ClientSubscription.toObject(message.subscription, options);
            return object;
        };
        /**
         * Converts this SubscribeError to JSON.
         * @function toJSON
         * @memberof ProtobufStream.SubscribeError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return SubscribeError;
    })();
    ProtobufStream.UnsubscribeError = (function () {
        /**
         * Properties of an UnsubscribeError.
         * @memberof ProtobufStream
         * @interface IUnsubscribeError
         * @property {string|null} [key] UnsubscribeError key
         * @property {string|null} [error] UnsubscribeError error
         * @property {ProtobufClient.IClientSubscription|null} [subscription] UnsubscribeError subscription
         */
        /**
         * Constructs a new UnsubscribeError.
         * @memberof ProtobufStream
         * @classdesc Represents an UnsubscribeError.
         * @implements IUnsubscribeError
         * @constructor
         * @param {ProtobufStream.IUnsubscribeError=} [properties] Properties to set
         */
        function UnsubscribeError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * UnsubscribeError key.
         * @member {string} key
         * @memberof ProtobufStream.UnsubscribeError
         * @instance
         */
        UnsubscribeError.prototype.key = "";
        /**
         * UnsubscribeError error.
         * @member {string} error
         * @memberof ProtobufStream.UnsubscribeError
         * @instance
         */
        UnsubscribeError.prototype.error = "";
        /**
         * UnsubscribeError subscription.
         * @member {ProtobufClient.IClientSubscription|null|undefined} subscription
         * @memberof ProtobufStream.UnsubscribeError
         * @instance
         */
        UnsubscribeError.prototype.subscription = null;
        /**
         * Creates a new UnsubscribeError instance using the specified properties.
         * @function create
         * @memberof ProtobufStream.UnsubscribeError
         * @static
         * @param {ProtobufStream.IUnsubscribeError=} [properties] Properties to set
         * @returns {ProtobufStream.UnsubscribeError} UnsubscribeError instance
         */
        UnsubscribeError.create = function create(properties) {
            return new UnsubscribeError(properties);
        };
        /**
         * Encodes the specified UnsubscribeError message. Does not implicitly {@link ProtobufStream.UnsubscribeError.verify|verify} messages.
         * @function encode
         * @memberof ProtobufStream.UnsubscribeError
         * @static
         * @param {ProtobufStream.IUnsubscribeError} message UnsubscribeError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnsubscribeError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.key);
            if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.error);
            if (message.subscription != null && Object.hasOwnProperty.call(message, "subscription"))
                $root.ProtobufClient.ClientSubscription.encode(message.subscription, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified UnsubscribeError message, length delimited. Does not implicitly {@link ProtobufStream.UnsubscribeError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufStream.UnsubscribeError
         * @static
         * @param {ProtobufStream.IUnsubscribeError} message UnsubscribeError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnsubscribeError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an UnsubscribeError message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufStream.UnsubscribeError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufStream.UnsubscribeError} UnsubscribeError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnsubscribeError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufStream.UnsubscribeError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.error = reader.string();
                        break;
                    case 3:
                        message.subscription = $root.ProtobufClient.ClientSubscription.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an UnsubscribeError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufStream.UnsubscribeError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufStream.UnsubscribeError} UnsubscribeError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnsubscribeError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an UnsubscribeError message.
         * @function verify
         * @memberof ProtobufStream.UnsubscribeError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnsubscribeError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key))
                    return "key: string expected";
            if (message.error != null && message.hasOwnProperty("error"))
                if (!$util.isString(message.error))
                    return "error: string expected";
            if (message.subscription != null && message.hasOwnProperty("subscription")) {
                var error = $root.ProtobufClient.ClientSubscription.verify(message.subscription);
                if (error)
                    return "subscription." + error;
            }
            return null;
        };
        /**
         * Creates an UnsubscribeError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufStream.UnsubscribeError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufStream.UnsubscribeError} UnsubscribeError
         */
        UnsubscribeError.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufStream.UnsubscribeError)
                return object;
            var message = new $root.ProtobufStream.UnsubscribeError();
            if (object.key != null)
                message.key = String(object.key);
            if (object.error != null)
                message.error = String(object.error);
            if (object.subscription != null) {
                if (typeof object.subscription !== "object")
                    throw TypeError(".ProtobufStream.UnsubscribeError.subscription: object expected");
                message.subscription = $root.ProtobufClient.ClientSubscription.fromObject(object.subscription);
            }
            return message;
        };
        /**
         * Creates a plain object from an UnsubscribeError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufStream.UnsubscribeError
         * @static
         * @param {ProtobufStream.UnsubscribeError} message UnsubscribeError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnsubscribeError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.key = "";
                object.error = "";
                object.subscription = null;
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = message.error;
            if (message.subscription != null && message.hasOwnProperty("subscription"))
                object.subscription = $root.ProtobufClient.ClientSubscription.toObject(message.subscription, options);
            return object;
        };
        /**
         * Converts this UnsubscribeError to JSON.
         * @function toJSON
         * @memberof ProtobufStream.UnsubscribeError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnsubscribeError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return UnsubscribeError;
    })();
    ProtobufStream.SubscriptionStatus = (function () {
        /**
         * Properties of a SubscriptionStatus.
         * @memberof ProtobufStream
         * @interface ISubscriptionStatus
         * @property {Array.<string>|null} [keys] SubscriptionStatus keys
         * @property {Array.<ProtobufClient.IClientSubscription>|null} [subscriptions] SubscriptionStatus subscriptions
         */
        /**
         * Constructs a new SubscriptionStatus.
         * @memberof ProtobufStream
         * @classdesc Represents a SubscriptionStatus.
         * @implements ISubscriptionStatus
         * @constructor
         * @param {ProtobufStream.ISubscriptionStatus=} [properties] Properties to set
         */
        function SubscriptionStatus(properties) {
            this.keys = [];
            this.subscriptions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * SubscriptionStatus keys.
         * @member {Array.<string>} keys
         * @memberof ProtobufStream.SubscriptionStatus
         * @instance
         */
        SubscriptionStatus.prototype.keys = $util.emptyArray;
        /**
         * SubscriptionStatus subscriptions.
         * @member {Array.<ProtobufClient.IClientSubscription>} subscriptions
         * @memberof ProtobufStream.SubscriptionStatus
         * @instance
         */
        SubscriptionStatus.prototype.subscriptions = $util.emptyArray;
        /**
         * Creates a new SubscriptionStatus instance using the specified properties.
         * @function create
         * @memberof ProtobufStream.SubscriptionStatus
         * @static
         * @param {ProtobufStream.ISubscriptionStatus=} [properties] Properties to set
         * @returns {ProtobufStream.SubscriptionStatus} SubscriptionStatus instance
         */
        SubscriptionStatus.create = function create(properties) {
            return new SubscriptionStatus(properties);
        };
        /**
         * Encodes the specified SubscriptionStatus message. Does not implicitly {@link ProtobufStream.SubscriptionStatus.verify|verify} messages.
         * @function encode
         * @memberof ProtobufStream.SubscriptionStatus
         * @static
         * @param {ProtobufStream.ISubscriptionStatus} message SubscriptionStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscriptionStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keys != null && message.keys.length)
                for (var i = 0; i < message.keys.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.keys[i]);
            if (message.subscriptions != null && message.subscriptions.length)
                for (var i = 0; i < message.subscriptions.length; ++i)
                    $root.ProtobufClient.ClientSubscription.encode(message.subscriptions[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified SubscriptionStatus message, length delimited. Does not implicitly {@link ProtobufStream.SubscriptionStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufStream.SubscriptionStatus
         * @static
         * @param {ProtobufStream.ISubscriptionStatus} message SubscriptionStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscriptionStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a SubscriptionStatus message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufStream.SubscriptionStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufStream.SubscriptionStatus} SubscriptionStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscriptionStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufStream.SubscriptionStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.keys && message.keys.length))
                            message.keys = [];
                        message.keys.push(reader.string());
                        break;
                    case 2:
                        if (!(message.subscriptions && message.subscriptions.length))
                            message.subscriptions = [];
                        message.subscriptions.push($root.ProtobufClient.ClientSubscription.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a SubscriptionStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufStream.SubscriptionStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufStream.SubscriptionStatus} SubscriptionStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscriptionStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a SubscriptionStatus message.
         * @function verify
         * @memberof ProtobufStream.SubscriptionStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscriptionStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keys != null && message.hasOwnProperty("keys")) {
                if (!Array.isArray(message.keys))
                    return "keys: array expected";
                for (var i = 0; i < message.keys.length; ++i)
                    if (!$util.isString(message.keys[i]))
                        return "keys: string[] expected";
            }
            if (message.subscriptions != null && message.hasOwnProperty("subscriptions")) {
                if (!Array.isArray(message.subscriptions))
                    return "subscriptions: array expected";
                for (var i = 0; i < message.subscriptions.length; ++i) {
                    var error = $root.ProtobufClient.ClientSubscription.verify(message.subscriptions[i]);
                    if (error)
                        return "subscriptions." + error;
                }
            }
            return null;
        };
        /**
         * Creates a SubscriptionStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufStream.SubscriptionStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufStream.SubscriptionStatus} SubscriptionStatus
         */
        SubscriptionStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufStream.SubscriptionStatus)
                return object;
            var message = new $root.ProtobufStream.SubscriptionStatus();
            if (object.keys) {
                if (!Array.isArray(object.keys))
                    throw TypeError(".ProtobufStream.SubscriptionStatus.keys: array expected");
                message.keys = [];
                for (var i = 0; i < object.keys.length; ++i)
                    message.keys[i] = String(object.keys[i]);
            }
            if (object.subscriptions) {
                if (!Array.isArray(object.subscriptions))
                    throw TypeError(".ProtobufStream.SubscriptionStatus.subscriptions: array expected");
                message.subscriptions = [];
                for (var i = 0; i < object.subscriptions.length; ++i) {
                    if (typeof object.subscriptions[i] !== "object")
                        throw TypeError(".ProtobufStream.SubscriptionStatus.subscriptions: object expected");
                    message.subscriptions[i] = $root.ProtobufClient.ClientSubscription.fromObject(object.subscriptions[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a SubscriptionStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufStream.SubscriptionStatus
         * @static
         * @param {ProtobufStream.SubscriptionStatus} message SubscriptionStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscriptionStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.keys = [];
                object.subscriptions = [];
            }
            if (message.keys && message.keys.length) {
                object.keys = [];
                for (var j = 0; j < message.keys.length; ++j)
                    object.keys[j] = message.keys[j];
            }
            if (message.subscriptions && message.subscriptions.length) {
                object.subscriptions = [];
                for (var j = 0; j < message.subscriptions.length; ++j)
                    object.subscriptions[j] = $root.ProtobufClient.ClientSubscription.toObject(message.subscriptions[j], options);
            }
            return object;
        };
        /**
         * Converts this SubscriptionStatus to JSON.
         * @function toJSON
         * @memberof ProtobufStream.SubscriptionStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscriptionStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return SubscriptionStatus;
    })();
    ProtobufStream.MissedMessages = (function () {
        /**
         * Properties of a MissedMessages.
         * @memberof ProtobufStream
         * @interface IMissedMessages
         * @property {number|Long|null} [numMissedMessages] MissedMessages numMissedMessages
         */
        /**
         * Constructs a new MissedMessages.
         * @memberof ProtobufStream
         * @classdesc Represents a MissedMessages.
         * @implements IMissedMessages
         * @constructor
         * @param {ProtobufStream.IMissedMessages=} [properties] Properties to set
         */
        function MissedMessages(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * MissedMessages numMissedMessages.
         * @member {number|Long} numMissedMessages
         * @memberof ProtobufStream.MissedMessages
         * @instance
         */
        MissedMessages.prototype.numMissedMessages = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * Creates a new MissedMessages instance using the specified properties.
         * @function create
         * @memberof ProtobufStream.MissedMessages
         * @static
         * @param {ProtobufStream.IMissedMessages=} [properties] Properties to set
         * @returns {ProtobufStream.MissedMessages} MissedMessages instance
         */
        MissedMessages.create = function create(properties) {
            return new MissedMessages(properties);
        };
        /**
         * Encodes the specified MissedMessages message. Does not implicitly {@link ProtobufStream.MissedMessages.verify|verify} messages.
         * @function encode
         * @memberof ProtobufStream.MissedMessages
         * @static
         * @param {ProtobufStream.IMissedMessages} message MissedMessages message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MissedMessages.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.numMissedMessages != null && Object.hasOwnProperty.call(message, "numMissedMessages"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.numMissedMessages);
            return writer;
        };
        /**
         * Encodes the specified MissedMessages message, length delimited. Does not implicitly {@link ProtobufStream.MissedMessages.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufStream.MissedMessages
         * @static
         * @param {ProtobufStream.IMissedMessages} message MissedMessages message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MissedMessages.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a MissedMessages message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufStream.MissedMessages
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufStream.MissedMessages} MissedMessages
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MissedMessages.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufStream.MissedMessages();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.numMissedMessages = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a MissedMessages message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufStream.MissedMessages
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufStream.MissedMessages} MissedMessages
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MissedMessages.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a MissedMessages message.
         * @function verify
         * @memberof ProtobufStream.MissedMessages
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MissedMessages.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.numMissedMessages != null && message.hasOwnProperty("numMissedMessages"))
                if (!$util.isInteger(message.numMissedMessages) && !(message.numMissedMessages && $util.isInteger(message.numMissedMessages.low) && $util.isInteger(message.numMissedMessages.high)))
                    return "numMissedMessages: integer|Long expected";
            return null;
        };
        /**
         * Creates a MissedMessages message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufStream.MissedMessages
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufStream.MissedMessages} MissedMessages
         */
        MissedMessages.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufStream.MissedMessages)
                return object;
            var message = new $root.ProtobufStream.MissedMessages();
            if (object.numMissedMessages != null)
                if ($util.Long)
                    (message.numMissedMessages = $util.Long.fromValue(object.numMissedMessages)).unsigned = false;
                else if (typeof object.numMissedMessages === "string")
                    message.numMissedMessages = parseInt(object.numMissedMessages, 10);
                else if (typeof object.numMissedMessages === "number")
                    message.numMissedMessages = object.numMissedMessages;
                else if (typeof object.numMissedMessages === "object")
                    message.numMissedMessages = new $util.LongBits(object.numMissedMessages.low >>> 0, object.numMissedMessages.high >>> 0).toNumber();
            return message;
        };
        /**
         * Creates a plain object from a MissedMessages message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufStream.MissedMessages
         * @static
         * @param {ProtobufStream.MissedMessages} message MissedMessages
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MissedMessages.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.numMissedMessages = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.numMissedMessages = options.longs === String ? "0" : 0;
            if (message.numMissedMessages != null && message.hasOwnProperty("numMissedMessages"))
                if (typeof message.numMissedMessages === "number")
                    object.numMissedMessages = options.longs === String ? String(message.numMissedMessages) : message.numMissedMessages;
                else
                    object.numMissedMessages = options.longs === String ? $util.Long.prototype.toString.call(message.numMissedMessages) : options.longs === Number ? new $util.LongBits(message.numMissedMessages.low >>> 0, message.numMissedMessages.high >>> 0).toNumber() : message.numMissedMessages;
            return object;
        };
        /**
         * Converts this MissedMessages to JSON.
         * @function toJSON
         * @memberof ProtobufStream.MissedMessages
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MissedMessages.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return MissedMessages;
    })();
    ProtobufStream.BandwidthUpdate = (function () {
        /**
         * Properties of a BandwidthUpdate.
         * @memberof ProtobufStream
         * @interface IBandwidthUpdate
         * @property {boolean|null} [ok] BandwidthUpdate ok
         * @property {number|Long|null} [bytesRemaining] BandwidthUpdate bytesRemaining
         * @property {number|Long|null} [bytesUsed] BandwidthUpdate bytesUsed
         */
        /**
         * Constructs a new BandwidthUpdate.
         * @memberof ProtobufStream
         * @classdesc Represents a BandwidthUpdate.
         * @implements IBandwidthUpdate
         * @constructor
         * @param {ProtobufStream.IBandwidthUpdate=} [properties] Properties to set
         */
        function BandwidthUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * BandwidthUpdate ok.
         * @member {boolean} ok
         * @memberof ProtobufStream.BandwidthUpdate
         * @instance
         */
        BandwidthUpdate.prototype.ok = false;
        /**
         * BandwidthUpdate bytesRemaining.
         * @member {number|Long} bytesRemaining
         * @memberof ProtobufStream.BandwidthUpdate
         * @instance
         */
        BandwidthUpdate.prototype.bytesRemaining = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * BandwidthUpdate bytesUsed.
         * @member {number|Long} bytesUsed
         * @memberof ProtobufStream.BandwidthUpdate
         * @instance
         */
        BandwidthUpdate.prototype.bytesUsed = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * Creates a new BandwidthUpdate instance using the specified properties.
         * @function create
         * @memberof ProtobufStream.BandwidthUpdate
         * @static
         * @param {ProtobufStream.IBandwidthUpdate=} [properties] Properties to set
         * @returns {ProtobufStream.BandwidthUpdate} BandwidthUpdate instance
         */
        BandwidthUpdate.create = function create(properties) {
            return new BandwidthUpdate(properties);
        };
        /**
         * Encodes the specified BandwidthUpdate message. Does not implicitly {@link ProtobufStream.BandwidthUpdate.verify|verify} messages.
         * @function encode
         * @memberof ProtobufStream.BandwidthUpdate
         * @static
         * @param {ProtobufStream.IBandwidthUpdate} message BandwidthUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BandwidthUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ok != null && Object.hasOwnProperty.call(message, "ok"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.ok);
            if (message.bytesRemaining != null && Object.hasOwnProperty.call(message, "bytesRemaining"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.bytesRemaining);
            if (message.bytesUsed != null && Object.hasOwnProperty.call(message, "bytesUsed"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.bytesUsed);
            return writer;
        };
        /**
         * Encodes the specified BandwidthUpdate message, length delimited. Does not implicitly {@link ProtobufStream.BandwidthUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufStream.BandwidthUpdate
         * @static
         * @param {ProtobufStream.IBandwidthUpdate} message BandwidthUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BandwidthUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a BandwidthUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufStream.BandwidthUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufStream.BandwidthUpdate} BandwidthUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BandwidthUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufStream.BandwidthUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ok = reader.bool();
                        break;
                    case 2:
                        message.bytesRemaining = reader.int64();
                        break;
                    case 3:
                        message.bytesUsed = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a BandwidthUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufStream.BandwidthUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufStream.BandwidthUpdate} BandwidthUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BandwidthUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a BandwidthUpdate message.
         * @function verify
         * @memberof ProtobufStream.BandwidthUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BandwidthUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ok != null && message.hasOwnProperty("ok"))
                if (typeof message.ok !== "boolean")
                    return "ok: boolean expected";
            if (message.bytesRemaining != null && message.hasOwnProperty("bytesRemaining"))
                if (!$util.isInteger(message.bytesRemaining) && !(message.bytesRemaining && $util.isInteger(message.bytesRemaining.low) && $util.isInteger(message.bytesRemaining.high)))
                    return "bytesRemaining: integer|Long expected";
            if (message.bytesUsed != null && message.hasOwnProperty("bytesUsed"))
                if (!$util.isInteger(message.bytesUsed) && !(message.bytesUsed && $util.isInteger(message.bytesUsed.low) && $util.isInteger(message.bytesUsed.high)))
                    return "bytesUsed: integer|Long expected";
            return null;
        };
        /**
         * Creates a BandwidthUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufStream.BandwidthUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufStream.BandwidthUpdate} BandwidthUpdate
         */
        BandwidthUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufStream.BandwidthUpdate)
                return object;
            var message = new $root.ProtobufStream.BandwidthUpdate();
            if (object.ok != null)
                message.ok = Boolean(object.ok);
            if (object.bytesRemaining != null)
                if ($util.Long)
                    (message.bytesRemaining = $util.Long.fromValue(object.bytesRemaining)).unsigned = false;
                else if (typeof object.bytesRemaining === "string")
                    message.bytesRemaining = parseInt(object.bytesRemaining, 10);
                else if (typeof object.bytesRemaining === "number")
                    message.bytesRemaining = object.bytesRemaining;
                else if (typeof object.bytesRemaining === "object")
                    message.bytesRemaining = new $util.LongBits(object.bytesRemaining.low >>> 0, object.bytesRemaining.high >>> 0).toNumber();
            if (object.bytesUsed != null)
                if ($util.Long)
                    (message.bytesUsed = $util.Long.fromValue(object.bytesUsed)).unsigned = false;
                else if (typeof object.bytesUsed === "string")
                    message.bytesUsed = parseInt(object.bytesUsed, 10);
                else if (typeof object.bytesUsed === "number")
                    message.bytesUsed = object.bytesUsed;
                else if (typeof object.bytesUsed === "object")
                    message.bytesUsed = new $util.LongBits(object.bytesUsed.low >>> 0, object.bytesUsed.high >>> 0).toNumber();
            return message;
        };
        /**
         * Creates a plain object from a BandwidthUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufStream.BandwidthUpdate
         * @static
         * @param {ProtobufStream.BandwidthUpdate} message BandwidthUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BandwidthUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ok = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.bytesRemaining = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.bytesRemaining = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.bytesUsed = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.bytesUsed = options.longs === String ? "0" : 0;
            }
            if (message.ok != null && message.hasOwnProperty("ok"))
                object.ok = message.ok;
            if (message.bytesRemaining != null && message.hasOwnProperty("bytesRemaining"))
                if (typeof message.bytesRemaining === "number")
                    object.bytesRemaining = options.longs === String ? String(message.bytesRemaining) : message.bytesRemaining;
                else
                    object.bytesRemaining = options.longs === String ? $util.Long.prototype.toString.call(message.bytesRemaining) : options.longs === Number ? new $util.LongBits(message.bytesRemaining.low >>> 0, message.bytesRemaining.high >>> 0).toNumber() : message.bytesRemaining;
            if (message.bytesUsed != null && message.hasOwnProperty("bytesUsed"))
                if (typeof message.bytesUsed === "number")
                    object.bytesUsed = options.longs === String ? String(message.bytesUsed) : message.bytesUsed;
                else
                    object.bytesUsed = options.longs === String ? $util.Long.prototype.toString.call(message.bytesUsed) : options.longs === Number ? new $util.LongBits(message.bytesUsed.low >>> 0, message.bytesUsed.high >>> 0).toNumber() : message.bytesUsed;
            return object;
        };
        /**
         * Converts this BandwidthUpdate to JSON.
         * @function toJSON
         * @memberof ProtobufStream.BandwidthUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BandwidthUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return BandwidthUpdate;
    })();
    ProtobufStream.Heartbeat = (function () {
        /**
         * Properties of a Heartbeat.
         * @memberof ProtobufStream
         * @interface IHeartbeat
         * @property {number|Long|null} [time] Heartbeat time
         */
        /**
         * Constructs a new Heartbeat.
         * @memberof ProtobufStream
         * @classdesc Represents a Heartbeat.
         * @implements IHeartbeat
         * @constructor
         * @param {ProtobufStream.IHeartbeat=} [properties] Properties to set
         */
        function Heartbeat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Heartbeat time.
         * @member {number|Long} time
         * @memberof ProtobufStream.Heartbeat
         * @instance
         */
        Heartbeat.prototype.time = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * Creates a new Heartbeat instance using the specified properties.
         * @function create
         * @memberof ProtobufStream.Heartbeat
         * @static
         * @param {ProtobufStream.IHeartbeat=} [properties] Properties to set
         * @returns {ProtobufStream.Heartbeat} Heartbeat instance
         */
        Heartbeat.create = function create(properties) {
            return new Heartbeat(properties);
        };
        /**
         * Encodes the specified Heartbeat message. Does not implicitly {@link ProtobufStream.Heartbeat.verify|verify} messages.
         * @function encode
         * @memberof ProtobufStream.Heartbeat
         * @static
         * @param {ProtobufStream.IHeartbeat} message Heartbeat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Heartbeat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.time);
            return writer;
        };
        /**
         * Encodes the specified Heartbeat message, length delimited. Does not implicitly {@link ProtobufStream.Heartbeat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtobufStream.Heartbeat
         * @static
         * @param {ProtobufStream.IHeartbeat} message Heartbeat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Heartbeat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a Heartbeat message from the specified reader or buffer.
         * @function decode
         * @memberof ProtobufStream.Heartbeat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtobufStream.Heartbeat} Heartbeat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Heartbeat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtobufStream.Heartbeat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.time = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a Heartbeat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtobufStream.Heartbeat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtobufStream.Heartbeat} Heartbeat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Heartbeat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a Heartbeat message.
         * @function verify
         * @memberof ProtobufStream.Heartbeat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Heartbeat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            return null;
        };
        /**
         * Creates a Heartbeat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtobufStream.Heartbeat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtobufStream.Heartbeat} Heartbeat
         */
        Heartbeat.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtobufStream.Heartbeat)
                return object;
            var message = new $root.ProtobufStream.Heartbeat();
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            return message;
        };
        /**
         * Creates a plain object from a Heartbeat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtobufStream.Heartbeat
         * @static
         * @param {ProtobufStream.Heartbeat} message Heartbeat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Heartbeat.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.time = options.longs === String ? "0" : 0;
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            return object;
        };
        /**
         * Converts this Heartbeat to JSON.
         * @function toJSON
         * @memberof ProtobufStream.Heartbeat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Heartbeat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Heartbeat;
    })();
    return ProtobufStream;
})();
module.exports = $root;
//# sourceMappingURL=index.js.map