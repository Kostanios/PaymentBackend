"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TradeClient = void 0;
const tslib_1 = require("tslib");
const v4_1 = tslib_1.__importDefault(require("uuid/v4"));
const constants_1 = require("./constants");
const credentials_1 = require("../util/credentials");
const proto_1 = require("./modules/proto");
const SessionTracker_1 = tslib_1.__importDefault(require("./SessionTracker"));
const helpers_1 = require("../util/helpers");
const logger_1 = tslib_1.__importDefault(require("../util/logger"));
const proto_2 = tslib_1.__importDefault(require("./proto"));
const WebSocketClient_1 = tslib_1.__importDefault(require("./WebSocketClient"));
const errors_1 = require("./errors");
// The number of recent trades kept locally in cache
const tradeCacheLimit = 1000;
// Requests to the trade service time out after 5s
const requestTimeout = 5000;
class TradeClient extends WebSocketClient_1.default {
    constructor(opts) {
        logger_1.default.setLevel(opts.logLevel);
        const tradeOpts = credentials_1.loadTradeCredentials(opts);
        super(tradeOpts);
        if (!(tradeOpts.tradeSubscriptions instanceof Array) ||
            tradeOpts.tradeSubscriptions.length === 0) {
            throw new Error('Missing parameter: tradeSubscriptions');
        }
        // Keep track of subscriptions for reconnecting
        tradeOpts.tradeSubscriptions.forEach((ts) => {
            this.subscriptions[ts.marketID] = proto_2.default.tradeSubscriptionToProto(ts);
        });
        this.session = new SessionTracker_1.default(tradeOpts.tradeSubscriptions);
        this.onDisconnect(() => {
            logger_1.default.debug('disconnected: resetting session');
            this.session.reset();
        });
        this.on(constants_1.EventWSData, (data) => {
            let dataDecoded = null;
            try {
                dataDecoded = proto_1.ProtobufBroker.BrokerUpdateMessage.decode(data);
            }
            catch (e) {
                this.error('Failed to deserialize ProtobufBroker message');
                return;
            }
            this.brokerMessageHandler(dataDecoded);
        });
        this.orders = {};
        this.trades = {};
        this.positions = {};
        // this.balances = [];
    }
    onReady(fn) {
        this.session.on('ready', () => {
            fn();
        });
    }
    onOrdersUpdate(fn) {
        this.on(constants_1.EventOrdersUpdate, (orders) => {
            fn(orders);
        });
    }
    onTradesUpdate(fn) {
        this.on(constants_1.EventTradesUpdate, (trades) => {
            fn(trades);
        });
    }
    onPositionsUpdate(fn) {
        this.on(constants_1.EventPositionsUpdate, (positions) => {
            fn(positions);
        });
    }
    placeOrder(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.session.isReady()) {
                throw errors_1.errNotInitialized;
            }
            if (opts.marketID == null) {
                throw new Error('place order opts missing market id');
            }
            logger_1.default.debug('place order request %o', JSON.stringify(opts));
            const startTime = new Date();
            const response = yield this.makeRequest(opts.marketID, proto_1.ProtobufBroker.PlaceOrderRequest.create({
                order: proto_2.default.placeOrderOptToProto(opts)
            }), opts.requestID);
            if (!response.placeOrderResult || !response.placeOrderResult.order) {
                throw errors_1.errPlaceOrderBadResponse;
            }
            const po = proto_2.default.privateOrderFromProto(response.placeOrderResult.order);
            if (!po) {
                logger_1.default.debug('failed to serialize order result %o', response.placeOrderResult.order);
                throw errors_1.errPlaceOrderBadResponse;
            }
            logger_1.default.debug('order placed', `${new Date().getTime() - startTime.getTime()}s`);
            return po;
        });
    }
    cancelOrder(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (typeof opts.orderID !== 'string' || opts.orderID === '') {
                throw new Error(`invalid order id: ${opts.orderID}`);
            }
            logger_1.default.debug('sending cancel order request');
            const response = yield this.makeRequest(opts.marketID, proto_1.ProtobufBroker.CancelOrderRequest.create({
                orderId: opts.orderID
            }), opts.requestID);
            logger_1.default.debug('order resolution %o', response);
            if (!response.cancelOrderResult || response.cancelOrderResult.orderId === null) {
                throw errors_1.errCancelOrderBadResponse;
            }
        });
    }
    makeRequest(marketID, request, requestID) {
        const reqID = requestID || v4_1.default();
        let brokerRequest;
        if (request instanceof proto_1.ProtobufBroker.PlaceOrderRequest) {
            brokerRequest = proto_1.ProtobufBroker.BrokerRequest.create({
                id: reqID,
                marketId: Number(marketID),
                placeOrderRequest: request
            });
        }
        else if (request instanceof proto_1.ProtobufBroker.CancelOrderRequest) {
            brokerRequest = proto_1.ProtobufBroker.BrokerRequest.create({
                id: reqID,
                marketId: Number(marketID),
                cancelOrderRequest: request
            });
        }
        else {
            throw new Error('internal error: invalid request');
        }
        this.send(proto_1.ProtobufBroker.BrokerRequest.encode(brokerRequest).finish());
        return new Promise((resolve, reject) => {
            const timeoutTimer = setTimeout(() => {
                reject();
            }, requestTimeout);
            // TODO (wells) look into how "once" works; could this be a memory leak?
            this.once(reqID, (response) => {
                clearTimeout(timeoutTimer);
                if (response.error !== 0) {
                    reject(`error: ${response.message}`);
                }
                else {
                    resolve(response);
                }
            });
        });
    }
    brokerMessageHandler(message) {
        const marketID = helpers_1.getNumber(message.marketId);
        switch (message.Update) {
            case 'authenticationResult':
                this.emit(constants_1.EventWSAuthResult, message.authenticationResult);
                break;
            case 'ordersUpdate':
                logger_1.default.debug('call orders update handler %o', message);
                if (message.ordersUpdate) {
                    this.ordersUpdateHandler(marketID, message.ordersUpdate);
                }
                break;
            case 'tradesUpdate':
                if (message.tradesUpdate) {
                    this.tradesUpdateHandler(marketID, message.tradesUpdate);
                }
                break;
            case 'balancesUpdate':
                // logger.debug("balance update %o", JSON.stringify(message));
                // if (message.balancesUpdate) {
                //   this.balancesUpdateHandler(marketID, message.balancesUpdate);
                // }
                break;
            case 'positionsUpdate':
                if (message.positionsUpdate) {
                    this.positionsUpdateHandler(marketID, message.positionsUpdate);
                }
                break;
            case 'subscriptionResult':
                if (message.subscriptionResult) {
                    this.subscriptionResultHandler(message.subscriptionResult);
                }
                break;
            case 'sessionStatusUpdate':
                if (message.sessionStatusUpdate && !this.session.isModuleReady(marketID, 'initialize')) {
                    this.sessionStatusUpdateHandler(marketID, message.sessionStatusUpdate);
                }
                break;
            case 'requestResolutionUpdate':
                if (message.requestResolutionUpdate) {
                    this.requestResolutionUpdateHandler(message.requestResolutionUpdate);
                }
                break;
            default:
            // unsupported type; no-op
        }
    }
    ordersUpdateHandler(marketID, ordersUpdate) {
        if (ordersUpdate.orders === null || ordersUpdate.orders === undefined) {
            logger_1.default.debug('received empty orders update');
            return;
        }
        const newOrders = [];
        ordersUpdate.orders.forEach((o) => {
            const order = proto_2.default.privateOrderFromProto(o);
            if (order != null) {
                newOrders.push(order);
            }
        });
        this.orders[marketID] = newOrders;
        logger_1.default.debug('orders update %o', newOrders);
        this.emit(constants_1.EventOrdersUpdate, newOrders);
        this.session.setModuleReady(marketID, 'orderUpdates');
    }
    tradesUpdateHandler(marketID, tradesUpdate) {
        if (tradesUpdate.trades === null || tradesUpdate.trades === undefined) {
            return;
        }
        const newTrades = [];
        tradesUpdate.trades.forEach((tradeProto) => {
            const trade = proto_2.default.privateTradeFromProto(tradeProto);
            if (trade) {
                newTrades.push(trade);
            }
        });
        if (!this.trades[marketID]) {
            this.trades[marketID] = [];
        }
        // Add new trades to old trades
        this.trades[marketID] = this.trades[marketID].concat(newTrades);
        // Trim cache if it's over the limit
        if (this.trades[marketID].length > tradeCacheLimit) {
            this.trades[marketID] = this.trades[marketID].slice(0, tradeCacheLimit);
        }
        logger_1.default.debug('trades update %o', newTrades);
        this.emit(constants_1.EventTradesUpdate, newTrades);
        this.session.setModuleReady(marketID, 'tradeUpdates');
    }
    // private balancesUpdateHandler(
    //   marketID: string,
    //   balancesUpdate: ProtobufBroker.IBalancesUpdate
    // ) {
    //   if (!balancesUpdate.balances) {
    //     return;
    //   }
    //   // Each balance can apply to multiple markets, so we find the balances index first
    //   let balancesIndex = -1;
    //   for (let i = 0; i < this.balances.length; i++) {
    //     for (const j of this.balances[i].marketIDs) {
    //       if (j === marketID) {
    //         balancesIndex = i;
    //         break;
    //       }
    //     }
    //     if (balancesIndex > -1) {
    //       break;
    //     }
    //   }
    //   if (balancesIndex === -1) {
    //     const exchangeBalances: ExchangeBalances = {
    //       marketIDs: [marketID],
    //       spot: [],
    //       margin: []
    //     };
    //   }
    //   balancesUpdate.balances.forEach(balancesProto => {
    //     const balance = proto.balancesFromProto(balancesProto);
    //     if (!balance) {
    //       return;
    //     }
    //   });
    //   this.session.setModuleReady(marketID, "balances");
    //   logger.debug("balances update");
    //   // TODO update balances cache
    //   // TODO emit exchange balances
    //   // this.emit(EventBalancesUpdate, exchangeBalances);
    // }
    positionsUpdateHandler(marketID, positionsUpdate) {
        if (positionsUpdate.positions === null || positionsUpdate.positions === undefined) {
            return;
        }
        const newPositions = [];
        positionsUpdate.positions.forEach((positionProto) => {
            const position = proto_2.default.privatePositionFromProto(positionProto);
            if (!position) {
                return;
            }
            newPositions.push(position);
        });
        this.positions[marketID] = newPositions;
        logger_1.default.debug('positions update %o', newPositions);
        this.emit(constants_1.EventPositionsUpdate, newPositions);
        this.session.setModuleReady(marketID, 'positionUpdates');
    }
    subscriptionResultHandler(subResult) {
        if (subResult.failed instanceof Array) {
            subResult.failed.forEach((e) => {
                let keyStr = '';
                if (e.key) {
                    keyStr = ` for "${e.key}"`;
                }
                this.error(`trading session failed${keyStr}: ${e.error}`);
            });
        }
    }
    sessionStatusUpdateHandler(marketID, sessionStatusUpdate) {
        if (sessionStatusUpdate.initialized === true) {
            logger_1.default.debug('session initialized');
            this.session.setModuleReady(marketID, 'initialize');
        }
    }
    requestResolutionUpdateHandler(requestResolution) {
        logger_1.default.debug('request resolution %o', requestResolution);
        if (requestResolution.id != null) {
            this.emit(requestResolution.id, requestResolution);
        }
    }
}
exports.TradeClient = TradeClient;
//# sourceMappingURL=TradeClient.js.map