"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.marketUpdateFromProto = void 0;
const sideFromProto_1 = require("./sideFromProto");
const helpers_1 = require("../../util/helpers");
const constants_1 = require("./constants");
function publicOrderFromProto(publicOrder) {
    if (!publicOrder.priceStr || !publicOrder.amountStr) {
        return null;
    }
    return {
        price: publicOrder.priceStr,
        amount: publicOrder.amountStr
    };
}
function publicOrdersFromProto(publicOrders) {
    const orders = [];
    if (publicOrders) {
        publicOrders.forEach((order) => {
            const publicOrder = publicOrderFromProto(order);
            if (publicOrder !== null) {
                orders.push(publicOrder);
            }
        });
    }
    return orders;
}
function periodFromProto(period) {
    if (constants_1.periodNames[period]) {
        return constants_1.periodNames[period];
    }
    return null;
}
function intervalFromProto(intervalUpdate) {
    if (!intervalUpdate.periodName ||
        !intervalUpdate.closetime ||
        !intervalUpdate.ohlc ||
        !intervalUpdate.ohlc.openStr ||
        !intervalUpdate.ohlc.highStr ||
        !intervalUpdate.ohlc.lowStr ||
        !intervalUpdate.ohlc.closeStr ||
        !intervalUpdate.volumeBaseStr ||
        !intervalUpdate.volumeQuoteStr) {
        return null;
    }
    const period = periodFromProto(intervalUpdate.periodName);
    if (!period) {
        return null;
    }
    const ohlc = {
        open: intervalUpdate.ohlc.openStr,
        high: intervalUpdate.ohlc.highStr,
        low: intervalUpdate.ohlc.lowStr,
        close: intervalUpdate.ohlc.closeStr
    };
    return {
        period,
        ohlc,
        closeTime: new Date(helpers_1.getNumber(intervalUpdate.closetime) * 1000),
        volumeBase: intervalUpdate.volumeBaseStr,
        volumeQuote: intervalUpdate.volumeQuoteStr
    };
}
function sparklineFromProto(sparklineUpdate) {
    if (!sparklineUpdate.time || !sparklineUpdate.priceStr) {
        return null;
    }
    return {
        timestamp: helpers_1.getDateFromSecs(sparklineUpdate.time),
        price: sparklineUpdate.priceStr
    };
}
function summaryFromProto(summaryUpdate) {
    if (!summaryUpdate.lastStr ||
        !summaryUpdate.highStr ||
        !summaryUpdate.lowStr ||
        !summaryUpdate.volumeBaseStr ||
        !summaryUpdate.volumeQuoteStr ||
        !summaryUpdate.changeAbsoluteStr ||
        !summaryUpdate.changePercentStr ||
        !summaryUpdate.numTrades) {
        return null;
    }
    return {
        last: summaryUpdate.lastStr,
        high: summaryUpdate.highStr,
        low: summaryUpdate.lowStr,
        volumeBase: summaryUpdate.volumeBaseStr,
        volumeQuote: summaryUpdate.volumeQuoteStr,
        changeAbsolute: summaryUpdate.changeAbsoluteStr,
        changePercent: summaryUpdate.changePercentStr,
        numTrades: summaryUpdate.numTrades
    };
}
function intervalsFromProto(intervalsUpdate) {
    if (!intervalsUpdate.intervals) {
        return null;
    }
    const intervals = [];
    intervalsUpdate.intervals.forEach((intervalProto) => {
        const i = intervalFromProto(intervalProto);
        if (i) {
            intervals.push(i);
        }
    });
    return intervals;
}
function publicTradesFromProto(tradesUpdate) {
    if (!tradesUpdate.trades) {
        return null;
    }
    const publicTrades = [];
    tradesUpdate.trades.forEach((trade) => {
        if (!trade || !trade.externalId || !trade.priceStr || !trade.amountStr) {
            return;
        }
        if (trade.orderSide !== 0 && trade.orderSide !== 1 && trade.orderSide !== 2) {
            return;
        }
        const side = sideFromProto_1.publicTradeSideFromProto(trade.orderSide);
        if (!side) {
            return;
        }
        let timestamp;
        if (trade.timestampNano && trade.timestampNano > 0) {
            timestamp = helpers_1.getDateFromNs(trade.timestampNano);
        }
        else if (trade.timestamp && trade.timestamp > 0) {
            timestamp = helpers_1.getDateFromSecs(trade.timestamp);
        }
        else {
            return;
        }
        publicTrades.push({
            externalID: trade.externalId,
            timestamp,
            side: side,
            price: trade.priceStr,
            amount: trade.amountStr
        });
    });
    return publicTrades;
}
function orderBookSpreadFromProto(orderBookSpread) {
    if (orderBookSpread.timestamp == null ||
        orderBookSpread.bid == null ||
        orderBookSpread.ask == null) {
        return null;
    }
    const bid = publicOrderFromProto(orderBookSpread.bid);
    if (!bid) {
        return null;
    }
    const ask = publicOrderFromProto(orderBookSpread.ask);
    if (!ask) {
        return null;
    }
    const ts = helpers_1.getDateFromSecs(orderBookSpread.timestamp);
    if (ts.getTime() === 0) {
        return null;
    }
    return {
        timestamp: ts,
        bid,
        ask
    };
}
function orderBookDeltaFromProto(orderBookDelta) {
    if (orderBookDelta.seqNum == null) {
        return null;
    }
    let bidSet = [];
    let bidRemove = [];
    if (orderBookDelta.bids) {
        bidSet = publicOrdersFromProto(orderBookDelta.bids.set);
        if (orderBookDelta.bids.removeStr) {
            bidRemove = orderBookDelta.bids.removeStr;
        }
    }
    let askSet = [];
    let askRemove = [];
    if (orderBookDelta.asks) {
        askSet = publicOrdersFromProto(orderBookDelta.asks.set);
        if (orderBookDelta.asks.removeStr) {
            askRemove = orderBookDelta.asks.removeStr;
        }
    }
    return {
        seqNum: orderBookDelta.seqNum,
        bids: {
            set: bidSet,
            remove: bidRemove
        },
        asks: {
            set: askSet,
            remove: askRemove
        }
    };
}
function orderBookSnapshotFromProto(orderBookSnapshot) {
    if (orderBookSnapshot.seqNum == null) {
        return null;
    }
    return {
        seqNum: orderBookSnapshot.seqNum,
        bids: publicOrdersFromProto(orderBookSnapshot.bids),
        asks: publicOrdersFromProto(orderBookSnapshot.asks)
    };
}
function marketFromProto(market) {
    if (!market.marketId || !market.exchangeId || !market.currencyPairId) {
        return null;
    }
    return {
        id: helpers_1.getNumber(market.marketId),
        exchangeID: helpers_1.getNumber(market.exchangeId),
        currencyPairID: helpers_1.getNumber(market.currencyPairId)
    };
}
function marketUpdateFromProto(marketUpdate) {
    if (marketUpdate.market == null) {
        return null;
    }
    const market = marketFromProto(marketUpdate.market);
    if (!market) {
        return null;
    }
    if (marketUpdate.orderBookUpdate) {
        const orderBookSnapshot = orderBookSnapshotFromProto(marketUpdate.orderBookUpdate);
        if (orderBookSnapshot) {
            return {
                market,
                orderBookSnapshot
            };
        }
    }
    if (marketUpdate.orderBookDeltaUpdate) {
        const orderBookDelta = orderBookDeltaFromProto(marketUpdate.orderBookDeltaUpdate);
        if (orderBookDelta) {
            return {
                market,
                orderBookDelta
            };
        }
    }
    if (marketUpdate.orderBookSpreadUpdate) {
        const orderBookSpread = orderBookSpreadFromProto(marketUpdate.orderBookSpreadUpdate);
        if (orderBookSpread) {
            return {
                market,
                orderBookSpread
            };
        }
    }
    if (marketUpdate.tradesUpdate) {
        const trades = publicTradesFromProto(marketUpdate.tradesUpdate);
        if (trades) {
            return {
                market,
                trades
            };
        }
    }
    if (marketUpdate.intervalsUpdate) {
        const intervals = intervalsFromProto(marketUpdate.intervalsUpdate);
        if (intervals) {
            return {
                market,
                intervals
            };
        }
    }
    if (marketUpdate.summaryUpdate) {
        const summary = summaryFromProto(marketUpdate.summaryUpdate);
        if (summary) {
            return {
                market,
                summary
            };
        }
    }
    if (marketUpdate.sparklineUpdate) {
        const sparkline = sparklineFromProto(marketUpdate.sparklineUpdate);
        if (sparkline) {
            return {
                market,
                sparkline
            };
        }
    }
    return null;
}
exports.marketUpdateFromProto = marketUpdateFromProto;
//# sourceMappingURL=marketUpdateFromProto.js.map