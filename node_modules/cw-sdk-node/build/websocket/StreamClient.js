"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamClient = void 0;
const tslib_1 = require("tslib");
const constants_1 = require("./constants");
const credentials_1 = require("../util/credentials");
const proto_1 = require("./modules/proto");
const logger_1 = tslib_1.__importDefault(require("../util/logger"));
const proto_2 = tslib_1.__importDefault(require("./proto"));
const WebSocketClient_1 = tslib_1.__importDefault(require("./WebSocketClient"));
class StreamClient extends WebSocketClient_1.default {
    constructor(opts) {
        logger_1.default.setLevel(opts.logLevel);
        const streamOpts = credentials_1.loadStreamCredentials(opts);
        super(streamOpts);
        if (Array.isArray(streamOpts.subscriptions) && streamOpts.subscriptions.length > 0) {
            // Keep track of subscriptions for reconnecting
            streamOpts.subscriptions.forEach((s) => {
                this.subscriptions[s] = proto_2.default.keyToStreamSubscription(s);
            });
        }
        this.on(constants_1.EventWSData, (data) => {
            let dataDecoded = null;
            try {
                dataDecoded = proto_1.ProtobufStream.StreamMessage.decode(data);
            }
            catch (e) {
                this.error('Failed to deserialize ProtobufStream message');
                return;
            }
            this.streamMessageHandler(dataDecoded);
        });
    }
    subscribe(keys) {
        const subs = [];
        keys.forEach((k) => {
            subs.push(proto_2.default.keyToStreamSubscription(k));
            this.subscriptions[k] = proto_2.default.keyToStreamSubscription(k);
        });
        if (this.connState === constants_1.StateConnected) {
            const subMsg = proto_1.ProtobufClient.ClientMessage.create({
                subscribe: proto_1.ProtobufClient.ClientSubscribeMessage.create({
                    subscriptions: subs
                })
            });
            this.send(proto_1.ProtobufClient.ClientMessage.encode(subMsg).finish());
        }
    }
    unsubscribe(keys) {
        const subs = [];
        keys.forEach((k) => {
            subs.push(proto_2.default.keyToStreamSubscription(k));
            delete this.subscriptions[k];
        });
        if (this.connState === constants_1.StateConnected) {
            const subMsg = proto_1.ProtobufClient.ClientMessage.create({
                unsubscribe: proto_1.ProtobufClient.ClientUnsubscribeMessage.create({
                    subscriptions: subs
                })
            });
            this.send(proto_1.ProtobufClient.ClientMessage.encode(subMsg).finish());
        }
    }
    onPairUpdate(fn) {
        this.on(constants_1.EventPairUpdate, (pairUpdateProto) => {
            const pairUpdate = proto_2.default.pairUpdateFromProto(pairUpdateProto);
            if (pairUpdate) {
                fn(pairUpdate);
            }
        });
    }
    onMarketUpdate(fn) {
        this.on(constants_1.EventMarketUpdate, (marketUpdateProto) => {
            const marketUpdate = proto_2.default.marketUpdateFromProto(marketUpdateProto);
            if (marketUpdate) {
                fn(marketUpdate);
            }
        });
    }
    // Private message handler for incoming stream data. Messages are then passed
    // to the correct public handler
    streamMessageHandler(message) {
        switch (message.body) {
            case 'authenticationResult':
                this.emit(constants_1.EventWSAuthResult, message.authenticationResult);
                break;
            case 'marketUpdate':
                this.emit(constants_1.EventMarketUpdate, message.marketUpdate);
                break;
            case 'pairUpdate':
                this.emit(constants_1.EventPairUpdate, message.pairUpdate);
                break;
            case 'subscriptionResult':
                if (message.subscriptionResult) {
                    this.unsubscriptionResultHandler(message.subscriptionResult);
                }
                break;
            case 'unsubscriptionResult':
                if (message.unsubscriptionResult) {
                    this.subscriptionResultHandler(message.unsubscriptionResult);
                }
                break;
            default:
                // unsupported type; no-op
                logger_1.default.debug('stream received unsupported proto type');
        }
    }
    subscriptionResultHandler(subResultProto) {
        const subResult = proto_2.default.subscriptionResultFromProto(subResultProto);
        if (subResult === null) {
            return;
        }
        if (subResult.failed.length > 0) {
            subResult.failed.forEach((e) => {
                this.error(`subscribe failed for "${e.subscription}": ${e.error}`);
            });
        }
        this.emit(constants_1.EventSubscriptionResult, subResult);
    }
    unsubscriptionResultHandler(unsubResultProto) {
        const unsubResult = proto_2.default.subscriptionResultFromProto(unsubResultProto);
        if (!unsubResult) {
            return;
        }
        if (unsubResult.failed.length > 0) {
            unsubResult.failed.forEach((e) => {
                this.error(`unsubscribe failed for ${e.subscription}: ${e.error}`);
            });
        }
    }
}
exports.StreamClient = StreamClient;
//# sourceMappingURL=StreamClient.js.map