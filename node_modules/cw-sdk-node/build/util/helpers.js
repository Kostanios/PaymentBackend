"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.binarySearchOrders = exports.sortDeltaItems = exports.transformSnapshot = exports.symbolString = exports.getDateFromNs = exports.getDateFromMs = exports.getDateFromSecs = exports.getString = exports.getNumber = exports.guardIsLong = void 0;
const long_1 = require("long");
const decimal_js_light_1 = require("decimal.js-light");
function guardIsLong(value) {
    return long_1.isLong(value);
}
exports.guardIsLong = guardIsLong;
function getNumber(n) {
    return guardIsLong(n) ? n.toNumber() : n;
}
exports.getNumber = getNumber;
function getString(n) {
    return String(getNumber(n));
}
exports.getString = getString;
function getDateFromSecs(n) {
    return new Date(getNumber(n) * 1000);
}
exports.getDateFromSecs = getDateFromSecs;
function getDateFromMs(n) {
    return new Date(getNumber(n));
}
exports.getDateFromMs = getDateFromMs;
function getDateFromNs(n) {
    return new Date(getNumber(n) / 1000000);
}
exports.getDateFromNs = getDateFromNs;
// Get rid of stupid Symbol() formatting
function symbolString(s) {
    return s.toString().substr(7, s.toString().length - 8);
}
exports.symbolString = symbolString;
function transformSnapshot(orderBook) {
    return {
        seqNum: orderBook.seqNum,
        asks: orderBook.asks.map((ask) => ({
            price: ask[0].toString(),
            amount: ask[1].toString()
        })),
        bids: orderBook.bids.map((bid) => ({
            price: bid[0].toString(),
            amount: bid[1].toString()
        }))
    };
}
exports.transformSnapshot = transformSnapshot;
function sortDeltaItems(i, j, reverse = false) {
    const iPriceDecimal = new decimal_js_light_1.Decimal(i.order.price);
    const jPriceDecimal = new decimal_js_light_1.Decimal(j.order.price);
    const comparison = reverse ? jPriceDecimal.cmp(iPriceDecimal) : iPriceDecimal.cmp(jPriceDecimal);
    if (comparison !== 0) {
        return comparison;
    }
    if (i.index < j.index) {
        i.overridden = true;
        return 1;
    }
    else {
        j.overridden = true;
        return -1;
    }
}
exports.sortDeltaItems = sortDeltaItems;
function binarySearchOrders(orders, price, startIndex, reverse = false) {
    const priceDecimal = new decimal_js_light_1.Decimal(price);
    let end = orders.length;
    let start = startIndex;
    while (start < end) {
        const currentIndex = start + Math.floor((end - start) / 2);
        const order = orders[currentIndex];
        const comparison = priceDecimal.cmp(new decimal_js_light_1.Decimal(order.price));
        if (comparison === 0) {
            return { exists: true, index: currentIndex };
        }
        else {
            if (reverse != comparison < 0) {
                end = currentIndex;
            }
            else {
                start = currentIndex + 1;
            }
        }
    }
    return { exists: false, index: start };
}
exports.binarySearchOrders = binarySearchOrders;
//# sourceMappingURL=helpers.js.map